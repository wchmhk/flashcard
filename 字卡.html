<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <script src="https://apis.google.com/js/api.js"></script>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="字卡">
    <link rel="apple-touch-icon" href="圖標URL.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>字卡程式</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <!-- Quill.js 編輯器相關文件 -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.0-rc.2/dist/quill.snow.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.0-rc.2/dist/quill.min.js"></script>

    <script>

    // Google API 密鑰配置
    let GOOGLE_API_KEY = '';

    // 從localStorage加載保存的API密鑰(如果有)
    if (localStorage.getItem('google_api_key')) {
        GOOGLE_API_KEY = localStorage.getItem('google_api_key');
    }

    </script>

    <style>

        /* 共用編輯器容器樣式 */
        .card-editor-container {
          margin-bottom: 1.5rem;
        }

        /* 上下輸入區容器 */
        .combined-editors {
          border: 1px solid rgb(209, 213, 219);
          border-bottom-left-radius: 0.5rem;
          border-bottom-right-radius: 0.5rem;
          overflow: hidden;
        }

        .dark .combined-editors {
          border-color: rgb(75, 85, 99);
        }

        /* 輸入區樣式 */
        .editor-section {
          position: relative;
          background-color: white;
        }

        .dark .editor-section {
          background-color: rgb(31, 41, 55);
        }

        /* 正面和背面輸入區分隔線 */
        .editor-divider {
          height: 1px;
          background-color: rgb(229, 231, 235);
        }

        .dark .editor-divider {
          background-color: rgb(75, 85, 99);
        }

        /* 編輯器內容區域 */
        .editor-content {
          padding: 0.75rem;
          min-height: 80px;
        }

        .editor-content .ql-editor {
          padding: 0;
          min-height: 80px;
        }

        /* 圖片按鈕樣式 */
        .image-btn {
          padding: 0.6rem;
          border: 1px solid rgb(209, 213, 219);
          border-radius: 0.5rem;
          background-color: rgb(243, 244, 246);
          transition: background-color 0.2s;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .dark .image-btn {
          border-color: rgb(75, 85, 99);
          background-color: rgb(55, 65, 81);
        }

        .image-btn:hover {
          background-color: rgb(229, 231, 235);
        }

        .dark .image-btn:hover {
          background-color: rgb(75, 85, 99);
        }

        /* 圖片預覽區域調整 */
        #frontImagePreview, #backImagePreview {
          margin-top: 0.5rem;
        }

        /* 自定義多選下拉框樣式 */
        .multiselect-dropdown {
            position: relative;
        }
        .multiselect-options {
            position: absolute;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
        }
        .multiselect-option {
            cursor: pointer;
        }
        .multiselect-option:hover {
            background-color: rgba(93, 92, 222, 0.1);
        }
        .multiselect-option.selected {
            background-color: rgba(93, 92, 222, 0.2);
        }

        /* 改進表單佈局 */
        .input-group {
            display: flex;
            align-items: stretch;
            position: relative;
        }

        .input-group .ql-container {
            flex-grow: 1;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .input-group button {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        /* 拖拽上傳相關樣式 */
        .drag-area {
            position: relative;
            width: 100%;
        }

        .drag-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(93, 92, 222, 0.1);
            border: 2px dashed #5D5CDE;
            border-radius: 0.5rem;
            pointer-events: none;
            z-index: 10;
        }

        .drag-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #5D5CDE;
            font-weight: 500;
            text-align: center;
            pointer-events: none;
        }

        .input-group.drag-over .drag-overlay {
            display: block;
        }

        /* 暗模式拖拽樣式調整 */
        .dark .drag-overlay {
            background-color: rgba(93, 92, 222, 0.2);
        }

        /* Quill編輯器樣式調整 */
        .ql-toolbar.ql-snow {
            border-color: rgb(209, 213, 219);
            border-top-right-radius: 0.5rem;
            border-top-left-radius: 0.5rem;
        }

        .dark .ql-toolbar.ql-snow {
            border-color: rgb(75, 85, 99);
            background-color: rgb(31, 41, 55);
        }

        .ql-container.ql-snow {
            border-color: rgb(209, 213, 219);
            border-bottom-right-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }

        .dark .ql-container.ql-snow {
            border-color: rgb(75, 85, 99);
            background-color: rgb(31, 41, 55);
            color: white;
        }

        .dark .ql-toolbar.ql-snow .ql-picker,
        .dark .ql-toolbar.ql-snow .ql-stroke {
            color: white;
            stroke: white;
        }

        .dark .ql-toolbar.ql-snow .ql-fill {
            fill: white;
        }

        .dark .ql-snow .ql-picker-options {
            background-color: rgb(31, 41, 55);
        }

        /* 修改編輯器和按鈕布局相關樣式 */
        .editor-with-button {
            display: flex;
            flex-direction: column; /* 改為垂直排列 */
            align-items: stretch;
            width: 100%;
            position: relative;
        }

        /* 編輯器容器樣式 */
        .editor-with-button .ql-container.ql-snow {
            flex-grow: 1;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom: none; /* 移除底部邊框 */
            min-height: 100px;
        }

        /* 工具欄樣式 */
        .editor-with-button .ql-toolbar.ql-snow {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            width: 100%; /* 確保寬度與編輯器一致 */
        }

        /* 按鈕區域樣式 */
        .editor-with-button .button-container {
            display: flex;
            width: 100%;
        }

        /* 按鈕樣式 */
        .editor-with-button button {
            padding: 0.5rem 1rem;
            border: 1px solid rgb(209, 213, 219);
            border-top: none; /* 移除頂部邊框使其與編輯器連接 */
            border-radius: 0 0 0.5rem 0.5rem; /* 只保留底部圓角 */
            background-color: rgb(243, 244, 246);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            width: 100%; /* 讓按鈕填滿整個寬度 */
        }

        .dark .editor-with-button button {
            background-color: rgb(55, 65, 81);
            border-color: rgb(75, 85, 99);
        }

        .editor-with-button button:hover {
            background-color: rgb(229, 231, 235);
        }

        .dark .editor-with-button button:hover {
            background-color: rgb(75, 85, 99);
        }

        /* 字卡正面背面分隔線 */
        #cardFront, #cardBack {
            word-break: break-word;
        }

        /* 複習界面的字卡樣式 */
        #cardFront p, #cardBack p,
        #frontText, #backText {
            margin-bottom: 0.5rem;
        }

        /* 確保Quill編輯器在模態框中的可見性 */
        .modal-quill-editor {
            z-index: 100;
        }

        /* 工作表列表樣式 */
        .sheet-tab {
            cursor: pointer;
            padding: 0.5rem 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.25rem;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            display: inline-block;
        }

        .sheet-tab.active {
            background-color: #5D5CDE;
            color: white;
            border-color: #5D5CDE;
        }

        .dark .sheet-tab {
            border-color: #4b5563;
        }

        .dark .sheet-tab.active {
            background-color: #5D5CDE;
            border-color: #5D5CDE;
        }

        /* Quill編輯器對齊樣式 */
        .ql-align-center {
          text-align: center;
        }

        .ql-align-right {
          text-align: right;
        }

        .ql-align-justify {
          text-align: justify;
        }

        /* 確保卡片顯示區域也應用相同的樣式 */
        #cardFront .ql-align-center,
        #cardBack .ql-align-center,
        #frontText .ql-align-center,
        #backText .ql-align-center {
          text-align: center;
        }

        #cardFront .ql-align-right,
        #cardBack .ql-align-right,
        #frontText .ql-align-right,
        #backText .ql-align-right {
          text-align: right;
        }

        #cardFront .ql-align-justify,
        #cardBack .ql-align-justify,
        #frontText .ql-align-justify,
        #backText .ql-align-justify {
          text-align: justify;
        }

        /* 處理圖片對齊 */
        .ql-align-center img {
          display: block;
          margin-left: auto;
          margin-right: auto;
        }

        .ql-align-right img {
          display: block;
          margin-left: auto;
          margin-right: 0;
        }

        .ql-align-justify img {
          display: block;
          width: 100%;
          height: auto;
        }

        /* 根據字型大小調整圖片尺寸 - 優化版 */
        .ql-size-small img {
          max-width: 40%;
          height: auto;
          transition: all 0.3s ease;
        }

        .ql-editor .ql-size-small img {
          margin: 5px auto;
          display: block;
        }

        .ql-size-large img {
          max-width: 75%;
          height: auto;
          transition: all 0.3s ease;
        }

        .ql-size-huge img {
          max-width: 100%;
          height: auto;
          transition: all 0.3s ease;
        }

        /* 確保卡片顯示時也保持這些樣式 */
        #cardFront .ql-align-center img,
        #cardBack .ql-align-center img,
        #frontText .ql-align-center img,
        #backText .ql-align-center img {
          display: block;
          margin-left: auto;
          margin-right: auto;
        }

        #cardFront .ql-align-right img,
        #cardBack .ql-align-right img,
        #frontText .ql-align-right img,
        #backText .ql-align-right img {
          display: block;
          margin-left: auto;
          margin-right: 0;
        }

        /* 字型大小對應的圖片樣式 - 優化版 */
        #cardFront .ql-size-small img,
        #cardBack .ql-size-small img,
        #frontText .ql-size-small img,
        #backText .ql-size-small img {
          max-width: 40%;
          height: auto;
          margin: 5px auto;
          display: block;
          transition: all 0.3s ease;
        }

        #cardFront .ql-size-large img,
        #cardBack .ql-size-large img,
        #frontText .ql-size-large img,
        #backText .ql-size-large img {
          max-width: 75%;
          height: auto;
          transition: all 0.3s ease;
        }

        #cardFront .ql-size-huge img,
        #cardBack .ql-size-huge img,
        #frontText .ql-size-huge img,
        #backText .ql-size-huge img {
          max-width: 100%;
          height: auto;
          transition: all 0.3s ease;
        }

        /* 標準字體大小的圖片樣式 */
        #cardFront img,
        #cardBack img,
        #frontText img,
        #backText img {
          max-width: 60%;
          height: auto;
          transition: all 0.3s ease;
        }

    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen pt-0">
    <!-- Sticky Navigation Bar (changed from fixed) -->
    <div class="sticky top-0 w-full z-40 bg-white dark:bg-gray-900 shadow-md">
        <div class="container mx-auto px-4">
            <!-- Navigation tabs -->
            <div class="flex justify-center border-b border-gray-300 dark:border-gray-700 overflow-x-auto">
                <button id="reviewBtn" class="py-3 px-4 border-b-2 border-primary font-medium whitespace-nowrap">複習</button>
                <button id="createCardBtn" class="py-3 px-4 border-b-2 border-transparent font-medium whitespace-nowrap">建立字卡</button>
                <button id="manageDeckBtn" class="py-3 px-4 border-b-2 border-transparent font-medium whitespace-nowrap">管理卡組</button>
                <button id="manageCardBtn" class="py-3 px-4 border-b-2 border-transparent font-medium whitespace-nowrap">管理字卡</button>
            </div>
        </div>
    </div>

    <!-- Main container for the flashcard app -->
    <div class="container mx-auto px-4 py-4 max-w-3xl flex flex-col min-h-[calc(100vh-4rem)]">

      <!-- Data import/export buttons -->
      <div class="flex justify-end mb-6 gap-2">
          <button id="importExcelBtn" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded-lg text-sm flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                  <path fill-rule="evenodd" d="M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V7.414A2 2 0 0015.414 6L12 2.586A2 2 0 0010.586 2H6zm5 6a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V8z" clip-rule="evenodd" />
              </svg>
              導入Excel
          </button>
          <button id="importGSheetsBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded-lg text-sm flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M19 3H5C3.9 3 3 3.9 3 5v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/>
                  <path d="M7 7h2v10H7zm4 0h2v10h-2zm4 0h2v10h-2z"/>
              </svg>
              從 Google Sheets 導入
          </button>
          <button id="exportExcelBtn" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded-lg text-sm flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
              導出Excel
          </button>
          <button id="exportDataBtn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded-lg text-sm flex items-center">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
              </svg>
              匯出數據
          </button>
          <label for="importDataInput" class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-lg text-sm flex items-center cursor-pointer">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0l-4 4m4-4v12" />
              </svg>
              匯入數據
              <input id="importDataInput" type="file" accept=".json" class="hidden">
          </label>
      </div>

        <!-- Review card section -->
        <div id="reviewSection" class="space-y-6">
            <!-- Deck selection -->
            <div id="deckSelection" class="mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold">選擇卡組</h2>
                    <div class="flex items-center">
                        <label for="deckSortSelect" class="mr-2 text-sm">排序：</label>
                        <select id="deckSortSelect" class="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg px-2 py-1 text-sm">
                            <option value="name">名稱</option>
                            <option value="cards">字卡數量</option>
                            <option value="date-new">最新建立</option>
                            <option value="date-old">最舊建立</option>
                        </select>
                    </div>
                </div>

                <!-- Search bar for decks -->
                <div class="mb-4">
                    <div class="relative">
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                            </svg>
                        </div>
                        <input type="text" id="deckSearchInput" placeholder="搜尋卡組..." class="bg-white dark:bg-gray-800 pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary w-full text-base">
                    </div>
                </div>

                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4" id="deckList">
                    <!-- Decks will be added here dynamically -->
                    <div class="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">
                        沒有可用的卡組。
                        <a href="#" id="createFirstDeckLink" class="text-primary hover:underline">建立第一個卡組</a>
                    </div>
                </div>
            </div>

            <!-- Mode selection (hidden initially) -->
            <div id="modeSelection" class="mb-8 hidden">
                <h2 class="text-xl font-semibold mb-4">選擇複習模式</h2>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-300 dark:border-gray-700 cursor-pointer hover:border-primary dark:hover:border-primary" data-mode="daily">
                        <h3 class="font-medium text-lg mb-2">日常模式</h3>
                        <p class="text-gray-600 dark:text-gray-400 text-sm">基於遺忘曲線複習，一次完整複習後結束</p>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-300 dark:border-gray-700 cursor-pointer hover:border-primary dark:hover:border-primary" data-mode="drill">
                        <h3 class="font-medium text-lg mb-2">操練模式</h3>
                        <p class="text-gray-600 dark:text-gray-400 text-sm">難度決定再次出現的間隔，間隔以複習的字卡數計算</p>
                    </div>
                </div>
            </div>

            <!-- Review interface (hidden initially) -->
            <div id="reviewInterface" class="space-y-4 hidden">
                <div class="flex justify-between items-center mb-1">
                    <div>
                        <span class="text-gray-700 dark:text-gray-300">卡組：</span>
                        <span id="currentDeckName" class="font-medium"></span>
                    </div>
                    <div>
                        <span class="text-gray-700 dark:text-gray-300">模式：</span>
                        <span id="currentModeName" class="font-medium"></span>
                    </div>
                </div>

                <div id="reviewInfo" class="flex justify-between items-center text-sm px-2 mb-2">
                    <button id="flipSidesBtn" class="text-blue-500 hover:text-blue-700 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                        </svg>
                        正反互換
                    </button>
                    <button id="exitReviewBtn" class="text-red-500 hover:text-red-700">結束複習</button>
                </div>

                <div id="reviewCard">
                    <div id="cardContainer" class="w-full h-96 bg-white dark:bg-gray-800 rounded-xl shadow-lg flex flex-col items-center justify-center cursor-pointer mb-4 border border-gray-300 dark:border-gray-700 transition-all duration-500 p-6 relative overflow-auto">
                        <div id="cardFront" class="text-xl font-medium text-center w-full h-full flex flex-col items-center justify-center">
                            <div id="frontText" class="mb-4"></div>
                            <div id="frontImage" class="flex-grow flex justify-center"></div>
                        </div>
                        <div id="cardBack" class="text-xl font-medium text-center w-full h-full hidden flex flex-col items-center justify-center">
                            <div id="backText" class="mb-4"></div>
                            <div id="backImage" class="mt-2 flex justify-center"></div>
                        </div>
                    </div>

                    <div class="text-center mb-4">
                        <button id="flipBtn" class="bg-primary hover:bg-opacity-80 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                            翻轉字卡
                        </button>
                    </div>

                    <div id="ratingButtons" class="flex justify-center space-x-4 mt-6 hidden">
                        <button class="rating-btn bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors" data-rating="1">很難</button>
                        <button class="rating-btn bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors" data-rating="2">困難</button>
                        <button class="rating-btn bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors" data-rating="3">良好</button>
                        <button class="rating-btn bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors" data-rating="4">簡單</button>
                    </div>
                </div>

                <div id="reviewCompleteMessage" class="text-center py-10 hidden">
                    <p class="text-xl font-bold mb-4 text-primary">複習結束！</p>
                    <p class="text-lg mb-6">您已完成該卡組的所有字卡</p>
                    <div class="space-x-4">
                        <button id="restartDeckBtn" class="bg-primary hover:bg-opacity-80 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                            重新複習此卡組
                        </button>
                        <button id="backToDeckSelectionBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                            返回選擇卡組
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Create card section -->
        <div id="createCardSection" class="space-y-6 hidden">
            <div id="noDeckWarning" class="bg-yellow-100 dark:bg-yellow-900 border-l-4 border-yellow-500 p-4 mb-6 hidden">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-yellow-700 dark:text-yellow-200">
                            請先建立一個卡組再添加字卡。
                            <a href="#" id="createFirstDeckLinkInWarning" class="text-primary hover:underline ml-1">建立第一個卡組</a>
                        </p>
                    </div>
                </div>
            </div>

            <div id="deckSelectionForCard" class="mb-6">
                <div class="flex justify-between items-end mb-1">
                    <label for="deckSelectForCard" class="block text-sm font-medium">選擇卡組</label>
                    <button id="createNewDeckBtn" class="text-primary hover:text-primary-dark text-sm flex items-center ml-2" type="button">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                        </svg>
                        新增卡組
                    </button>
                </div>
                <div class="multiselect-dropdown">
                    <div class="flex items-center border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 bg-white dark:bg-gray-800 text-base">
                        <div id="selectedDecks" class="flex-1 flex flex-wrap gap-2">
                            <span class="text-gray-500 dark:text-gray-400" id="selectedDecksPlaceholder">請選擇卡組</span>
                        </div>
                        <button type="button" id="toggleDeckDropdown" class="focus:outline-none">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                            </svg>
                        </button>
                    </div>
                    <div id="deckOptions" class="multiselect-options mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg hidden">
                        <!-- Deck options will be added here dynamically -->
                    </div>
                </div>
            </div>

            <form id="cardForm" class="space-y-6">
              <div class="card-editor-container space-y-4">
                <label class="block text-lg font-medium">字卡內容</label>

                <!-- 上下輸入區容器 -->
                <div class="combined-editors">
                  <!-- a. 正面輸入區 -->
                  <div class="editor-section front-section">
                    <div id="frontEditor" class="editor-content"></div>
                  </div>

                  <!-- b. 分隔線 -->
                  <div class="editor-divider"></div>

                  <!-- c. 背面輸入區 -->
                  <div class="editor-section back-section">
                    <div id="backEditor" class="editor-content"></div>
                  </div>
                </div>

                <!-- 並排的圖片選擇按鈕 -->
                <div class="image-buttons grid grid-cols-2 gap-2">
                  <button type="button" id="frontImageBtn" class="image-btn">
                    選擇正面圖片
                  </button>
                  <button type="button" id="backImageBtn" class="image-btn">
                    選擇背面圖片
                  </button>
                  <input type="file" id="cardFrontImage" accept="image/*" class="hidden" />
                  <input type="file" id="cardBackImage" accept="image/*" class="hidden" />
                </div>

                <!-- 拖放區域 -->
                <div class="flex space-x-2">
                  <div class="flex-1 drag-area" id="frontDragArea">
                    <div class="drag-overlay">
                      <div class="drag-text">拖放正面圖片</div>
                    </div>
                  </div>
                  <div class="flex-1 drag-area" id="backDragArea">
                    <div class="drag-overlay">
                      <div class="drag-text">拖放背面圖片</div>
                    </div>
                  </div>
                </div>

                <!-- 圖片預覽區域 -->
                <div class="grid grid-cols-2 gap-4">
                  <div id="frontImagePreview" class="hidden">
                    <div class="flex items-center">
                      <img id="frontPreviewImg" class="max-h-40 max-w-full rounded border border-gray-300 dark:border-gray-700" />
                      <button type="button" id="removeFrontImage" class="ml-2 text-red-500 hover:text-red-700 text-sm">
                        移除
                      </button>
                    </div>
                    <span id="frontImageName" class="text-sm text-gray-500 dark:text-gray-400 mt-1 block"></span>
                  </div>
                  <div id="backImagePreview" class="hidden">
                    <div class="flex items-center">
                      <img id="backPreviewImg" class="max-h-40 max-w-full rounded border border-gray-300 dark:border-gray-700" />
                      <button type="button" id="removeBackImage" class="ml-2 text-red-500 hover:text-red-700 text-sm">
                        移除
                      </button>
                    </div>
                    <span id="backImageName" class="text-sm text-gray-500 dark:text-gray-400 mt-1 block"></span>
                  </div>
                </div>

                <!-- 創建字卡的提交按鈕 -->
                <div class="mt-4 flex justify-end">
                  <button type="submit" class="bg-primary hover:bg-opacity-80 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                    建立字卡
                  </button>
                </div>
              </div>
            </form>
        </div>

        <!-- Manage cards section -->
        <div id="manageCardSection" class="space-y-6 hidden">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-4">
                <h2 class="text-xl font-semibold">管理字卡</h2>
                <div class="flex space-x-2">
                    <button id="deleteBatchCardsBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm hidden">
                        刪除選中 (<span id="selectedCardCount">0</span>)
                    </button>
                    <button id="deleteAllCardsBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm">
                        刪除全部
                    </button>
                </div>
            </div>

            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <div class="relative flex-1">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                        <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <input type="text" id="cardSearchInput" placeholder="搜尋字卡內容..." class="bg-white dark:bg-gray-800 pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary w-full text-base">
                </div>

                <div class="sm:w-1/3">
                    <select id="deckFilterSelect" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary bg-white dark:bg-gray-800 text-base">
                        <option value="all">全部卡組</option>
                        <!-- Deck options will be added here dynamically -->
                    </select>
                </div>
            </div>

            <div class="flex items-center mb-4">
                <input type="checkbox" id="selectAllCards" class="mr-2 h-4 w-4">
                <label for="selectAllCards" class="text-sm">全選</label>
            </div>

            <div id="allCardsContainer" class="space-y-4">
                <!-- Cards will be added here dynamically -->
                <div class="text-center py-8 text-gray-500 dark:text-gray-400">
                    沒有可用的字卡。
                </div>
            </div>
        </div>

        <!-- Manage decks section -->
        <div id="manageDeckSection" class="space-y-6 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold">所有卡組</h2>
            </div>

            <!-- Search and sort bar for decks -->
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <div class="relative flex-1">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                        <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <input type="text" id="manageDeckSearchInput" placeholder="搜尋卡組..." class="bg-white dark:bg-gray-800 pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary w-full text-base">
                </div>

                <div class="sm:w-1/3 flex items-center">
                    <label for="manageDeckSortSelect" class="mr-2 text-sm whitespace-nowrap">排序：</label>
                    <select id="manageDeckSortSelect" class="flex-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg px-2 py-2 text-sm">
                        <option value="name">名稱</option>
                        <option value="cards">字卡數量</option>
                        <option value="date-new">最新建立</option>
                        <option value="date-old">最舊建立</option>
                    </select>
                </div>
            </div>

            <div class="flex items-center justify-between mb-4">
                <div class="flex items-center">
                    <input type="checkbox" id="selectAllDecks" class="mr-2 h-4 w-4">
                    <label for="selectAllDecks" class="text-sm">全選</label>
                </div>
                <div class="flex items-center space-x-3">
                    <button id="addDeckInManageBtn" class="bg-primary hover:bg-opacity-80 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                        </svg>
                        新增卡組
                    </button>
                    <button id="deleteBatchDecksBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm hidden">
                        刪除選中 (<span id="selectedDeckCount">0</span>)
                    </button>
                    <button id="deleteAllDecksBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm">
                        刪除全部
                    </button>
                </div>
            </div>

            <div id="allDecksContainer" class="space-y-4">
                <!-- Decks will be added here dynamically -->
                <div class="text-center py-8 text-gray-500 dark:text-gray-400">
                    沒有可用的卡組。請先建立卡組。
                </div>
            </div>
        </div>

        <!-- Card edit modal -->
        <div id="cardEditModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50 overflow-y-auto py-10">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4 my-auto max-h-[85vh] overflow-y-auto">
                <h2 class="text-xl font-semibold mb-4 sticky top-0 bg-white dark:bg-gray-800 py-2 z-10 border-b border-gray-200 dark:border-gray-700">編輯字卡</h2>
                <div class="space-y-4 overflow-y-auto">
                    <div>
                        <label for="editCardFrontInput" class="block text-sm font-medium mb-1">正面（問題）</label>
                        <div class="editor-with-button">
                            <!-- Quill編輯器將替換這個div -->
                            <div id="editFrontEditor"></div>

                            <div class="input-group drag-area">
                                <button type="button" id="editFrontImageBtn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-r-lg transition-colors text-sm">
                                    更改圖片
                                </button>
                                <input type="file" id="editCardFrontImage" accept="image/*" class="hidden" />
                                <div class="drag-overlay">
                                    <div class="drag-text">拖放圖片至此</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="editFrontImageContainer">
                        <div id="editFrontImagePreview" class="mb-2 hidden">
                            <div class="flex items-center">
                                <img id="editFrontPreviewImg" class="max-h-40 max-w-full rounded border border-gray-300 dark:border-gray-700" />
                                <button type="button" id="removeEditFrontImage" class="ml-2 text-red-500 hover:text-red-700 text-sm">
                                    移除圖片
                                </button>
                            </div>
                        </div>
                    </div>

                    <div>
                        <label for="editCardBackInput" class="block text-sm font-medium mb-1">背面（答案）</label>
                        <div class="editor-with-button">
                            <!-- Quill編輯器將替換這個div -->
                            <div id="editBackEditor"></div>

                            <div class="input-group drag-area">
                                <button type="button" id="editBackImageBtn" class="bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-r-lg transition-colors text-sm">
                                    更改圖片
                                </button>
                                <input type="file" id="editCardBackImage" accept="image/*" class="hidden" />
                                <div class="drag-overlay">
                                    <div class="drag-text">拖放圖片至此</div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="editBackImageContainer">
                        <div id="editBackImagePreview" class="mb-2 hidden">
                            <div class="flex items-center">
                                <img id="editBackPreviewImg" class="max-h-40 max-w-full rounded border border-gray-300 dark:border-gray-700" />
                                <button type="button" id="removeEditBackImage" class="ml-2 text-red-500 hover:text-red-700 text-sm">
                                    移除圖片
                                </button>
                            </div>
                        </div>
                    </div>

                    <div>
                        <label class="block text-sm font-medium mb-1">所屬卡組</label>
                        <div class="max-h-60 overflow-y-auto space-y-2 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <div id="editCardDecksList">
                                <!-- Deck checkboxes will be added here dynamically -->
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="closeCardEditBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="saveCardEditBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            儲存
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Deck edit modal -->
        <div id="deckEditModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">編輯卡組</h2>
                <div class="space-y-4">
                    <div>
                        <label for="editDeckNameInput" class="block text-sm font-medium mb-1">卡組名稱</label>
                        <input type="text" id="editDeckNameInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" />
                    </div>
                    <div>
                        <label for="editDeckDescriptionInput" class="block text-sm font-medium mb-1">描述</label>
                        <textarea id="editDeckDescriptionInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" rows="2"></textarea>
                    </div>
                    <div class="border-t border-gray-300 dark:border-gray-700 pt-4">
                        <h3 class="font-medium mb-2">卡組中的字卡</h3>
                        <div id="deckCardsList" class="max-h-60 overflow-y-auto space-y-2">
                            <!-- Cards will be added here dynamically -->
                        </div>
                    </div>
                    <div class="border-t border-gray-300 dark:border-gray-700 pt-4">
                        <h3 class="font-medium mb-2">添加字卡</h3>
                        <div id="availableCardsList" class="max-h-60 overflow-y-auto space-y-2">
                            <!-- Available cards will be added here dynamically -->
                        </div>
                    </div>
                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="closeDeckEditBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="saveDeckEditBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            儲存
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- New deck modal -->
        <div id="newDeckModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">新增卡組</h2>
                <div class="space-y-4">
                    <div>
                        <label for="newDeckNameInput" class="block text-sm font-medium mb-1">卡組名稱</label>
                        <input type="text" id="newDeckNameInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" />
                    </div>
                    <div>
                        <label for="newDeckDescriptionInput" class="block text-sm font-medium mb-1">描述 (選填)</label>
                        <textarea id="newDeckDescriptionInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" rows="2"></textarea>
                    </div>
                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="closeNewDeckBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="saveNewDeckBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            建立
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Enhanced Export Modal (with deck selection) -->
        <div id="exportModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">匯出數據</h2>
                <div class="space-y-4">
                    <div>
                        <label for="exportFilenameInput" class="block text-sm font-medium mb-1">檔案名稱</label>
                        <input type="text" id="exportFilenameInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" value="flashcards_data" />
                    </div>

                    <!-- Deck selection section -->
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="block text-sm font-medium">選擇要匯出的卡組</label>
                            <div class="flex space-x-2">
                                <button id="selectAllExportDecksBtn" class="text-xs text-primary hover:underline">全選</button>
                                <button id="deselectAllExportDecksBtn" class="text-xs text-primary hover:underline">取消全選</button>
                            </div>
                        </div>
                        <div id="exportDecksList" class="max-h-60 overflow-y-auto space-y-2 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <!-- Deck checkboxes will be added here dynamically -->
                            <div class="text-center py-4 text-gray-500 dark:text-gray-400">
                                沒有可用的卡組。
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="cancelExportBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="confirmExportBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            匯出
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Import Preview Modal -->
        <div id="importPreviewModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-xl w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">匯入預覽</h2>
                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="block text-sm font-medium">選擇要匯入的卡組</label>
                            <div class="flex space-x-2">
                                <button id="selectAllImportDecksBtn" class="text-xs text-primary hover:underline">全選</button>
                                <button id="deselectAllImportDecksBtn" class="text-xs text-primary hover:underline">取消全選</button>
                            </div>
                        </div>
                        <div id="importDecksList" class="max-h-60 overflow-y-auto space-y-2 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <!-- Import decks will be added here dynamically -->
                        </div>
                    </div>

                    <!-- Conflict resolution options -->
                    <div>
                        <label class="block text-sm font-medium mb-2">衝突處理方式</label>
                        <div class="space-y-2">
                            <label class="flex items-center">
                                <input type="radio" name="conflictResolution" value="overwrite" checked class="mr-2">
                                <span>覆蓋 - 用匯入的卡組替換現有同名卡組</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="conflictResolution" value="rename" class="mr-2">
                                <span>重命名 - 為匯入的卡組添加數字後綴</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="conflictResolution" value="merge" class="mr-2">
                                <span>合併 - 將匯入的字卡合併到現有卡組</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="conflictResolution" value="skip" class="mr-2">
                                <span>跳過 - 不匯入衝突的卡組</span>
                            </label>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="cancelImportBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="confirmImportBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            匯入
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Excel導入對話框 -->
        <div id="importExcelModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50 overflow-y-auto py-10">
          <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-3xl w-full mx-4 my-auto">
                <h2 class="text-xl font-semibold mb-4">從Excel導入字卡</h2>

                <div id="excelImportSteps" class="overflow-y-auto">
                    <!-- 步驟1: 選擇文件 -->
                    <div id="excelStep1" class="space-y-4">
                        <div class="border-2 border-dashed border-gray-300 dark:border-gray-700 p-6 rounded-lg text-center">
                            <div class="mb-4">
                                <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-12 w-12 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                                </svg>
                            </div>
                            <p class="mb-4 text-gray-600 dark:text-gray-400">選擇Excel檔案（.xls或.xlsx）</p>
                            <p class="mb-4 text-sm text-gray-500 dark:text-gray-500">Excel第一列應為表頭，第二列開始為字卡數據。<br>至少需要兩列：第一列為正面內容，第二列為背面內容。<br>多個工作表將被識別為不同卡組。</p>
                            <div>
                                <label for="excelFileInput" class="bg-primary hover:bg-opacity-80 text-white px-4 py-2 rounded-lg cursor-pointer">
                                    選擇檔案
                                    <input type="file" id="excelFileInput" accept=".xls,.xlsx" class="hidden" />
                                </label>
                            </div>
                            <div id="excelFileName" class="mt-4 text-sm text-gray-500 dark:text-gray-500 hidden"></div>
                        </div>

                        <div class="mt-4 flex justify-between">
                            <button id="downloadExcelTemplateBtn" class="text-primary hover:underline text-sm">
                                下載Excel範本
                            </button>
                            <div>
                                <button id="closeImportExcelBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg mr-2">
                                    取消
                                </button>
                                <button id="nextToPreviewBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg" disabled>
                                    下一步
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 步驟2: 預覽和設置 -->
                    <div id="excelStep2" class="space-y-4 hidden">
                        <div class="mb-4 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <h3 class="font-medium mb-2">工作表</h3>
                            <div id="sheetTabsContainer" class="mb-2 flex flex-wrap">
                                <!-- 工作表選項卡將在這裡動態添加 -->
                            </div>
                        </div>

                        <div class="border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <h3 class="font-medium mb-2">預覽數據</h3>
                            <div class="overflow-x-auto">
                                <table class="min-w-full divide-y divide-gray-300 dark:divide-gray-700">
                                    <thead id="excelPreviewHead" class="bg-gray-100 dark:bg-gray-800">
                                        <!-- Excel表頭數據會動態添加到這裡 -->
                                    </thead>
                                    <tbody id="excelPreviewBody" class="divide-y divide-gray-200 dark:divide-gray-800">
                                        <!-- Excel預覽數據會動態添加到這裡 -->
                                    </tbody>
                                </table>
                            </div>
                            <p id="excelRowCount" class="text-sm text-gray-500 dark:text-gray-500 mt-2"></p>
                        </div>

                        <div class="border border-gray-300 dark:border-gray-700 rounded-lg p-4">
                            <h3 class="font-medium mb-2">設置欄位映射</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium mb-1">正面 (問題)</label>
                                    <select id="frontColumnSelect" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                                        <!-- 欄位選項會動態添加到這裡 -->
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mb-1">背面 (答案)</label>
                                    <select id="backColumnSelect" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                                        <!-- 欄位選項會動態添加到這裡 -->
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="border border-gray-300 dark:border-gray-700 rounded-lg p-4">
                            <h3 class="font-medium mb-2">設置工作表映射</h3>
                            <div id="sheetMappingContainer" class="space-y-4">
                                <!-- 工作表映射選項將在這裡動態添加 -->
                            </div>
                        </div>

                        <div class="mt-4 flex justify-between">
                            <button id="backToFileBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                                上一步
                            </button>
                            <button id="importExcelDataBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                                匯入數據
                            </button>
                        </div>
                    </div>

                    <!-- 步驟3: 匯入結果 -->
                    <div id="excelStep3" class="space-y-4 hidden">
                        <div id="importResults" class="border border-gray-300 dark:border-gray-700 rounded-lg p-4">
                            <!-- 匯入結果會動態添加到這裡 -->
                        </div>

                        <div class="mt-4 flex justify-between">
                            <button id="importNewFileBtn" class="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg transition-colors">
                                導入新檔案
                            </button>
                            <button id="finishImportBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white font-semibold rounded-lg transition-colors">
                                完成
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 導出Excel對話框 -->
        <div id="exportExcelModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">導出Excel</h2>
                <div class="space-y-4">
                    <div>
                        <label for="exportExcelFilenameInput" class="block text-sm font-medium mb-1">檔案名稱</label>
                        <input type="text" id="exportExcelFilenameInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" value="flashcards" />
                    </div>

                    <!-- Deck selection section -->
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="block text-sm font-medium">選擇要導出的卡組</label>
                            <div class="flex space-x-2">
                                <button id="selectAllExportExcelDecksBtn" class="text-xs text-primary hover:underline">全選</button>
                                <button id="deselectAllExportExcelDecksBtn" class="text-xs text-primary hover:underline">取消全選</button>
                            </div>
                        </div>
                        <div id="exportExcelDecksList" class="max-h-60 overflow-y-auto space-y-2 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <!-- Deck checkboxes will be added here dynamically -->
                            <div class="text-center py-4 text-gray-500 dark:text-gray-400">
                                沒有可用的卡組。
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="cancelExportExcelBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="confirmExportExcelBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            導出
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Data storage reminder -->
        <div id="storageReminder" class="fixed bottom-4 left-4 bg-yellow-100 dark:bg-yellow-900 border-l-4 border-yellow-500 p-4 rounded shadow-lg hidden">
            <div class="flex">
                <div class="flex-shrink-0">
                    <svg class="h-5 w-5 text-yellow-600 dark:text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                    </svg>
                </div>
                <div class="ml-3">
                    <p class="text-sm text-yellow-700 dark:text-yellow-200">
                        請記得匯出您的數據！資料只暫存在記憶體中，關閉或重新整理頁面將會遺失。
                    </p>
                    <div class="mt-2">
                        <button type="button" id="exportReminderBtn" class="text-sm text-yellow-700 dark:text-yellow-300 font-medium bg-yellow-50 dark:bg-yellow-800 px-2 py-1 rounded">
                            立即匯出
                        </button>
                        <button type="button" id="dismissReminderBtn" class="text-sm text-yellow-700 dark:text-yellow-300 font-medium ml-2 underline">
                            我知道了
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 自定義確認對話框 -->
        <div id="customConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
                <h3 class="text-lg font-medium mb-4" id="confirmModalTitle">確認操作</h3>
                <p id="confirmModalMessage" class="mb-6">您確定要執行此操作嗎？</p>
                <div class="flex justify-end space-x-3">
                    <button id="confirmModalCancelBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                        取消
                    </button>
                    <button id="confirmModalConfirmBtn" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg">
                        確認
                    </button>
                </div>
            </div>
        </div>

        <!-- Google Sheets 導入對話框 -->
        <div id="importGSheetsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50 overflow-y-auto py-10">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-3xl w-full mx-4 my-auto">
                <h2 class="text-xl font-semibold mb-4">從 Google Sheets 導入字卡</h2>

                <div id="gSheetsImportSteps" class="overflow-y-auto">
                    <!-- 步驟1: 輸入 Google Sheets URL -->
                    <div id="gSheetsStep1" class="space-y-4">
                        <p class="mb-4 text-gray-600 dark:text-gray-400">請輸入已共享的 Google Sheets URL</p>
                        <p class="text-sm text-gray-500 dark:text-gray-500 mb-4">
                            注意：Google Sheets 必須設置為「任何人都可以查看」，並請確保第一列為標題行
                        </p>
                        <div class="space-y-2">
                            <label for="gSheetsUrlInput" class="block text-sm font-medium">Google Sheets URL</label>
                            <input type="text" id="gSheetsUrlInput" placeholder="例如：https://docs.google.com/spreadsheets/d/..."
                                   class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                        </div>

                        <div class="flex items-center mt-4">
                            <input type="checkbox" id="enableSyncGSheets" class="mr-2">
                            <label for="enableSyncGSheets" class="text-sm">
                                保持同步（當 Google Sheets 更新時自動更新字卡）
                            </label>
                        </div>

                        <div class="mt-6 flex justify-between">
                            <div>
                                <a href="https://support.google.com/docs/answer/183965" target="_blank" class="text-primary hover:underline text-sm">
                                    如何共享 Google Sheets?
                                </a>
                            </div>
                            <div>
                                <button id="closeGSheetsModalBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg mr-2">
                                    取消
                                </button>
                                <button id="loadGSheetsBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                                    載入
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 步驟2: 預覽和設置 (類似 Excel 導入) -->
                    <div id="gSheetsStep2" class="space-y-4 hidden">
                        <!-- 與 Excel 預覽部分類似的結構 -->
                        <div id="formatStatusIndicator" class="mb-4 p-2 bg-gray-100 dark:bg-gray-700 rounded-lg text-sm">
                            <span id="formatStatus" class="font-medium">格式狀態：</span>
                            <span id="formatStatusValue">載入中...</span>
                        </div>
                    </div>

                    <!-- 步驟3: 導入結果 -->
                    <div id="gSheetsStep3" class="space-y-4 hidden">
                        <!-- 與 Excel 結果部分類似的結構 -->
                    </div>
                </div>
            </div>
        </div>
        <!-- 在文件底部，其他對話框之後添加這個 -->
        <div id="apiSettingsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">API設置</h2>
                <div class="space-y-4">
                    <div>
                        <label for="googleApiKeyInput" class="block text-sm font-medium mb-1">Google API密鑰</label>
                        <input type="password" id="googleApiKeyInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" />
                        <div class="flex items-center mt-1">
                            <input type="checkbox" id="showApiKey" class="mr-2">
                            <label for="showApiKey" class="text-sm">顯示密鑰</label>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">API密鑰用於訪問Google Sheets API，提供格式化數據。密鑰會安全地存儲在您的瀏覽器中。</p>
                    </div>
                    <div class="bg-blue-50 dark:bg-blue-900/30 p-3 rounded-lg text-sm">
                        <h3 class="font-medium text-blue-700 dark:text-blue-400">如何獲取Google API密鑰</h3>
                        <ol class="list-decimal list-inside mt-2 space-y-1 text-blue-600 dark:text-blue-300">
                            <li>訪問 <a href="https://console.cloud.google.com/" target="_blank" class="underline">Google Cloud Console</a></li>
                            <li>創建一個新項目</li>
                            <li>啟用 Google Sheets API</li>
                            <li>創建API密鑰 (憑證 → 創建憑證 → API密鑰)</li>
                            <li>複製API密鑰並粘貼到上面的輸入框</li>
                        </ol>
                    </div>
                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="closeApiSettingsBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="saveApiSettingsBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            保存
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Quill editors
        let frontQuill = null;
        let backQuill = null;
        let editFrontQuill = null;
        let editBackQuill = null;

        // Initialize app state
        let currentCardIndex = 0;
        let cardsToReview = [];
        let currentDeck = null;
        let currentMode = null;
        let drillReviewedCount = 0; // Count of reviewed cards in drill mode
        let drillTimers = []; // Store timers for drill mode
        let reviewCycleCount = 0; // Count cycles of review
        let sidesFlipped = false; // Track if card sides are flipped during review

        // In-memory storage for cards and decks
        let cardsData = [];
        let decksData = [];

        // Selected cards for batch operations
        let selectedCardIds = new Set();

        // Selected deck IDs for creating cards
        let selectedDeckIds = [];

        // Selected deck IDs for batch operations
        let selectedDeckIds2 = new Set();

        // Selected deck IDs for export
        let selectedExportDeckIds = [];

        // Selected deck IDs for Excel export
        let selectedExportExcelDeckIds = [];

        // Import data temporary storage
        let importDataCache = null;
        let selectedImportDeckIds = [];

        // Excel導入功能變量
        let excelData = null;
        let excelColumns = [];
        let excelFileName = '';
        let editingFolderId = null;

        // Excel 多工作表導入變量
        let excelSheets = {}; // 保存所有工作表的數據
        let activeSheetName = ''; // 當前活動的工作表名稱
        let sheetMappings = {}; // 工作表到卡組的映射
        let sheetOptions = {}; // 每個工作表的列映射選項

        // Sorting preferences
        let deckSortPreference = 'name';
        let manageDeckSortPreference = 'name';

        // Image upload related variables
        let frontImageData = null;
        let backImageData = null;
        let editFrontImageData = null;
        let editBackImageData = null;

        // For editing
        let editingCardId = null;
        let editingDeckId = null;

        // For storage reminder
        let reminderShown = false;

        // DOM Elements - Sections
        const reviewSection = document.getElementById('reviewSection');
        const createCardSection = document.getElementById('createCardSection');
        const manageCardSection = document.getElementById('manageCardSection');
        const manageDeckSection = document.getElementById('manageDeckSection');

        // DOM Elements - Navigation
        const reviewBtn = document.getElementById('reviewBtn');
        const createCardBtn = document.getElementById('createCardBtn');
        const manageCardBtn = document.getElementById('manageCardBtn');
        const manageDeckBtn = document.getElementById('manageDeckBtn');
        const createFirstDeckLink = document.getElementById('createFirstDeckLink');

        // DOM Elements - Storage Reminder
        const storageReminder = document.getElementById('storageReminder');
        const exportReminderBtn = document.getElementById('exportReminderBtn');
        const dismissReminderBtn = document.getElementById('dismissReminderBtn');

        // DOM Elements - Import/Export
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataInput = document.getElementById('importDataInput');
        const exportModal = document.getElementById('exportModal');
        const exportFilenameInput = document.getElementById('exportFilenameInput');
        const cancelExportBtn = document.getElementById('cancelExportBtn');
        const confirmExportBtn = document.getElementById('confirmExportBtn');
        const exportDecksList = document.getElementById('exportDecksList');
        const selectAllExportDecksBtn = document.getElementById('selectAllExportDecksBtn');
        const deselectAllExportDecksBtn = document.getElementById('deselectAllExportDecksBtn');

        // DOM Elements - Export Excel
        const exportExcelBtn = document.getElementById('exportExcelBtn');
        const exportExcelModal = document.getElementById('exportExcelModal');
        const exportExcelFilenameInput = document.getElementById('exportExcelFilenameInput');
        const exportExcelDecksList = document.getElementById('exportExcelDecksList');
        const selectAllExportExcelDecksBtn = document.getElementById('selectAllExportExcelDecksBtn');
        const deselectAllExportExcelDecksBtn = document.getElementById('deselectAllExportExcelDecksBtn');
        const cancelExportExcelBtn = document.getElementById('cancelExportExcelBtn');
        const confirmExportExcelBtn = document.getElementById('confirmExportExcelBtn');

        // DOM Elements - Import Preview
        const importPreviewModal = document.getElementById('importPreviewModal');
        const importDecksList = document.getElementById('importDecksList');
        const selectAllImportDecksBtn = document.getElementById('selectAllImportDecksBtn');
        const deselectAllImportDecksBtn = document.getElementById('deselectAllImportDecksBtn');
        const cancelImportBtn = document.getElementById('cancelImportBtn');
        const confirmImportBtn = document.getElementById('confirmImportBtn');

        // DOM Elements - Sorting
        const deckSortSelect = document.getElementById('deckSortSelect');
        const manageDeckSortSelect = document.getElementById('manageDeckSortSelect');

        // DOM Elements - Search
        const deckSearchInput = document.getElementById('deckSearchInput');
        const cardSearchInput = document.getElementById('cardSearchInput');
        const manageDeckSearchInput = document.getElementById('manageDeckSearchInput');

        // DOM Elements - Create Card Deck Selection
        const noDeckWarning = document.getElementById('noDeckWarning');
        const createNewDeckBtn = document.getElementById('createNewDeckBtn');
        const deckSelectionForCard = document.getElementById('deckSelectionForCard');
        const selectedDecks = document.getElementById('selectedDecks');
        const selectedDecksPlaceholder = document.getElementById('selectedDecksPlaceholder');
        const toggleDeckDropdown = document.getElementById('toggleDeckDropdown');
        const deckOptions = document.getElementById('deckOptions');

        // DOM Elements - Review
        const deckSelection = document.getElementById('deckSelection');
        const modeSelection = document.getElementById('modeSelection');
        const reviewInterface = document.getElementById('reviewInterface');
        const currentDeckName = document.getElementById('currentDeckName');
        const currentModeName = document.getElementById('currentModeName');
        const flipSidesBtn = document.getElementById('flipSidesBtn');
        const exitReviewBtn = document.getElementById('exitReviewBtn');
        const reviewCard = document.getElementById('reviewCard');
        const reviewCompleteMessage = document.getElementById('reviewCompleteMessage');
        const restartDeckBtn = document.getElementById('restartDeckBtn');
        const backToDeckSelectionBtn = document.getElementById('backToDeckSelectionBtn');
        const deckList = document.getElementById('deckList');

        // DOM Elements - Card elements
        const cardFront = document.getElementById('cardFront');
        const cardBack = document.getElementById('cardBack');
        const frontText = document.getElementById('frontText');
        const backText = document.getElementById('backText');
        const frontImage = document.getElementById('frontImage');
        const backImage = document.getElementById('backImage');
        const flipBtn = document.getElementById('flipBtn');
        const ratingButtons = document.getElementById('ratingButtons');

        // DOM Elements - Create Card
        const cardForm = document.getElementById('cardForm');
        const frontEditor = document.getElementById('frontEditor');
        const backEditor = document.getElementById('backEditor');
        const cardFrontImageInput = document.getElementById('cardFrontImage');
        const cardBackImageInput = document.getElementById('cardBackImage');
        const frontImageBtn = document.getElementById('frontImageBtn');
        const backImageBtn = document.getElementById('backImageBtn');
        const frontImageName = document.getElementById('frontImageName');
        const backImageName = document.getElementById('backImageName');
        const frontImagePreview = document.getElementById('frontImagePreview');
        const backImagePreview = document.getElementById('backImagePreview');
        const frontPreviewImg = document.getElementById('frontPreviewImg');
        const backPreviewImg = document.getElementById('backPreviewImg');
        const removeFrontImage = document.getElementById('removeFrontImage');
        const removeBackImage = document.getElementById('removeBackImage');

        // DOM Elements - Manage Cards
        const allCardsContainer = document.getElementById('allCardsContainer');
        const selectAllCards = document.getElementById('selectAllCards');
        const selectedCardCount = document.getElementById('selectedCardCount');
        const deleteBatchCardsBtn = document.getElementById('deleteBatchCardsBtn');
        const deleteAllCardsBtn = document.getElementById('deleteAllCardsBtn');
        const deckFilterSelect = document.getElementById('deckFilterSelect');

        // DOM Elements - Manage Decks
        const allDecksContainer = document.getElementById('allDecksContainer');
        const deleteAllDecksBtn = document.getElementById('deleteAllDecksBtn');
        const addDeckInManageBtn = document.getElementById('addDeckInManageBtn');
        const selectAllDecks = document.getElementById('selectAllDecks');
        const selectedDeckCount = document.getElementById('selectedDeckCount');
        const deleteBatchDecksBtn = document.getElementById('deleteBatchDecksBtn');

        // DOM Elements - Card Edit Modal
        const cardEditModal = document.getElementById('cardEditModal');
        const editFrontEditor = document.getElementById('editFrontEditor');
        const editBackEditor = document.getElementById('editBackEditor');
        const editCardFrontImage = document.getElementById('editCardFrontImage');
        const editCardBackImage = document.getElementById('editCardBackImage');
        const editFrontImageBtn = document.getElementById('editFrontImageBtn');
        const editBackImageBtn = document.getElementById('editBackImageBtn');
        const editFrontImagePreview = document.getElementById('editFrontImagePreview');
        const editBackImagePreview = document.getElementById('editBackImagePreview');
        const editFrontPreviewImg = document.getElementById('editFrontPreviewImg');
        const editBackPreviewImg = document.getElementById('editBackPreviewImg');
        const removeEditFrontImage = document.getElementById('removeEditFrontImage');
        const removeEditBackImage = document.getElementById('removeEditBackImage');
        const editCardDecksList = document.getElementById('editCardDecksList');
        const closeCardEditBtn = document.getElementById('closeCardEditBtn');
        const saveCardEditBtn = document.getElementById('saveCardEditBtn');

        // DOM Elements - Deck Edit Modal
        const deckEditModal = document.getElementById('deckEditModal');
        const editDeckNameInput = document.getElementById('editDeckNameInput');
        const editDeckDescriptionInput = document.getElementById('editDeckDescriptionInput');
        const deckCardsList = document.getElementById('deckCardsList');
        const availableCardsList = document.getElementById('availableCardsList');
        const closeDeckEditBtn = document.getElementById('closeDeckEditBtn');
        const saveDeckEditBtn = document.getElementById('saveDeckEditBtn');

        // DOM Elements - New Deck Modal
        const newDeckModal = document.getElementById('newDeckModal');
        const newDeckNameInput = document.getElementById('newDeckNameInput');
        const newDeckDescriptionInput = document.getElementById('newDeckDescriptionInput');
        const closeNewDeckBtn = document.getElementById('closeNewDeckBtn');
        const saveNewDeckBtn = document.getElementById('saveNewDeckBtn');

        // DOM Elements - Excel Import
        const importExcelBtn = document.getElementById('importExcelBtn');
        const importExcelModal = document.getElementById('importExcelModal');
        const closeImportExcelBtn = document.getElementById('closeImportExcelBtn');
        const excelFileInput = document.getElementById('excelFileInput');
        const excelFileNameDisplay = document.getElementById('excelFileName');
        const nextToPreviewBtn = document.getElementById('nextToPreviewBtn');
        const downloadExcelTemplateBtn = document.getElementById('downloadExcelTemplateBtn');

        // Excel Import Multi-Sheet Elements
        const sheetTabsContainer = document.getElementById('sheetTabsContainer');
        const sheetMappingContainer = document.getElementById('sheetMappingContainer');

        const excelStep1 = document.getElementById('excelStep1');
        const excelStep2 = document.getElementById('excelStep2');
        const excelStep3 = document.getElementById('excelStep3');
        const backToFileBtn = document.getElementById('backToFileBtn');
        const importExcelDataBtn = document.getElementById('importExcelDataBtn');
        const finishImportBtn = document.getElementById('finishImportBtn');

        const excelPreviewHead = document.getElementById('excelPreviewHead');
        const excelPreviewBody = document.getElementById('excelPreviewBody');
        const excelRowCount = document.getElementById('excelRowCount');
        const frontColumnSelect = document.getElementById('frontColumnSelect');
        const backColumnSelect = document.getElementById('backColumnSelect');
        const targetExistingDeck = document.getElementById('targetExistingDeck');
        const existingDeckSelector = document.getElementById('existingDeckSelector');
        const newDeckInputs = document.getElementById('newDeckInputs');
        const newDeckName = document.getElementById('newDeckName');
        const newDeckDescription = document.getElementById('newDeckDescription');
        const importResults = document.getElementById('importResults');

        // Google Sheets 相關函數 - 移至全局作用域

        // 初始化 Google Sheets 導入功能
        function initGSheetsImport() {
            // 獲取元素
            const importGSheetsBtn = document.getElementById('importGSheetsBtn');
            const importGSheetsModal = document.getElementById('importGSheetsModal');
            const closeGSheetsModalBtn = document.getElementById('closeGSheetsModalBtn');
            const loadGSheetsBtn = document.getElementById('loadGSheetsBtn');
            const gSheetsUrlInput = document.getElementById('gSheetsUrlInput');

            // 綁定事件
            importGSheetsBtn.addEventListener('click', openGSheetsImportModal);
            closeGSheetsModalBtn.addEventListener('click', closeGSheetsImportModal);
            loadGSheetsBtn.addEventListener('click', loadGSheetsData);

            // 點擊對話框外部關閉
            importGSheetsModal.addEventListener('click', function(e) {
                if (e.target === importGSheetsModal) {
                    closeGSheetsImportModal();
                }
            });

            // 顯示 API 密鑰狀態
            if (GOOGLE_API_KEY) {
                console.log('Google API 密鑰已配置，將支持格式同步');
            } else {
                console.log('未配置 Google API 密鑰，將使用純文本方式同步');

                // 可選：添加一個提示鏈接
                const apiKeyLink = document.createElement('div');
                apiKeyLink.className = 'mt-2 text-xs text-primary hover:underline cursor-pointer';
                apiKeyLink.textContent = '如何獲取 Google API 密鑰以支持格式同步？';
                apiKeyLink.addEventListener('click', () => {
                    window.open('https://developers.google.com/sheets/api/guides/authorizing#APIKey', '_blank');
                });

                // 將鏈接添加到導入對話框
                const gSheetsStep1 = document.getElementById('gSheetsStep1');
                if (gSheetsStep1) {
                    const linkContainer = gSheetsStep1.querySelector('div.mt-6 div:first-child');
                    if (linkContainer) {
                        linkContainer.appendChild(apiKeyLink);
                    }
                }
            }
        }

        function initApiSettings() {
            const apiSettingsBtn = document.getElementById('apiSettingsBtn');
            const apiSettingsModal = document.getElementById('apiSettingsModal');
            const closeApiSettingsBtn = document.getElementById('closeApiSettingsBtn');
            const saveApiSettingsBtn = document.getElementById('saveApiSettingsBtn');
            const googleApiKeyInput = document.getElementById('googleApiKeyInput');
            const showApiKey = document.getElementById('showApiKey');

            // 檢查設置按鈕是否存在（不影響其他功能）
            if (!apiSettingsBtn) {
                console.warn('找不到 apiSettingsBtn 元素，跳過設置按鈕綁定');
                // 繼續執行，而不是返回
            } else {
                // 設置按鈕點擊事件
                apiSettingsBtn.addEventListener('click', () => {
                    // 載入當前API密鑰到輸入框
                    googleApiKeyInput.value = GOOGLE_API_KEY || '';
                    apiSettingsModal.classList.remove('hidden');
                });
            }

            // 檢查必要的元素
            if (!apiSettingsModal || !closeApiSettingsBtn || !saveApiSettingsBtn || !googleApiKeyInput) {
                console.error('API設置模態框缺少必要元素，無法完成初始化');
                return;
            }

            // 關閉按鈕點擊事件
            closeApiSettingsBtn.addEventListener('click', () => {
                apiSettingsModal.classList.add('hidden');
            });

            // 保存按鈕點擊事件
            saveApiSettingsBtn.addEventListener('click', () => {
                const newApiKey = googleApiKeyInput.value.trim();

                // 保存API密鑰
                GOOGLE_API_KEY = newApiKey;
                localStorage.setItem('google_api_key', newApiKey);

                // 顯示確認
                showNotification('API設置已保存');

                // 關閉對話框
                apiSettingsModal.classList.add('hidden');
            });

            // 顯示/隱藏密鑰切換
            if (showApiKey) {
                showApiKey.addEventListener('change', () => {
                    googleApiKeyInput.type = showApiKey.checked ? 'text' : 'password';
                });
            }

            // 點擊對話框外部關閉
            apiSettingsModal.addEventListener('click', (e) => {
                if (e.target === apiSettingsModal) {
                    apiSettingsModal.classList.add('hidden');
                }
            });
        }

        // 打開 Google Sheets 導入對話框
        function openGSheetsImportModal() {
            const importGSheetsModal = document.getElementById('importGSheetsModal');
            importGSheetsModal.classList.remove('hidden');

            // 重置表單
            document.getElementById('gSheetsUrlInput').value = '';
            document.getElementById('enableSyncGSheets').checked = false;

            // 顯示第一步
            showGSheetsStep(1);
        }

        // 關閉 Google Sheets 導入對話框
        function closeGSheetsImportModal() {
            const importGSheetsModal = document.getElementById('importGSheetsModal');
            importGSheetsModal.classList.add('hidden');
        }

        // 顯示指定的 Google Sheets 導入步驟
        function showGSheetsStep(step) {
            document.getElementById('gSheetsStep1').classList.add('hidden');
            document.getElementById('gSheetsStep2').classList.add('hidden');
            document.getElementById('gSheetsStep3').classList.add('hidden');

            document.getElementById(`gSheetsStep${step}`).classList.remove('hidden');
        }

        // 從 Google Sheets 載入數據
        function loadGSheetsData() {
            // 檢查是否設置了API密鑰
            if (!GOOGLE_API_KEY) {
                // 提示用戶設置API密鑰
                showNotification('請先設置Google API密鑰');

                // 在讀取Google Sheets數據時
                if (value && typeof value === 'string') {
                    // 保留換行符，不要去除
                    const preservedValue = value;
                    // 繼續處理 preservedValue...
                }

                // 自動打開API設置對話框
                const apiSettingsModal = document.getElementById('apiSettingsModal');
                if (apiSettingsModal) {
                    apiSettingsModal.classList.remove('hidden');

                    // 聚焦到API密鑰輸入框
                    const googleApiKeyInput = document.getElementById('googleApiKeyInput');
                    if (googleApiKeyInput) {
                        googleApiKeyInput.focus();
                    }
                }

                return;
            }
                        const gSheetsUrl = document.getElementById('gSheetsUrlInput').value.trim();
            const enableSync = document.getElementById('enableSyncGSheets').checked;

            if (!gSheetsUrl) {
                showNotification('請輸入 Google Sheets URL');
                return;
            }

            // 驗證 URL 格式
            if (!isValidGSheetsUrl(gSheetsUrl)) {
                showNotification('請輸入有效的 Google Sheets URL');
                return;
            }

            // 顯示載入中狀態
            const loadBtn = document.getElementById('loadGSheetsBtn');
            const originalText = loadBtn.textContent;
            loadBtn.disabled = true;
            loadBtn.innerHTML = '<span class="inline-block animate-spin mr-2">⟳</span> 載入中...';

            // 從 URL 獲取 spreadsheetId
            const spreadsheetId = extractSpreadsheetId(gSheetsUrl);

            // 先嘗試使用 Google API（帶格式），如果失敗則回退到 CSV（無格式）
            if (GOOGLE_API_KEY) {
                console.log('使用 Google API 載入格式化數據');
                loadFormattedGSheetsData(spreadsheetId, gSheetsUrl, enableSync)
                    .then(() => {
                        // 顯示預覽
                        showGSheetsStep(2);
                        preparePreviewData();

                        // 恢復按鈕狀態
                        loadBtn.disabled = false;
                        loadBtn.textContent = originalText;

                        showNotification('成功載入 Google Sheets 數據（含格式）');

                        // 添加自動導入功能
                        setTimeout(() => {
                            // 詢問用戶是否直接導入
                            if (confirm('成功載入數據！是否直接導入到新卡組？')) {
                                // 獲取所有工作表名稱
                                const sheetNames = Object.keys(excelSheets);
                                let totalImportCount = 0;

                                // 遍歷所有工作表
                                sheetNames.forEach((sheetName, index) => {
                                    if (sheetName && excelSheets[sheetName]) {
                                        // 創建卡組代碼...

                                        // 處理數據（從第1行開始，跳過標題行）
                                        const sheetData = excelSheets[sheetName].data;
                                        let importCount = 0;

                                        // 獲取此工作表的列配置
                                        const frontCol = sheetOptions[sheetName]?.frontColumn || 0;
                                        const backCol = sheetOptions[sheetName]?.backColumn || 1;

                                        console.log(`處理工作表 ${sheetName}, 正面列: ${frontCol}, 背面列: ${backCol}`);

                                        for (let i = 1; i < sheetData.length; i++) {
                                            const row = sheetData[i];
                                            if (!row || !row.length) {
                                                console.log(`行 ${i}: 跳過空行`);
                                                continue;
                                            }

                                            // 使用正確的列索引
                                            const frontContent = row[frontCol];
                                            const backContent = row[backCol];

                                            // 處理內容...

                                            // 添加調試輸出
                                            console.log(`成功添加卡片: ${frontText.substring(0, 20)}... / ${backText.substring(0, 20)}...`);

                                            // 確保計數器增加
                                            importCount++;
                                        }

                                        // 非常重要：確保在此位置增加總計數
                                        totalImportCount += importCount;

                                        console.log(`工作表 ${sheetName} 導入完成: ${importCount} 張字卡`);
                                    }
                                });

                                // 顯示總體結果
                                showNotification(`成功導入 ${totalImportCount} 張字卡到 ${sheetNames.length} 個卡組`);

                                // 刷新UI
                                loadDeckList();

                                // 顯示提醒保存數據
                                showStorageReminder();

                                // 關閉導入對話框
                                closeGSheetsImportModal();

                                // 切換到複習頁面查看結果
                                showSection('review');
                            }
                        }, 500); // 此處缺少了setTimeout的結束括號
                    })



                    .catch(error => {
                        console.error('Google Sheets API 錯誤:', error);

                        // 檢查是否是API密鑰錯誤
                        if (error.message && (
                            error.message.includes('API key') ||
                            error.message.includes('invalid key') ||
                            error.message.includes('unauthorized')
                        )) {
                            showNotification('Google API密鑰無效，請重新設置');

                            // 自動打開API設置對話框
                            const apiSettingsModal = document.getElementById('apiSettingsModal');
                            if (apiSettingsModal) {
                                apiSettingsModal.classList.remove('hidden');
                            }
                        } else {
                            showNotification(`載入失敗: ${error.message}`);
                        }

                        // 添加自動導入功能
                        setTimeout(() => {
                            // 詢問用戶是否直接導入
                            if (confirm('成功載入數據！是否直接導入到新卡組？')) {
                                // 從第一個工作表獲取數據
                                const sheetName = Object.keys(excelSheets)[0];
                                if (sheetName && excelSheets[sheetName]) {
                                    // 創建新卡組
                                    const newDeck = {
                                        id: Date.now(),
                                        name: '來自Sheets-' + new Date().toLocaleDateString(),
                                        description: '從Google Sheets自動導入的字卡',
                                        cardIds: [],
                                        createdAt: Date.now()
                                    };

                                    // 添加卡組
                                    decksData.push(newDeck);

                                    // 處理數據（從第1行開始，跳過標題行）
                                    const sheetData = excelSheets[sheetName].data;
                                    let importCount = 0;

                                    for (let i = 1; i < sheetData.length; i++) {
                                        const row = sheetData[i];
                                        if (!row || !row.length) continue;

                                        // 使用正確的列索引，從sheetOptions中獲取
                                        const frontContent = row[sheetOptions[sheetName].frontColumn];
                                        const backContent = row[sheetOptions[sheetName].backColumn];

                                        // 跳過空行
                                        if ((!frontContent && !backContent) ||
                                            (frontText === '' && backText === '')) {
                                            skippedCount++;
                                            continue;
                                        }

                                        // 處理內容，支持格式化和純文本
                                        let frontText, backText;

                                        if (excelSheets[sheetName].hasFormatting) {
                                            // 處理格式化內容
                                            frontText = typeof frontContent === 'object' && frontContent.delta
                                                ? convertDeltaToHTML(frontContent.delta)
                                                : (frontContent ? frontContent.toString() : '');

                                            backText = typeof backContent === 'object' && backContent.delta
                                                ? convertDeltaToHTML(backContent.delta)
                                                : (backContent ? backContent.toString() : '');
                                        } else {
                                            // 處理純文本
                                            frontText = frontContent ? frontContent.toString() : '';
                                            backText = backContent ? backContent.toString() : '';
                                        }

                                        // 跳過空行
                                        if (!frontText && !backText) continue;

                                        // 創建新卡片
                                        const newCardId = Date.now() + i + Math.floor(Math.random() * 1000);
                                        const newCard = {
                                            id: newCardId,
                                            frontText: frontText,
                                            backText: backText,
                                            nextReview: Date.now(),
                                            repetitions: 0,
                                            easeFactor: 2.0,
                                            interval: 1.0
                                        };

                                        // 添加卡片
                                        cardsData.push(newCard);
                                        newDeck.cardIds.push(newCardId);
                                        importCount++;
                                    }

                                    // 顯示結果
                                    showNotification(`成功導入 ${importCount} 張字卡到卡組 "${newDeck.name}"`);

                                    // 刷新UI
                                    loadDeckList();

                                    // 顯示提醒保存數據
                                    showStorageReminder();

                                    // 關閉導入對話框
                                    closeGSheetsImportModal();

                                    // 切換到複習頁面查看結果
                                    showSection('review');
                                }
                            }
                        }, 500); // 短暫延遲確保通知顯示後再彈出確認

                        // 恢復按鈕狀態
                        loadBtn.disabled = false;
                        loadBtn.textContent = originalText;
                    });

            } else {
                // 使用 CSV 方式（無格式）
                loadGSheetsDataWithCSV(spreadsheetId, gSheetsUrl, enableSync, loadBtn, originalText);
            }
        }

        // 使用 CSV 方式載入 Google Sheets 數據（無格式）
        function loadGSheetsDataWithCSV(spreadsheetId, gSheetsUrl, enableSync, loadBtn, originalText) {
            // 構建導出 CSV 的 URL
            const exportUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv`;

            console.log('嘗試從 URL 載入數據:', exportUrl);

            // 使用 JSONP 方式繞過 CORS 限制
            const jsonpUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/gviz/tq?tqx=out:json`;

            fetch(jsonpUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`無法訪問 Google Sheets，狀態碼: ${response.status}`);
                    }
                    return response.text();
                })
                .then(text => {
                    // JSONP 回應需要處理，移除前缀和後缀
                    const jsonStart = text.indexOf('{');
                    const jsonEnd = text.lastIndexOf('}');
                    if (jsonStart === -1 || jsonEnd === -1) {
                        throw new Error('返回的數據格式不正確');
                    }

                    const jsonText = text.substring(jsonStart, jsonEnd + 1);
                    const data = JSON.parse(jsonText);

                    // 轉換為 CSV 格式的數據結構
                    const rows = [];
                    // 添加表頭
                    const headers = data.table.cols.map(col => col.label || '');
                    rows.push(headers);

                    // 添加數據行
                    data.table.rows.forEach(row => {
                        const rowData = row.c.map(cell => (cell ? (cell.v || '') : ''));
                        rows.push(rowData);
                    });

                    // 保存 Google Sheets 數據
                    const sheetName = 'GoogleSheet';
                    excelSheets = {};
                    excelSheets[sheetName] = {
                        data: rows,
                        columns: headers,
                        hasFormatting: false
                    };

                    // 設置默認卡組映射
                    sheetMappings = {};
                    sheetMappings[sheetName] = {
                        deckOption: 'new',
                        deckId: '',
                        newDeckName: 'Google Sheets 導入',
                        newDeckDescription: '從 Google Sheets 導入的字卡'
                    };

                    // 設置默認列選擇
                    sheetOptions = {};
                    sheetOptions[sheetName] = {
                        frontColumn: 0,
                        backColumn: 1
                    };

                    // 設置活動工作表
                    activeSheetName = sheetName;

                    // 如果啟用同步，保存 URL 和 sync 標記到元數據
                    if (enableSync) {
                        window.gSheetsSyncData = {
                            url: gSheetsUrl,
                            spreadsheetId: spreadsheetId,
                            lastSync: Date.now(),
                            syncEnabled: true,
                            useFormatting: false
                        };

                        setupGSheetsSync();
                    }

                    // 顯示預覽
                    showGSheetsStep(2);
                    preparePreviewData();

                    // 恢復按鈕狀態
                    if (loadBtn) {
                        loadBtn.disabled = false;
                        loadBtn.textContent = originalText;
                    }

                    showNotification('成功載入 Google Sheets 數據');
                })
                .catch(error => {
                    console.error('Google Sheets 載入錯誤:', error);

                    // 提供更詳細的錯誤說明和解決方案
                    let errorMessage = `Google Sheets 載入失敗: ${error.message || '無法連接到Google Sheets'}`;
                    errorMessage += '\n請確保：';
                    errorMessage += '\n1. 您的Google Sheet已設為「任何人都可以查看」';
                    errorMessage += '\n2. 已在「檔案 -> 發布到網路」中發布此表格';

                    showNotification(errorMessage);

                    // 恢復按鈕狀態
                    if (loadBtn) {
                        loadBtn.disabled = false;
                        loadBtn.textContent = originalText;
                    }
                });

        }

        // 從 Google Sheets URL 提取 spreadsheetId
        function extractSpreadsheetId(url) {
            const match = url.match(/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
            return match ? match[1] : null;
        }

        // 驗證 Google Sheets URL
        function isValidGSheetsUrl(url) {
            return url.includes('docs.google.com/spreadsheets/d/');
        }

        // 解析 CSV 數據為二維數組
        function parseCSV(text) {
            const lines = text.split('\n');
            const result = [];

            for (let line of lines) {
                // 處理 CSV 行，支持引號括起的字段
                const row = [];
                let inQuotes = false;
                let currentField = '';

                for (let i = 0; i < line.length; i++) {
                    const char = line[i];

                    if (char === '"') {
                        inQuotes = !inQuotes;
                    } else if (char === ',' && !inQuotes) {
                        row.push(currentField);
                        currentField = '';
                    } else {
                        currentField += char;
                    }
                }

                // 添加最後一個字段
                row.push(currentField);
                result.push(row);
            }

            return result;
        }

        // 帶格式的 Google Sheets 導入（使用 Google API）
        function loadFormattedGSheetsData(spreadsheetId, gSheetsUrl, enableSync) {
            return new Promise((resolve, reject) => {
                // 加載 Google API 客戶端
                gapi.load('client', () => {
                    gapi.client.init({
                        apiKey: GOOGLE_API_KEY,
                        discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4']
                    })
                    .then(() => {
                        // 請求 Google Sheets 數據，包含格式信息
                        return gapi.client.sheets.spreadsheets.get({
                            spreadsheetId: spreadsheetId,
                            includeGridData: true,
                            ranges: []  // 空數組表示獲取所有工作表
                        });
                    })
                    .then(response => {
                        const sheets = response.result.sheets;

                        // 檢查是否有工作表
                        if (!sheets || sheets.length === 0) {
                            reject(new Error('未找到工作表數據'));
                            return;
                        }

                        // 重置 excelSheets
                        excelSheets = {};

                        // 處理所有工作表
                        sheets.forEach(sheet => {
                            const sheetName = sheet.properties.title;
                            const gridData = sheet.data[0]; // 第一個數據網格

                            if (!gridData || !gridData.rowData || gridData.rowData.length === 0) {
                                console.warn(`工作表 "${sheetName}" 沒有數據`);
                                return;
                            }

                            // 提取帶格式的數據
                            const rowData = gridData.rowData;
                            const formattedData = [];

                            // 處理所有行
                            rowData.forEach(row => {
                                if (!row.values) return;

                                const formattedRow = [];
                                const values = row.values;

                                // 處理每個單元格
                                values.forEach(cell => {
                                    // 獲取單元格值和格式
                                    const value = cell.formattedValue || '';
                                    const textFormatRuns = cell.textFormatRuns || [];
                                    const effectiveFormat = cell.effectiveFormat || {};

                                    // 創建帶格式的單元格對象
                                    const formattedCell = {
                                        value: value,
                                        textContent: value, // 純文本內容（用於搜索等）
                                        format: {
                                            bold: effectiveFormat.textFormat?.bold || false,
                                            italic: effectiveFormat.textFormat?.italic || false,
                                            underline: effectiveFormat.textFormat?.underline || false,
                                            strikethrough: effectiveFormat.textFormat?.strikethrough || false,
                                            fontSize: effectiveFormat.textFormat?.fontSize || 10,
                                            foregroundColor: effectiveFormat.textFormat?.foregroundColor || null,
                                            backgroundColor: effectiveFormat.backgroundColor || null
                                        },
                                        formatRuns: textFormatRuns,
                                        // 轉換為 Quill Delta 格式
                                        delta: convertGSheetsCellToQuillDelta(value, textFormatRuns, effectiveFormat)
                                    };

                                    formattedRow.push(formattedCell);
                                });

                                formattedData.push(formattedRow);
                            });

                            // 保存帶格式的工作表數據
                            excelSheets[sheetName] = {
                                data: formattedData,
                                columns: formattedData[0].map(cell => cell.value),
                                hasFormatting: true // 標記為帶格式
                            };

                            // 設置默認卡組映射
                            if (!sheetMappings[sheetName]) {
                                sheetMappings[sheetName] = {
                                    deckOption: 'new',
                                    deckId: '',
                                    newDeckName: sheetName,
                                    newDeckDescription: '從 Google Sheets 導入的字卡'
                                };
                            }

                            // 設置默認列選擇
                            if (!sheetOptions[sheetName]) {
                                sheetOptions[sheetName] = {
                                    frontColumn: 0,
                                    backColumn: 1
                                };
                            }
                        });

                        // 設置第一個工作表為活動工作表
                        activeSheetName = Object.keys(excelSheets)[0];

                        // 如果啟用同步，保存 URL 和 sync 標記到元數據
                        if (enableSync) {
                            // 保存同步元數據
                            window.gSheetsSyncData = {
                                url: gSheetsUrl,
                                spreadsheetId: spreadsheetId,
                                lastSync: Date.now(),
                                syncEnabled: true,
                                useFormatting: true // 標記為帶格式
                            };

                            // 設置定期同步
                            setupGSheetsSync();
                        }

                        resolve();
                    })
                    .catch(error => {
                        console.error('Google Sheets API 錯誤:', error);
                        reject(error);
                    });
                });
            });
        }

        // 與 Google Sheets 同步數據
        function syncWithGoogleSheets() {
            if (!window.gSheetsSyncData) return;

            const { spreadsheetId, useFormatting } = window.gSheetsSyncData;

            // 顯示同步中狀態
            const syncIndicator = document.getElementById('gSheetsSyncIndicator');
            if (syncIndicator) {
                syncIndicator.classList.add('animate-pulse');
                const syncNowBtn = document.getElementById('syncNowBtn');
                if (syncNowBtn) {
                    syncNowBtn.disabled = true;
                    syncNowBtn.textContent = '同步中...';
                }
            }

            // 根據是否使用格式化選擇同步方式
            if (useFormatting && GOOGLE_API_KEY) {
                // 使用 Google API 獲取帶格式的數據
                loadFormattedGSheetsData(spreadsheetId, window.gSheetsSyncData.url, true)
                    .then(() => {
                        // 更新字卡數據
                        updateCardsFromGSheets();

                        // 更新同步時間
                        window.gSheetsSyncData.lastSync = Date.now();

                        // 恢復同步指示器狀態
                        restoreSyncIndicator(syncIndicator);

                        showNotification('已成功與 Google Sheets 同步（含格式）');
                    })
                    .catch(error => {
                        console.error('Google Sheets API 同步錯誤:', error);
                        showNotification('格式同步失敗，嘗試純文本同步');

                        // 回退到 CSV 同步
                        syncWithGoogleSheetsCSV(spreadsheetId, syncIndicator);
                    });
            } else {
                // 使用 CSV 獲取純文本數據
                syncWithGoogleSheetsCSV(spreadsheetId, syncIndicator);
            }
        }

        // 使用 CSV 方式與 Google Sheets 同步（無格式）
        function syncWithGoogleSheetsCSV(spreadsheetId, syncIndicator) {
            const exportUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv`;

            fetch(exportUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('同步失敗，無法訪問 Google Sheets');
                    }
                    return response.text();
                })
                .then(csvData => {
                    // 解析 CSV 數據
                    const parsedData = parseCSV(csvData);

                    // 保存 Google Sheets 數據
                    const sheetName = 'GoogleSheet';
                    excelSheets[sheetName] = {
                        data: parsedData,
                        columns: parsedData[0],
                        hasFormatting: false
                    };

                    // 更新字卡數據
                    updateCardsFromGSheets();

                    // 更新同步時間
                    if (window.gSheetsSyncData) {
                        window.gSheetsSyncData.lastSync = Date.now();
                    }

                    if (value && typeof value === 'string') {
                        // 保留換行符，不要去除
                        const preservedValue = value;
                        // 繼續處理 preservedValue...
                    }

                    // 恢復同步指示器狀態
                    restoreSyncIndicator(syncIndicator);

                    showNotification('已成功與 Google Sheets 同步（純文本）');
                })
                .catch(error => {
                    console.error('Google Sheets 同步錯誤:', error);
                    showNotification(error.message || 'Google Sheets 同步失敗');

                    // 恢復同步指示器狀態
                    restoreSyncIndicator(syncIndicator);
                });
        }

        // 恢復同步指示器狀態
        function restoreSyncIndicator(syncIndicator) {
            if (syncIndicator) {
                syncIndicator.classList.remove('animate-pulse');
                const syncNowBtn = document.getElementById('syncNowBtn');
                if (syncNowBtn) {
                    syncNowBtn.disabled = false;
                    syncNowBtn.textContent = '立即同步';
                }
            }
        }

        function convertGSheetsCellToQuillDelta(value, textFormatRuns, effectiveFormat) {
            // 如果沒有文本，返回空 Delta
            if (!value) {
                return { ops: [] };
            }

            // 如果沒有格式運行，使用整體格式
            if (!textFormatRuns || textFormatRuns.length === 0) {
                const format = {};

                // 從 effectiveFormat 提取全局格式
                if (effectiveFormat && effectiveFormat.textFormat) {
                    if (effectiveFormat.textFormat.bold) format.bold = true;
                    if (effectiveFormat.textFormat.italic) format.italic = true;
                    if (effectiveFormat.textFormat.underline) format.underline = true;
                    if (effectiveFormat.textFormat.strikethrough) format.strike = true;

                    // 處理前景色 - 增強顏色處理邏輯
                    if (effectiveFormat.textFormat.foregroundColor) {
                        const color = effectiveFormat.textFormat.foregroundColor;
                        if (color.red !== undefined && color.green !== undefined && color.blue !== undefined) {
                            // 使用更精確的RGB值
                            const r = Math.round(color.red * 255);
                            const g = Math.round(color.green * 255);
                            const b = Math.round(color.blue * 255);

                            if (!isDefaultBlack) {
                              // 總是應用顏色，無論是什麼顏色
                              format.color = `rgb(${r}, ${g}, ${b})`;
                              // 保存原始顏色值以備在暗模式下使用
                              format.originalColor = [r, g, b];
                            }
                        }
                    }

                    // 處理背景色
                    if (effectiveFormat.backgroundColor) {
                        const bgColor = effectiveFormat.backgroundColor;
                        // 檢查是否不是默認白色
                        const isDefaultWhite = (bgColor.red === 1 && bgColor.green === 1 && bgColor.blue === 1);
                        if (!isDefaultWhite) {
                            const r = Math.round(bgColor.red * 255);
                            const g = Math.round(bgColor.green * 255);
                            const b = Math.round(bgColor.blue * 255);
                            format.background = `rgb(${r}, ${g}, ${b})`;
                        }
                    }
                }

                // 創建帶格式的 Delta
                return {
                    ops: [
                        {
                            insert: value,
                            attributes: Object.keys(format).length > 0 ? format : undefined
                        }
                    ]
                };
            }

            // 如果有格式運行，處理每一段
            const ops = [];
            let lastIndex = 0;

            // 按順序處理每個格式段
            textFormatRuns.forEach(run => {
                const startIndex = run.startIndex || 0;

                // 添加前一段文本（如果有）
                if (startIndex > lastIndex) {
                    const text = value.substring(lastIndex, startIndex);
                    if (text) {
                        ops.push({ insert: text });
                    }
                }

                // 獲取此格式段的結束索引
                const nextRun = textFormatRuns.find(r => r.startIndex > startIndex);
                const endIndex = nextRun ? nextRun.startIndex : value.length;

                // 提取文本
                const text = value.substring(startIndex, endIndex);

                // 提取格式 - 增強顏色處理
                const format = {};
                if (run.format) {
                    if (run.format.bold) format.bold = true;
                    if (run.format.italic) format.italic = true;
                    if (run.format.underline) format.underline = true;
                    if (run.format.strikethrough) format.strike = true;

                    // 處理前景色 - 加強顏色轉換
                    if (run.format.foregroundColor) {
                        const color = run.format.foregroundColor;
                        if (color.red !== undefined && color.green !== undefined && color.blue !== undefined) {
                            const r = Math.round(color.red * 255);
                            const g = Math.round(color.green * 255);
                            const b = Math.round(color.blue * 255);

                            // 檢查顏色是否為默認黑色
                            const isDefaultBlack = r === 0 && g === 0 && b === 0;
                            if (!isDefaultBlack) {
                                format.color = `rgb(${r}, ${g}, ${b})`;
                                // 保存原始顏色值
                                format.originalColor = [r, g, b];
                            }
                        }
                    }

                    // 處理背景色
                    if (run.format.backgroundColor) {
                        const bgColor = run.format.backgroundColor;
                        const isDefaultWhite = (bgColor.red === 1 && bgColor.green === 1 && bgColor.blue === 1);
                        if (!isDefaultWhite) {
                            const r = Math.round(bgColor.red * 255);
                            const g = Math.round(bgColor.green * 255);
                            const b = Math.round(bgColor.blue * 255);
                            format.background = `rgb(${r}, ${g}, ${b})`;
                        }
                    }
                }

                // 添加帶格式的文本
                ops.push({
                    insert: text,
                    attributes: Object.keys(format).length > 0 ? format : undefined
                });

                // 更新處理索引
                lastIndex = endIndex;
            });

            // 添加剩餘的文本（如果有）
            if (lastIndex < value.length) {
                const remainingText = value.substring(lastIndex);
                ops.push({ insert: remainingText });
            }

            return { ops: ops };
        }

        // 根據 Google Sheets 數據更新字卡
        function updateCardsFromGSheets() {
            if (!activeSheetName || !excelSheets[activeSheetName]) return;

            const sheetData = excelSheets[activeSheetName].data;
            const hasFormatting = excelSheets[activeSheetName].hasFormatting;
            const options = sheetOptions[activeSheetName];
            const mapping = sheetMappings[activeSheetName];

            // 確認選擇了正確的列
            if (!options || options.frontColumn === undefined || options.backColumn === undefined) {
                console.error('列選擇無效');
                return;
            }

            // 獲取目標卡組
            let targetDeckId;

            if (mapping.deckOption === 'existing') {
                targetDeckId = parseInt(mapping.deckId);
            } else {
                // 查找之前創建的卡組
                const existingDeck = decksData.find(d => d.name === mapping.newDeckName);
                if (existingDeck) {
                    targetDeckId = existingDeck.id;
                } else {
                    // 如果沒有找到卡組，創建一個新卡組
                    const newDeck = {
                        id: Date.now(),
                        name: mapping.newDeckName,
                        description: mapping.newDeckDescription || '',
                        cardIds: [],
                        createdAt: Date.now()
                    };

                    decksData.push(newDeck);
                    targetDeckId = newDeck.id;
                }
            }

            // 獲取目標卡組
            const targetDeck = decksData.find(d => d.id === targetDeckId);
            if (!targetDeck) {
                console.error('找不到目標卡組');
                return;
            }

            // 臨時存儲卡片 ID 與行索引的映射
            const cardRowMap = new Map();

            // 處理每一行數據（跳過標題行）
            for (let i = 1; i < sheetData.length; i++) {
                const row = sheetData[i];

                // 獲取正面和背面內容
                const frontCell = row[options.frontColumn];
                const backCell = row[options.backColumn];

                // 跳過空行
                if (!frontCell && !backCell) continue;

                // 準備卡片內容
                let frontText, backText;

                if (hasFormatting) {
                    // 處理帶格式的內容
                    frontText = convertDeltaToHTML(frontCell?.delta || { ops: [] });
                    backText = convertDeltaToHTML(backCell?.delta || { ops: [] });
                } else {
                    // 處理純文本內容
                    frontText = frontCell || '';
                    backText = backCell || '';
                }

                // 生成一個用於識別這行的唯一鍵
                const rowKey = `${frontText}_${backText}`;

                // 查找是否已存在相同內容的卡片
                let existingCard = null;
                for (const cardId of targetDeck.cardIds) {
                    const card = cardsData.find(c => c.id === cardId);
                    if (card) {
                        const cardKey = `${card.frontText}_${card.backText}`;
                        if (cardKey === rowKey) {
                            existingCard = card;
                            break;
                        }
                    }
                }

                if (existingCard) {
                    // 更新現有卡片
                    existingCard.frontText = frontText;
                    existingCard.backText = backText;
                    cardRowMap.set(existingCard.id, i);
                } else {
                    // 創建新卡片
                    const newCardId = Date.now() + i;
                    const newCard = {
                        id: newCardId,
                        frontText: frontText,
                        backText: backText,
                        nextReview: Date.now(),
                        repetitions: 0,
                        easeFactor: 2.0,
                        interval: 1.0
                    };

                    cardsData.push(newCard);
                    targetDeck.cardIds.push(newCardId);
                    cardRowMap.set(newCardId, i);
                }
            }

            // 可選：移除不再存在於表格中的卡片
            targetDeck.cardIds = targetDeck.cardIds.filter(cardId => {
                return cardRowMap.has(cardId);
            });

            // 刷新相關 UI
            loadDeckList();
            if (!manageCardSection.classList.contains('hidden')) {
                loadAllCards();
            }

            // 提醒用戶保存數據
            showStorageReminder();
        }

        // 將 Quill Delta 轉換為 HTML
        // 修改 convertDeltaToHTML 函數以正確處理換行
        // 修改 convertDeltaToHTML 函數以適應暗模式
        function convertDeltaToHTML(delta) {
            if (!delta || !delta.ops || delta.ops.length === 0) {
                return '';
            }

            // 檢測當前頁面模式
            const isDarkMode = document.documentElement.classList.contains('dark');

            // 創建臨時 div 元素
            const tempDiv = document.createElement('div');

            // 處理每個操作
            delta.ops.forEach(op => {
                if (!op.insert) return;

                // 處理文本換行
                if (typeof op.insert === 'string' && op.insert.includes('\n')) {
                    // 將文本按換行符分割
                    const lines = op.insert.split('\n');

                    for (let i = 0; i < lines.length; i++) {
                        if (i > 0) {
                            // 在每個換行前添加<br>標籤
                            tempDiv.appendChild(document.createElement('br'));
                        }

                        if (lines[i]) {
                            const span = document.createElement('span');
                            span.textContent = lines[i];

                            // 應用格式並顧及暗模式適配
                            applyFormattingWithColorEnhancement(span, op.attributes, isDarkMode);

                            tempDiv.appendChild(span);
                        }
                    }
                } else {
                    const span = document.createElement('span');
                    span.textContent = op.insert;

                    // 應用格式
                    applyFormattingWithColorEnhancement(span, op.attributes, isDarkMode);

                    tempDiv.appendChild(span);
                }
            });

            return tempDiv.innerHTML;
        }

        // 增強的格式應用函數，特別注重顏色處理
        function applyFormattingWithColorEnhancement(element, attributes, isDarkMode) {
            if (!attributes) return;

            // 基本格式
            if (attributes.bold) element.style.fontWeight = 'bold';
            if (attributes.italic) element.style.fontStyle = 'italic';
            if (attributes.underline) element.style.textDecoration = 'underline';
            if (attributes.strike) element.style.textDecoration = 'line-through';

            // 前景色處理 - 優化暗模式下的顏色顯示
            if (attributes.color) {
                // 直接使用color屬性
                element.style.color = attributes.color;

                // 對特定顏色在暗模式下進行調整
                if (isDarkMode) {
                    // 可能需要根據暗模式調整某些顏色的亮度/對比度
                    // 例如：在暗模式下加亮深色文字
                    const colorMatch = attributes.color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (colorMatch) {
                        const r = parseInt(colorMatch[1]);
                        const g = parseInt(colorMatch[2]);
                        const b = parseInt(colorMatch[3]);

                        // 計算顏色亮度 (0-255)
                        const brightness = (r * 299 + g * 587 + b * 114) / 1000;

                        // 如果顏色太暗，在暗模式下提亮
                        if (brightness < 128) {
                            // 提亮顏色，但保持色調
                            element.style.color = `rgb(${Math.min(r + 100, 255)}, ${Math.min(g + 100, 255)}, ${Math.min(b + 100, 255)})`;
                            // 添加文字陰影增加可讀性
                            element.style.textShadow = '0 0 2px rgba(0,0,0,0.5)';
                        }
                    }
                }
            }

            // 背景色處理
            if (attributes.background) {
                // 檢查是否為白色或接近白色的背景
                if (attributes.background === 'rgb(255, 255, 255)' ||
                    attributes.background.match(/rgb\(2[0-9][0-9], 2[0-9][0-9], 2[0-9][0-9]\)/)) {

                    if (isDarkMode) {
                        // 在暗模式下將白色背景改為半透明
                        element.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                        // 確保文字可見
                        if (!attributes.color) {
                            element.style.color = '#fff';
                        }
                    } else {
                        element.style.backgroundColor = attributes.background;
                    }
                } else {
                    // 其他背景色直接應用，可能還需按暗模式調整
                    element.style.backgroundColor = attributes.background;

                    // 在暗模式下，可能需要調整背景色的透明度
                    if (isDarkMode) {
                        const match = attributes.background.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                        if (match) {
                            // 使背景色半透明以配合暗模式
                            element.style.backgroundColor = `rgba(${match[1]}, ${match[2]}, ${match[3]}, 0.7)`;
                        }
                    }
                }
            }

            // 添加CSS類以便進一步通過CSS自定義樣式
            if (attributes.color) element.classList.add('has-text-color');
            if (attributes.background) element.classList.add('has-background');
        }

        // 添加一個新的輔助函數來處理暗模式適應的格式應用
        function applyFormattingWithDarkModeAwareness(element, attributes) {
            if (!attributes) return;

            if (attributes.bold) element.style.fontWeight = 'bold';
            if (attributes.italic) element.style.fontStyle = 'italic';
            if (attributes.underline) element.style.textDecoration = 'underline';
            if (attributes.strike) element.style.textDecoration = 'line-through';
            if (attributes.color) element.style.color = attributes.color;

            // 背景色處理 - 添加暗模式適應
            if (attributes.background) {
                // 檢查是否為白色或接近白色的背景
                if (attributes.background === 'rgb(255, 255, 255)' ||
                    attributes.background.match(/rgb\(2[0-9][0-9], 2[0-9][0-9], 2[0-9][0-9]\)/)) {

                    // 在暗模式下，將白色背景轉換為淺灰色
                    // 可以通過檢測頁面當前模式來確定
                    const isDarkMode = document.documentElement.classList.contains('dark');

                    if (isDarkMode) {
                        element.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'; // 半透明白色在暗模式下
                        element.style.color = '#fff'; // 確保文字在暗背景下可見
                    } else {
                        element.style.backgroundColor = attributes.background;
                    }
                } else {
                    // 非白色背景直接應用
                    element.style.backgroundColor = attributes.background;
                }
            }
        }

        // 初始化Quill編輯器 - 使用直接HTML創建工具欄，並防止表單提交
        // 初始化Quill編輯器 - 修復輸入問題
        function initQuillEditors() {
          console.log("初始化Quill編輯器...");

          // 確保之前的實例被清理
          if (frontQuill) {
            try {
              frontQuill.off('selection-change');
              frontQuill = null;
            } catch (e) {
              console.log("清理前面編輯器失敗:", e);
            }
          }

          if (backQuill) {
            try {
              backQuill.off('selection-change');
              backQuill = null;
            } catch (e) {
              console.log("清理背面編輯器失敗:", e);
            }
          }

          // 定義 formatButtons 對象
          formatButtons = {};

          console.log("工具欄HTML已創建，正在創建編輯器...");

          // 使用延遲初始化，確保DOM已完全加載
          setTimeout(() => {
            try {
              // 檢查編輯器容器是否存在
              const frontEditorContainer = document.getElementById('frontEditor');
              const backEditorContainer = document.getElementById('backEditor');

              if (!frontEditorContainer || !backEditorContainer) {
                console.error("找不到編輯器容器元素");
                return;
              }

              // 確保容器是空的並且能夠接收點擊
              frontEditorContainer.innerHTML = '';
              backEditorContainer.innerHTML = '';

              // 確保編輯器容器可以接收事件
              frontEditorContainer.style.pointerEvents = 'auto';
              backEditorContainer.style.pointerEvents = 'auto';

              // 定義共用的工具欄配置
              const standardToolbarOptions = [
                ['bold', 'italic', 'underline', 'strike'],
                ['blockquote'],
                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                [{ 'align': ['', 'center', 'right', 'justify'] }],
                [{ 'color': [] }, { 'background': [] }],
                [{ 'size': ['small', false, 'large', 'huge'] }],
                ['image'] // 添加圖片按鈕
              ];

              // 初始化Quill編輯器 - 使用擴展配置
              frontQuill = new Quill('#frontEditor', {
                theme: 'snow',
                modules: {
                  toolbar: {
                    container: standardToolbarOptions,
                    handlers: {
                      // 可以添加自定義處理器
                    }
                  },
                  clipboard: {
                    matchVisual: false // 改進粘貼行為
                  }
                },
                placeholder: '輸入卡片正面內容...'
              });

              console.log("正在初始化背面編輯器...");
              backQuill = new Quill('#backEditor', {
                theme: 'snow',
                modules: {
                  toolbar: standardToolbarOptions
                },
                placeholder: '輸入卡片背面內容...'
              });

              // 編輯模式編輯器初始化 - 使用相同的工具欄配置確保一致性
              const editFrontEditorContainer = document.getElementById('editFrontEditor');
              const editBackEditorContainer = document.getElementById('editBackEditor');

              if (editFrontEditorContainer && editBackEditorContainer) {
                console.log("正在初始化編輯模式編輯器...");
                editFrontQuill = new Quill('#editFrontEditor', {
                  theme: 'snow',
                  modules: {
                    toolbar: standardToolbarOptions
                  },
                  placeholder: '輸入卡片正面內容...'
                });

                editBackQuill = new Quill('#editBackEditor', {
                  theme: 'snow',
                  modules: {
                    toolbar: standardToolbarOptions
                  },
                  placeholder: '輸入卡片背面內容...'
                });


                editBackQuill = new Quill('#editBackEditor', {
                  theme: 'snow',
                  modules: {
                    toolbar: [
                      ['bold', 'italic', 'underline', 'strike'],
                      ['blockquote'],
                      [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                      [{ 'color': [] }, { 'background': [] }],
                      [{ 'size': ['small', false, 'large', 'huge'] }]
                    ]
                  },
                  placeholder: '輸入卡片背面內容...'
                });
              } else {
                console.log("編輯模式編輯器容器不存在，跳過初始化");
              }

              // 移除編輯器內容區域的重複工具欄
              document.querySelectorAll('.editor-content .ql-toolbar').forEach(toolbar => {
                if (toolbar.parentNode) {
                  toolbar.parentNode.removeChild(toolbar);
                }
              });

              console.log("編輯器已創建，設置事件處理器...");

              // 確保編輯器區域可點擊，能夠獲得焦點
              document.querySelectorAll('.ql-editor').forEach(editor => {
                editor.style.pointerEvents = 'auto';
                editor.style.userSelect = 'text';
              });

              // 為每個按鈕添加獨立事件處理器，避免事件衝突
              for (const [format, button] of Object.entries(formatButtons)) {
                if (!button) {
                  console.warn(`找不到按鈕: ${format}`);
                  continue;
                }

                // 刪除任何現有的事件監聽器，避免重複
                const newButton = button.cloneNode(true);
                if (button.parentNode) {
                  button.parentNode.replaceChild(newButton, button);
                }

                // 添加新的事件監聽器
                newButton.addEventListener('click', (e) => {
                  console.log(`點擊了 ${format} 按鈕`);
                  e.preventDefault();
                  e.stopPropagation();

                  if (!activeQuill) {
                    console.warn("沒有活動的編輯器");
                    return false;
                  }

                  try {
                    const currentFormat = activeQuill.getFormat();

                    if (format === 'orderedList') {
                      const isOrdered = currentFormat.list === 'ordered';
                      activeQuill.format('list', isOrdered ? false : 'ordered');
                      newButton.classList.toggle('active', !isOrdered);
                    }
                    else if (format === 'bulletList') {
                      const isBullet = currentFormat.list === 'bullet';
                      activeQuill.format('list', isBullet ? false : 'bullet');
                      newButton.classList.toggle('active', !isBullet);
                    }
                    else {
                      const formatKey = format === 'blockquote' ? 'blockquote' : format;
                      const newValue = !currentFormat[formatKey];
                      activeQuill.format(formatKey, newValue);
                      newButton.classList.toggle('active', newValue);
                    }

                    activeQuill.focus();
                  } catch (error) {
                    console.error(`格式化錯誤 (${format}):`, error);
                  }

                  return false;
                });

                // 更新引用
                formatButtons[format] = newButton;
              }

              // 更新按鈕活動狀態的函數
              function updateButtonStates() {
                if (!activeQuill) return;

                try {
                  // 檢查編輯器選擇範圍是否存在
                  const selection = activeQuill.getSelection();
                  if (!selection) return;

                  const format = activeQuill.getFormat(selection);

                  Object.entries(formatButtons).forEach(([key, button]) => {
                    if (!button) return;

                    if (key === 'orderedList') {
                      button.classList.toggle('active', format.list === 'ordered');
                    } else if (key === 'bulletList') {
                      button.classList.toggle('active', format.list === 'bullet');
                    } else {
                      const formatKey = key === 'blockquote' ? 'blockquote' : key;
                      button.classList.toggle('active', !!format[formatKey]);
                    }
                  });
                } catch (error) {
                  console.error("更新按鈕狀態時出錯:", error);
                }
              }

              // 為編輯器添加焦點和選擇事件
              if (frontQuill && frontQuill.root) {
                frontQuill.root.addEventListener('focus', function() {
                  console.log("前面編輯器獲得焦點");
                  activeQuill = frontQuill;
                  updateButtonStates();
                });

                frontQuill.on('selection-change', function() {
                  if (frontQuill.hasFocus()) {
                    activeQuill = frontQuill;
                    updateButtonStates();
                  }
                });
              }

              if (backQuill && backQuill.root) {
                backQuill.root.addEventListener('focus', function() {
                  console.log("背面編輯器獲得焦點");
                  activeQuill = backQuill;
                  updateButtonStates();
                });

                backQuill.on('selection-change', function() {
                  if (backQuill.hasFocus()) {
                    activeQuill = backQuill;
                    updateButtonStates();
                  }
                });
              }

              // 添加Tab鍵順序
              if (frontQuill && frontQuill.root) {
                frontQuill.root.setAttribute('tabindex', '1');
              }

              if (backQuill && backQuill.root) {
                backQuill.root.setAttribute('tabindex', '2');
              }

              // 調整Quill編輯器的深色模式
              adjustQuillForDarkMode();

              // 初始化時設置焦點
              setTimeout(() => {
                if (frontQuill) {
                  try {
                    frontQuill.focus();
                    console.log("設置焦點到前面編輯器");
                  } catch (error) {
                    console.error("設置焦點時出錯:", error);
                  }
                }
              }, 200);

              console.log("Quill編輯器初始化完成");
            } catch (error) {
              console.error("初始化Quill編輯器時發生錯誤:", error);
            }
          }, 300);  // 延遲初始化，確保DOM已完全加載
        }

        // 處理圖片拖拽
        [frontQuill, backQuill, editFrontQuill, editBackQuill].forEach(editor => {
          if (!editor) return;

          const editorElement = editor.root;

          // 處理拖拽進入
          editorElement.addEventListener('dragover', function(e) {
            e.preventDefault();
            editorElement.classList.add('drag-over');
          });

          // 處理拖拽離開
          editorElement.addEventListener('dragleave', function(e) {
            e.preventDefault();
            editorElement.classList.remove('drag-over');
          });

          // 處理拖拽放下
          editorElement.addEventListener('drop', function(e) {
            e.preventDefault();
            editorElement.classList.remove('drag-over');

            // 檢查是否有文件被拖拽
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
              const file = e.dataTransfer.files[0];

              // 檢查是否為圖片
              if (file.type.match('image.*')) {
                const reader = new FileReader();

                reader.onload = function(event) {
                  // 獲取當前選中位置
                  const range = editor.getSelection();

                  // 在當前位置插入圖片
                  if (range) {
                    // 智能壓縮圖片
                    analyzeAndCompressImage(event.target.result).then(compressedImage => {
                      editor.insertEmbed(range.index, 'image', compressedImage);

                      // 移動光標到圖片後面
                      editor.setSelection(range.index + 1);
                    });
                  }
                };

                reader.readAsDataURL(file);
              }
            }
          });
        });

        // 添加顯示拖拽區域的CSS樣式
        const dragStyleElement = document.createElement('style');
        dragStyleElement.textContent = `
          .ql-editor.drag-over {
            border: 2px dashed #5D5CDE;
            background-color: rgba(93, 92, 222, 0.05);
          }
        `;
        document.head.appendChild(dragStyleElement);



        // 根據當前主題調整Quill編輯器
        function adjustQuillForDarkMode() {
            const isDarkMode = document.documentElement.classList.contains('dark');
            const allEditors = [frontQuill, backQuill, editFrontQuill, editBackQuill].filter(editor => editor);

            allEditors.forEach(editor => {
                if (!editor) return;

                const container = editor.container;
                const toolbar = container.previousElementSibling;

                if (isDarkMode) {
                    container.classList.add('dark-quill');
                    if (toolbar) toolbar.classList.add('dark-toolbar');
                } else {
                    container.classList.remove('dark-quill');
                    if (toolbar) toolbar.classList.remove('dark-toolbar');
                }
            });
        }

        // Smart image compression functions
        async function analyzeAndCompressImage(dataUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    // 分析圖片複雜度
                    const canvas = document.createElement('canvas');
                    const smallSize = 50; // 小尺寸用於分析
                    canvas.width = smallSize;
                    canvas.height = smallSize;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, smallSize, smallSize);

                    // 分析圖片複雜度 (用簡單的邊緣檢測)
                    const imageData = ctx.getImageData(0, 0, smallSize, smallSize);
                    const data = imageData.data;
                    let complexity = 0;

                    // 計算相鄰像素差異，估算圖片複雜度
                    for (let y = 0; y < smallSize - 1; y++) {
                        for (let x = 0; x < smallSize - 1; x++) {
                            const i = (y * smallSize + x) * 4;
                            const i2 = (y * smallSize + x + 1) * 4;
                            const i3 = ((y + 1) * smallSize + x) * 4;

                            // 計算水平和垂直差異
                            const diffX = Math.abs(data[i] - data[i2]) +
                                         Math.abs(data[i+1] - data[i2+1]) +
                                         Math.abs(data[i+2] - data[i2+2]);

                            const diffY = Math.abs(data[i] - data[i3]) +
                                         Math.abs(data[i+1] - data[i3+1]) +
                                         Math.abs(data[i+2] - data[i3+2]);

                            complexity += (diffX + diffY);
                        }
                    }

                    // 標準化複雜度
                    complexity = complexity / (smallSize * smallSize * 6);

                    // 根據複雜度和尺寸調整壓縮參數
                    let quality = 0.85; // 默認較高品質
                    let maxWidth = 1000;
                    let maxHeight = 800;

                    // 根據圖片複雜度調整品質
                    // 複雜圖片(文字、細節多)保持較高品質
                    if (complexity > 30) {
                        quality = 0.88; // 更高品質
                    } else if (complexity < 10) {
                        quality = 0.80; // 較簡單圖片可以多壓縮
                    }

                    // 根據原始尺寸調整目標尺寸
                    if (img.width > 2000 || img.height > 2000) {
                        // 非常大的圖片，適度縮小
                        maxWidth = 1200;
                        maxHeight = 1000;
                    } else if (img.width < 500 && img.height < 500) {
                        // 小圖片基本不縮小
                        maxWidth = Math.max(img.width, 500);
                        maxHeight = Math.max(img.height, 500);
                    }

                    // 執行壓縮
                    compressImage(dataUrl, maxWidth, maxHeight, quality).then(result => {
                        resolve(result);
                    });
                };
                img.src = dataUrl;
            });
        }

        // 圖片壓縮核心功能
        async function compressImage(dataUrl, maxWidth = 1000, maxHeight = 800, quality = 0.85) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    // 計算新尺寸，保持原始比例
                    let width = img.width;
                    let height = img.height;
                    let resized = false;

                    // 只有圖片超過最大尺寸時才調整
                    if (width > maxWidth) {
                        height = Math.round((height * maxWidth) / width);
                        width = maxWidth;
                        resized = true;
                    }

                    if (height > maxHeight) {
                        width = Math.round((width * maxHeight) / height);
                        height = maxHeight;
                        resized = true;
                    }

                    // 如果圖片已經很小且沒有調整過尺寸，不進行壓縮
                    if (width < 500 && height < 500 && dataUrl.length < 100 * 1024 && !resized) {
                        resolve(dataUrl);
                        return;
                    }

                    // 創建 canvas 進行尺寸調整和壓縮
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // 轉換為適中壓縮的 JPEG 格式
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);

                    resolve(compressedDataUrl);
                };
                img.src = dataUrl;
            });
        }

        // 設置圖片壓縮功能
        function setupImageCompression() {
            // 前面圖片處理
            cardFrontImageInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                frontImageName.textContent = file.name;
                frontImagePreview.classList.remove('hidden');

                // 顯示載入中狀態
                frontPreviewImg.src = ''; // 清空之前的圖片
                frontPreviewImg.style.display = 'none';
                const loadingIndicator = document.createElement('div');
                loadingIndicator.className = 'text-center py-2';
                loadingIndicator.textContent = '處理圖片中...';
                frontImagePreview.appendChild(loadingIndicator);

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // 進行智能壓縮
                        const compressedDataUrl = await analyzeAndCompressImage(e.target.result);

                        // 更新圖片數據和預覽
                        frontImageData = compressedDataUrl;

                        // 移除載入指示器
                        if (loadingIndicator.parentNode) {
                            loadingIndicator.parentNode.removeChild(loadingIndicator);
                        }

                        // 顯示圖片預覽
                        frontPreviewImg.src = compressedDataUrl;
                        frontPreviewImg.style.display = 'block';

                    } catch (error) {
                        console.error('圖片處理錯誤:', error);
                        frontImagePreview.innerHTML = `
                            <div class="text-red-500">圖片處理失敗</div>
                        `;
                    }
                };
                reader.readAsDataURL(file);
            });

            // 背面圖片處理
            cardBackImageInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                backImageName.textContent = file.name;
                backImagePreview.classList.remove('hidden');

                // 顯示載入中狀態
                backPreviewImg.src = '';
                backPreviewImg.style.display = 'none';
                const loadingIndicator = document.createElement('div');
                loadingIndicator.className = 'text-center py-2';
                loadingIndicator.textContent = '處理圖片中...';
                backImagePreview.appendChild(loadingIndicator);

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // 進行智能壓縮
                        const compressedDataUrl = await analyzeAndCompressImage(e.target.result);

                        // 更新圖片數據和預覽
                        backImageData = compressedDataUrl;

                        // 移除載入指示器
                        if (loadingIndicator.parentNode) {
                            loadingIndicator.parentNode.removeChild(loadingIndicator);
                        }

                        // 顯示圖片預覽
                        backPreviewImg.src = compressedDataUrl;
                        backPreviewImg.style.display = 'block';

                    } catch (error) {
                        console.error('圖片處理錯誤:', error);
                        backImagePreview.innerHTML = `
                            <div class="text-red-500">圖片處理失敗</div>
                        `;
                    }
                };
                reader.readAsDataURL(file);
            });

            // 編輯正面圖片處理
            editCardFrontImage.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                editFrontImagePreview.classList.remove('hidden');

                // 顯示載入中狀態
                editFrontPreviewImg.src = '';
                editFrontPreviewImg.style.display = 'none';
                const loadingIndicator = document.createElement('div');
                loadingIndicator.className = 'text-center py-2';
                loadingIndicator.textContent = '處理圖片中...';
                editFrontImagePreview.appendChild(loadingIndicator);

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // 進行智能壓縮
                        const compressedDataUrl = await analyzeAndCompressImage(e.target.result);

                        // 更新圖片數據和預覽
                        editFrontImageData = compressedDataUrl;

                        // 移除載入指示器
                        if (loadingIndicator.parentNode) {
                            loadingIndicator.parentNode.removeChild(loadingIndicator);
                        }

                        // 顯示圖片預覽
                        editFrontPreviewImg.src = compressedDataUrl;
                        editFrontPreviewImg.style.display = 'block';

                    } catch (error) {
                        console.error('圖片處理錯誤:', error);
                        editFrontImagePreview.innerHTML = `
                            <div class="text-red-500">圖片處理失敗</div>
                        `;
                    }
                };
                reader.readAsDataURL(file);
            });

            // 編輯背面圖片處理
            editCardBackImage.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                editBackImagePreview.classList.remove('hidden');

                // 顯示載入中狀態
                editBackPreviewImg.src = '';
                editBackPreviewImg.style.display = 'none';
                const loadingIndicator = document.createElement('div');
                loadingIndicator.className = 'text-center py-2';
                loadingIndicator.textContent = '處理圖片中...';
                editBackImagePreview.appendChild(loadingIndicator);

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        // 進行智能壓縮
                        const compressedDataUrl = await analyzeAndCompressImage(e.target.result);

                        // 更新圖片數據和預覽
                        editBackImageData = compressedDataUrl;

                        // 移除載入指示器
                        if (loadingIndicator.parentNode) {
                            loadingIndicator.parentNode.removeChild(loadingIndicator);
                        }

                        // 顯示圖片預覽
                        editBackPreviewImg.src = compressedDataUrl;
                        editBackPreviewImg.style.display = 'block';

                    } catch (error) {
                        console.error('圖片處理錯誤:', error);
                        editBackImagePreview.innerHTML = `
                            <div class="text-red-500">圖片處理失敗</div>
                        `;
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        // 設置拖放上傳功能
        function setupDragAndDrop() {
            // 獲取拖放區域元素
            const frontDragArea = document.getElementById('frontDragArea');
            const backDragArea = document.getElementById('backDragArea');

            if (frontDragArea) {
                setupDragArea(frontDragArea, cardFrontImageInput);
            }

            if (backDragArea) {
                setupDragArea(backDragArea, cardBackImageInput);
            }

            // 同樣為編輯模式設置拖放區
            const editFrontDragArea = document.getElementById('editFrontDragArea');
            const editBackDragArea = document.getElementById('editBackDragArea');

            if (editFrontDragArea) {
                setupDragArea(editFrontDragArea, editCardFrontImage);
            }

            if (editBackDragArea) {
                setupDragArea(editBackDragArea, editCardBackImage);
            }
        }

        function setupDragArea(dragArea, fileInput) {
            // 阻止默認拖放行為以允許自定義處理
            dragArea.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragArea.querySelector('.drag-overlay').style.display = 'block';
            });

            dragArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });

            dragArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // 檢查是否真的離開了元素
                const rect = dragArea.getBoundingClientRect();
                const x = e.clientX;
                const y = e.clientY;

                if (x < rect.left || x >= rect.right || y < rect.top || y >= rect.bottom) {
                    dragArea.querySelector('.drag-overlay').style.display = 'none';
                }
            });

            dragArea.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragArea.querySelector('.drag-overlay').style.display = 'none';

                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];

                    // 檢查是否為圖片
                    if (file.type.match('image.*')) {
                        // 使用現有的檔案輸入框處理圖片
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(file);
                        fileInput.files = dataTransfer.files;

                        // 觸發 change 事件以處理圖片
                        const event = new Event('change', { bubbles: true });
                        fileInput.dispatchEvent(event);
                    } else {
                        showNotification('請上傳圖片檔案');
                    }
                }
            });
        }

        // Storage reminder functions
        function showStorageReminder() {
            if (!reminderShown && (cardsData.length > 0 || decksData.length > 0)) {
                storageReminder.classList.remove('hidden');
                reminderShown = true;

                // 設置提醒按鈕事件
                exportReminderBtn.addEventListener('click', () => {
                    openExportModal();
                    storageReminder.classList.add('hidden');
                });

                dismissReminderBtn.addEventListener('click', () => {
                    storageReminder.classList.add('hidden');
                });
            }
        }

        // Show storage reminder periodically
        function setupStorageReminders() {
            // 當有資料後每 10 分鐘提醒一次
            setInterval(() => {
                if (cardsData.length > 0 || decksData.length > 0) {
                    reminderShown = false;
                    showStorageReminder();
                }
            }, 10 * 60 * 1000);

            // 當有資料變動時提醒
            const checkForReminder = () => {
                if (cardsData.length > 0 || decksData.length > 0) {
                    showStorageReminder();
                }
            };

            // 5秒後檢查是否需要顯示提醒
            setTimeout(checkForReminder, 5000);
        }

        // Card batch selection handlers
        selectAllCards.addEventListener('change', function() {
            const checkboxes = document.querySelectorAll('.card-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = this.checked;
                const cardId = parseInt(checkbox.value);
                if (this.checked) {
                    selectedCardIds.add(cardId);
                } else {
                    selectedCardIds.delete(cardId);
                }
            });
            updateBatchDeleteButton();
        });

        // Deck batch selection handlers
        selectAllDecks.addEventListener('change', function() {
            const checkboxes = document.querySelectorAll('.deck-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = this.checked;
                const deckId = parseInt(checkbox.value);
                if (this.checked) {
                    selectedDeckIds2.add(deckId);
                } else {
                    selectedDeckIds2.delete(deckId);
                }
            });
            updateBatchDeleteDecksButton();
        });

        // Batch delete button
        deleteBatchCardsBtn.addEventListener('click', deleteSelectedCards);
        deleteBatchDecksBtn.addEventListener('click', deleteSelectedDecks);

        // Create new deck button
        createNewDeckBtn.addEventListener('click', openNewDeckModal);
        createFirstDeckLink.addEventListener('click', (e) => {
            e.preventDefault();
            openNewDeckModal();
        });

        // Add Deck in Manage section
        addDeckInManageBtn.addEventListener('click', openNewDeckModal);

        // New deck modal handlers
        closeNewDeckBtn.addEventListener('click', closeNewDeckModal);
        saveNewDeckBtn.addEventListener('click', saveNewDeck);

        // Import/Export Handlers
        exportDataBtn.addEventListener('click', openExportModal);
        cancelExportBtn.addEventListener('click', closeExportModal);
        confirmExportBtn.addEventListener('click', exportData);
        importDataInput.addEventListener('change', handleImportFile);

        // Export Excel Handlers
        exportExcelBtn.addEventListener('click', openExportExcelModal);
        cancelExportExcelBtn.addEventListener('click', closeExportExcelModal);
        confirmExportExcelBtn.addEventListener('click', exportExcelData);

        // Excel export deck selection handlers
        selectAllExportExcelDecksBtn.addEventListener('click', selectAllExportExcelDecks);
        deselectAllExportExcelDecksBtn.addEventListener('click', deselectAllExportExcelDecks);

        // Import preview handlers
        cancelImportBtn.addEventListener('click', closeImportPreviewModal);
        confirmImportBtn.addEventListener('click', processImport);

        // Export deck selection handlers
        selectAllExportDecksBtn.addEventListener('click', selectAllExportDecks);
        deselectAllExportDecksBtn.addEventListener('click', deselectAllExportDecks);

        // Import deck selection handlers
        selectAllImportDecksBtn.addEventListener('click', selectAllImportDecks);
        deselectAllImportDecksBtn.addEventListener('click', deselectAllImportDecks);

        // Delete All buttons with confirmation
        deleteAllCardsBtn.addEventListener('click', function() {
            customConfirm('確定要刪除所有字卡嗎？此操作無法撤銷。', '刪除所有字卡', function(confirmed) {
                if (confirmed) {
                    deleteAllCards();
                }
            });
        });

        deleteAllDecksBtn.addEventListener('click', function() {
            customConfirm('確定要刪除所有卡組嗎？此操作無法撤銷，所有字卡也將被刪除。', '刪除所有卡組', function(confirmed) {
                if (confirmed) {
                    deleteAllDecks();
                }
            });
        });

        // Function to select all export Excel decks
        function selectAllExportExcelDecks() {
            const checkboxes = exportExcelDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                selectedExportExcelDeckIds.push(parseInt(checkbox.value));
            });

            // Remove duplicates
            selectedExportExcelDeckIds = [...new Set(selectedExportExcelDeckIds)];
        }

        // Function to deselect all export Excel decks
        function deselectAllExportExcelDecks() {
            const checkboxes = exportExcelDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            selectedExportExcelDeckIds = [];
        }

        // Function to open export Excel modal
        function openExportExcelModal() {
            // Reset selected decks
            selectedExportExcelDeckIds = [];

            // Set default filename with current date
            const now = new Date();
            const dateStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}`;
            exportExcelFilenameInput.value = `flashcards_${dateStr}`;

            // Load deck selection list
            loadExportExcelDecksList();

            // Show modal
            exportExcelModal.classList.remove('hidden');

            // Add click outside to close functionality
            document.addEventListener('click', handleExportExcelModalOutsideClick);
        }

        // Function to load decks for Excel export selection
        function loadExportExcelDecksList() {
            exportExcelDecksList.innerHTML = '';

            if (decksData.length === 0) {
                exportExcelDecksList.innerHTML = '<div class="text-center py-4 text-gray-500 dark:text-gray-400">沒有可用的卡組。</div>';
                return;
            }

            // Sort decks by name for easier selection
            const sortedDecks = [...decksData].sort((a, b) => a.name.localeCompare(b.name));

            // By default, select all decks
            selectedExportExcelDeckIds = sortedDecks.map(deck => deck.id);

            sortedDecks.forEach(deck => {
                const deckItem = document.createElement('div');
                deckItem.className = 'flex items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';

                const cardCount = deck.cardIds.length;

                deckItem.innerHTML = `
                    <input type="checkbox" id="export-excel-deck-${deck.id}" value="${deck.id}" class="mr-2" checked>
                    <label for="export-excel-deck-${deck.id}" class="flex-1 flex justify-between items-center cursor-pointer">
                        <span>${deck.name}</span>
                        <span class="text-xs text-gray-500 dark:text-gray-400">${cardCount} 張字卡</span>
                    </label>
                `;

                exportExcelDecksList.appendChild(deckItem);

                // Add change event for checkbox
                const checkbox = deckItem.querySelector(`#export-excel-deck-${deck.id}`);
                checkbox.addEventListener('change', function() {
                    const deckId = parseInt(this.value);
                    if (this.checked) {
                        if (!selectedExportExcelDeckIds.includes(deckId)) {
                            selectedExportExcelDeckIds.push(deckId);
                        }
                    } else {
                        selectedExportExcelDeckIds = selectedExportExcelDeckIds.filter(id => id !== deckId);
                    }
                });
            });
        }

        // Function to close export Excel modal
        function closeExportExcelModal() {
            exportExcelModal.classList.add('hidden');
            document.removeEventListener('click', handleExportExcelModalOutsideClick);
        }

        // Handle click outside the export Excel modal to close it
        function handleExportExcelModalOutsideClick(event) {
            const modalContent = exportExcelModal.querySelector('div');
            if (exportExcelModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeExportExcelModal();
            }
        }

        // Function to export Excel data
        function exportExcelData() {
            if (selectedExportExcelDeckIds.length === 0) {
                showNotification('請至少選擇一個卡組進行導出');
                return;
            }

            const filename = exportExcelFilenameInput.value.trim() || 'flashcards';

            // Filter selected decks
            const selectedDecks = decksData.filter(deck => selectedExportExcelDeckIds.includes(deck.id));

            // Create workbook
            const wb = XLSX.utils.book_new();

            // Process each selected deck
            selectedDecks.forEach(deck => {
                // Get cards for this deck
                const deckCards = cardsData.filter(card => deck.cardIds.includes(card.id));

                // Prepare data for worksheet
                const sheetData = [
                    ['正面內容', '背面內容'] // Header row
                ];

                // Add cards data
                deckCards.forEach(card => {
                    // 從HTML內容中提取純文本
                    const frontText = stripHtml(card.frontText || '');
                    const backText = stripHtml(card.backText || '');

                    sheetData.push([frontText, backText]);
                });

                // Create worksheet and add to workbook
                const ws = XLSX.utils.aoa_to_sheet(sheetData);

                // 確保工作表名稱合法 (Excel工作表名稱最多31個字符，且不能包含某些特殊字符)
                let sheetName = deck.name;
                if (sheetName.length > 31) sheetName = sheetName.substring(0, 28) + '...';
                sheetName = sheetName.replace(/[\[\]\*\/\\\?:]/g, '_'); // 替換不允許的字符

                XLSX.utils.book_append_sheet(wb, ws, sheetName);
            });

            // Add timestamp to filename to make it unique
            const filenameSuffix = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 14);
            const fullFilename = `${filename}_${filenameSuffix}.xlsx`;

            // Generate and download Excel file
            XLSX.writeFile(wb, fullFilename);

            closeExportExcelModal();
            showNotification(`成功導出 ${selectedDecks.length} 個卡組至Excel檔案`);
        }

        // Function to delete all cards
        function deleteAllCards() {
            // If a deck filter is active, only delete cards from that deck
            const selectedDeckId = deckFilterSelect.value;

            if (selectedDeckId !== 'all') {
                const deckId = parseInt(selectedDeckId);
                const deck = decksData.find(d => d.id === deckId);

                if (deck) {
                    // Remove cards from the deck
                    const deckCards = [...deck.cardIds];
                    deck.cardIds = [];

                    // If cards are only in this deck, remove them from cardsData
                    deckCards.forEach(cardId => {
                        // Check if card exists in other decks
                        const existsInOtherDecks = decksData.some(d => d.id !== deckId && d.cardIds.includes(cardId));

                        if (!existsInOtherDecks) {
                            cardsData = cardsData.filter(card => card.id !== cardId);
                        }
                    });
                }
            } else {
                // Delete all cards globally
                cardsData = [];
                // Also remove all cards from all decks
                decksData.forEach(deck => {
                    deck.cardIds = [];
                });
            }

            // Clear selection
            selectedCardIds.clear();
            updateBatchDeleteButton();

            // Refresh UI
            loadAllCards();
            showNotification('已刪除所有字卡');

            // Show storage reminder
            showStorageReminder();
        }

        // Function to delete all decks
        function deleteAllDecks() {
            decksData = [];
            cardsData = [];

            // Clear selection
            selectedDeckIds2.clear();
            updateBatchDeleteDecksButton();

            // Refresh UI
            loadAllDecks();
            loadDeckList();
            showNotification('已刪除所有卡組');

            // Show storage reminder
            showStorageReminder();
        }

        // Function to select all export decks
        function selectAllExportDecks() {
            const checkboxes = exportDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                selectedExportDeckIds.push(parseInt(checkbox.value));
            });

            // Remove duplicates
            selectedExportDeckIds = [...new Set(selectedExportDeckIds)];
        }

        // Function to deselect all export decks
        function deselectAllExportDecks() {
            const checkboxes = exportDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            selectedExportDeckIds = [];
        }

        // Function to select all import decks
        function selectAllImportDecks() {
            const checkboxes = importDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                selectedImportDeckIds.push(checkbox.value);
            });

            // Remove duplicates
            selectedImportDeckIds = [...new Set(selectedImportDeckIds)];
        }

        // Function to deselect all import decks
        function deselectAllImportDecks() {
            const checkboxes = importDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            selectedImportDeckIds = [];
        }

        // Function to open export modal
        function openExportModal() {
            // Reset selected decks
            selectedExportDeckIds = [];

            // Set default filename with current date
            const now = new Date();
            const dateStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}`;
            exportFilenameInput.value = `flashcards_${dateStr}`;

            // Load deck selection list
            loadExportDecksList();

            // Show modal
            exportModal.classList.remove('hidden');

            // Add click outside to close functionality
            document.addEventListener('click', handleExportModalOutsideClick);
        }

        // Function to load decks for export selection
        function loadExportDecksList() {
            exportDecksList.innerHTML = '';

            if (decksData.length === 0) {
                exportDecksList.innerHTML = '<div class="text-center py-4 text-gray-500 dark:text-gray-400">沒有可用的卡組。</div>';
                return;
            }

            // Sort decks by name for easier selection
            const sortedDecks = [...decksData].sort((a, b) => a.name.localeCompare(b.name));

            // By default, select all decks
            selectedExportDeckIds = sortedDecks.map(deck => deck.id);

            sortedDecks.forEach(deck => {
                const deckItem = document.createElement('div');
                deckItem.className = 'flex items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';

                const cardCount = deck.cardIds.length;

                deckItem.innerHTML = `
                    <input type="checkbox" id="export-deck-${deck.id}" value="${deck.id}" class="mr-2" checked>
                    <label for="export-deck-${deck.id}" class="flex-1 flex justify-between items-center cursor-pointer">
                        <span>${deck.name}</span>
                        <span class="text-xs text-gray-500 dark:text-gray-400">${cardCount} 張字卡</span>
                    </label>
                `;

                exportDecksList.appendChild(deckItem);

                // Add change event for checkbox
                const checkbox = deckItem.querySelector(`#export-deck-${deck.id}`);
                checkbox.addEventListener('change', function() {
                    const deckId = parseInt(this.value);
                    if (this.checked) {
                        if (!selectedExportDeckIds.includes(deckId)) {
                            selectedExportDeckIds.push(deckId);
                        }
                    } else {
                        selectedExportDeckIds = selectedExportDeckIds.filter(id => id !== deckId);
                    }
                });
            });
        }

        // Function to close export modal
        function closeExportModal() {
            exportModal.classList.add('hidden');
            document.removeEventListener('click', handleExportModalOutsideClick);
        }

        // Function to handle import file
        function handleImportFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = JSON.parse(event.target.result);

                    // Store data temporarily
                    importDataCache = data;

                    // Open import preview modal
                    openImportPreviewModal(data);
                } catch (error) {
                    showNotification('匯入失敗：無效的 JSON 格式');
                    console.error('Import error:', error);
                }

                // Reset the file input
                e.target.value = '';
            };
            reader.readAsText(file);
        }

        // Function to open import preview modal
        function openImportPreviewModal(data) {
            // Reset selected decks
            selectedImportDeckIds = [];

            // Check data format
            if (!data.decksData) {
                showNotification('匯入失敗：無效的數據格式');
                return;
            }

            // Load import deck list
            loadImportPreviewList(data);

            // Show modal
            importPreviewModal.classList.remove('hidden');

            // Add click outside to close functionality
            document.addEventListener('click', handleImportModalOutsideClick);
        }

        // Function to load import preview list
        function loadImportPreviewList(data) {
            importDecksList.innerHTML = '';

            if (!data.decksData || data.decksData.length === 0) {
                importDecksList.innerHTML = '<div class="text-center py-4 text-gray-500 dark:text-gray-400">檔案中沒有卡組。</div>';
                return;
            }

            // By default, select all decks
            selectedImportDeckIds = data.decksData.map(deck => deck.id.toString());

            data.decksData.forEach(deck => {
                // Check if this deck conflicts with existing decks
                const conflict = decksData.some(existingDeck => existingDeck.name === deck.name);

                // Get cards related to this deck
                const deckCards = data.cardsData.filter(card => deck.cardIds.includes(card.id));

                const deckItem = document.createElement('div');
                deckItem.className = `flex items-start p-2 bg-gray-100 dark:bg-gray-700 rounded ${conflict ? 'border-l-4 border-yellow-500' : ''}`;

                deckItem.innerHTML = `
                    <input type="checkbox" id="import-deck-${deck.id}" value="${deck.id}" class="mr-2 mt-1" checked>
                    <div class="flex-1">
                        <label for="import-deck-${deck.id}" class="flex justify-between items-center cursor-pointer">
                            <span class="font-medium">${deck.name}</span>
                            <span class="text-xs text-gray-500 dark:text-gray-400">${deckCards.length} 張字卡</span>
                        </label>
                        ${deck.description ? `<p class="text-xs text-gray-600 dark:text-gray-400 mt-1">${deck.description}</p>` : ''}
                        ${conflict ? `<p class="text-xs text-yellow-600 dark:text-yellow-400 mt-1">注意：與現有卡組名稱衝突</p>` : ''}
                    </div>
                `;

                importDecksList.appendChild(deckItem);

                // Add change event for checkbox
                const checkbox = deckItem.querySelector(`#import-deck-${deck.id}`);
                checkbox.addEventListener('change', function() {
                    const deckId = this.value;
                    if (this.checked) {
                        if (!selectedImportDeckIds.includes(deckId)) {
                            selectedImportDeckIds.push(deckId);
                        }
                    } else {
                        selectedImportDeckIds = selectedImportDeckIds.filter(id => id !== deckId);
                    }
                });
            });
        }

        // Function to close import preview modal
        function closeImportPreviewModal() {
            importPreviewModal.classList.add('hidden');
            document.removeEventListener('click', handleImportModalOutsideClick);

            // Clear temp import data
            importDataCache = null;
            selectedImportDeckIds = [];
        }

        // Function to process import based on selection
        function processImport() {
            if (!importDataCache || selectedImportDeckIds.length === 0) {
                closeImportPreviewModal();
                return;
            }

            // Get conflict resolution strategy
            const conflictResolution = document.querySelector('input[name="conflictResolution"]:checked').value;

            // Filter selected decks from import data
            const selectedDecks = importDataCache.decksData.filter(deck =>
                selectedImportDeckIds.includes(deck.id.toString())
            );

            // Process each selected deck
            selectedDecks.forEach(importDeck => {
                // Check for name conflict
                const conflictDeckIndex = decksData.findIndex(deck => deck.name === importDeck.name);

                if (conflictDeckIndex !== -1) {
                    // Handle conflict according to selected strategy
                    switch (conflictResolution) {
                        case 'overwrite':
                            // Keep the deck ID but update all other properties
                            const existingDeckId = decksData[conflictDeckIndex].id;
                            importDeck.id = existingDeckId; // preserve original ID
                            decksData[conflictDeckIndex] = importDeck;
                            break;

                        case 'rename':
                            // Add a number suffix to make the name unique
                            let counter = 1;
                            let newName = `${importDeck.name} (${counter})`;

                            while (decksData.some(deck => deck.name === newName)) {
                                counter++;
                                newName = `${importDeck.name} (${counter})`;
                            }

                            importDeck.name = newName;
                            decksData.push(importDeck);
                            break;

                        case 'merge':
                            // Merge cards from import deck to existing deck
                            const existingDeck = decksData[conflictDeckIndex];

                            // Add cards from import deck
                            importDeck.cardIds.forEach(cardId => {
                                if (!existingDeck.cardIds.includes(cardId)) {
                                    existingDeck.cardIds.push(cardId);
                                }
                            });
                            break;

                        case 'skip':
                            // Skip this deck entirely
                            return;
                    }
                } else {
                    // No conflict, simply add the deck
                    decksData.push(importDeck);
                }

                // Import cards related to this deck
                if (importDataCache.cardsData) {
                    const deckCards = importDataCache.cardsData.filter(card =>
                        importDeck.cardIds.includes(card.id)
                    );

                    deckCards.forEach(importCard => {
                        // Check if card already exists (by ID)
                        const existingCardIndex = cardsData.findIndex(card => card.id === importCard.id);

                        if (existingCardIndex !== -1) {
                            // Update existing card if conflict resolution is 'overwrite' or 'merge'
                            if (conflictResolution === 'overwrite' || conflictResolution === 'merge') {
                                cardsData[existingCardIndex] = importCard;
                            }
                        } else {
                            // Add new card
                            cardsData.push(importCard);
                        }
                    });
                }
            });

            // 關閉模態框並刷新UI
            closeImportPreviewModal();

            // 無論當前在哪個頁面，都預先更新複習頁面的卡組列表
            loadDeckList();

            // 根據當前頁面刷新UI其他部分
            if (!reviewSection.classList.contains('hidden')) {
                // 如果當前在複習頁面，確保卡組列表可見
                showReviewStage('deckSelection');
            } else if (!manageDeckSection.classList.contains('hidden')) {
                loadAllDecks();
            } else if (!manageCardSection.classList.contains('hidden')) {
                loadDeckFilterOptions();
                loadAllCards();
            }

            showNotification('數據匯入成功！');

            // 清除緩存的導入數據
            importDataCache = null;
        }

        // Function to open new deck modal
        function openNewDeckModal() {
            // Reset fields
            newDeckNameInput.value = '';
            newDeckDescriptionInput.value = '';

            // Show modal
            newDeckModal.classList.remove('hidden');

            // Focus on name input
            setTimeout(() => {
                newDeckNameInput.focus();
            }, 100);

            // Add click outside to close functionality
            document.addEventListener('click', handleNewDeckModalOutsideClick);
        }

        // Function to close new deck modal
        function closeNewDeckModal() {
            newDeckModal.classList.add('hidden');
            document.removeEventListener('click', handleNewDeckModalOutsideClick);
        }

        // Function to save new deck from modal
        // 修改saveNewDeck函數
        function saveNewDeck() {
            const name = newDeckNameInput.value.trim();
            const description = newDeckDescriptionInput.value.trim();

            if (name) {
                const newDeck = {
                    id: Date.now(),
                    name: name,
                    description: description || '',
                    cardIds: [],
                    createdAt: Date.now()
                };

                decksData.push(newDeck);

                // 更新部分：處理在建立字卡頁面建立卡組的情況
                if (!createCardSection.classList.contains('hidden')) {
                    // 當前在建立字卡頁面
                    selectedDeckIds = [newDeck.id]; // 只選擇新建立的卡組

                    // 隱藏警告提示
                    noDeckWarning.classList.add('hidden');

                    // 顯示字卡製作表單和卡組選擇區
                    deckSelectionForCard.classList.remove('hidden');
                    cardForm.classList.remove('hidden');

                    // 更新選定的卡組顯示
                    updateSelectedDecksDisplay();

                    // 初始化搜索功能
                    initSearchableDeckSelector();

                    // 聚焦到字卡正面輸入框，方便用戶直接開始輸入
                    setTimeout(() => {
                        if (frontQuill) {
                            frontQuill.focus();
                        }
                    }, 100);
                }

                closeNewDeckModal();
                showNotification('卡組建立成功');

                // 刷新相關部分
                loadDeckFilterOptions();
                loadDeckList();
                loadAllDecks();

                // 顯示存儲提醒
                showStorageReminder();
            } else {
                showNotification('請至少輸入卡組名稱');
            }
        }

        // Handle click outside the new deck modal to close it
        function handleNewDeckModalOutsideClick(event) {
            const modalContent = newDeckModal.querySelector('div');
            if (newDeckModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeNewDeckModal();
            }
        }

        // Handle click outside the export modal to close it
        function handleExportModalOutsideClick(event) {
            const modalContent = exportModal.querySelector('div');
            if (exportModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeExportModal();
            }
        }

        // Handle click outside the import modal to close it
        function handleImportModalOutsideClick(event) {
            const modalContent = importPreviewModal.querySelector('div');
            if (importPreviewModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeImportPreviewModal();
            }
        }

        // Update batch delete button visibility and count
        function updateBatchDeleteButton() {
            selectedCardCount.textContent = selectedCardIds.size;
            if (selectedCardIds.size > 0) {
                deleteBatchCardsBtn.classList.remove('hidden');
            } else {
                deleteBatchCardsBtn.classList.add('hidden');
            }
        }

        // Update batch delete decks button visibility and count
        function updateBatchDeleteDecksButton() {
            selectedDeckCount.textContent = selectedDeckIds2.size;
            if (selectedDeckIds2.size > 0) {
                deleteBatchDecksBtn.classList.remove('hidden');
            } else {
                deleteBatchDecksBtn.classList.add('hidden');
            }
        }

        // Delete selected cards
        function deleteSelectedCards() {
            if (selectedCardIds.size === 0) return;

            // Remove selected cards from cardsData
            cardsData = cardsData.filter(card => !selectedCardIds.has(card.id));

            // Remove selected cards from all decks
            decksData.forEach(deck => {
                deck.cardIds = deck.cardIds.filter(id => !selectedCardIds.has(id));
            });

            // Clear selection
            selectedCardIds.clear();
            updateBatchDeleteButton();

            // Update UI
            loadAllCards();
            showNotification(`已刪除所選字卡`);

            // Show storage reminder as data has changed
            showStorageReminder();
        }

        // Delete selected decks
        function deleteSelectedDecks() {
            if (selectedDeckIds2.size === 0) return;

            customConfirm(`確定要刪除選中的 ${selectedDeckIds2.size} 個卡組嗎？`, '刪除卡組', function(confirmed) {
                if (confirmed) {
                    // Get all card IDs from selected decks
                    const cardsToDelete = new Set();
                    selectedDeckIds2.forEach(deckId => {
                        const deck = decksData.find(d => d.id === deckId);
                        if (deck) {
                            // Check if cards are used in other decks
                            deck.cardIds.forEach(cardId => {
                                // Only mark for deletion if not in other unselected decks
                                const isInOtherDecks = decksData.some(d =>
                                    !selectedDeckIds2.has(d.id) && d.cardIds.includes(cardId)
                                );
                                if (!isInOtherDecks) {
                                    cardsToDelete.add(cardId);
                                }
                            });
                        }
                    });

                    // Remove selected decks
                    decksData = decksData.filter(deck => !selectedDeckIds2.has(deck.id));

                    // Remove cards that were only in the deleted decks
                    cardsData = cardsData.filter(card => !cardsToDelete.has(card.id));

                    // Clear selection
                    selectedDeckIds2.clear();
                    updateBatchDeleteDecksButton();

                    // Update UI
                    loadAllDecks();
                    loadDeckList();
                    showNotification('已刪除選中的卡組');

                    // Show storage reminder
                    showStorageReminder();
                }
            });
        }

        // Function to export data
        function exportData() {
            if (selectedExportDeckIds.length === 0) {
                showNotification('請至少選擇一個卡組進行匯出');
                return;
            }

            const filename = exportFilenameInput.value.trim() || 'flashcards_data';

            // Filter selected decks
            const selectedDecks = decksData.filter(deck => selectedExportDeckIds.includes(deck.id));

            // Get all card IDs from selected decks
            const allCardIds = new Set();
            selectedDecks.forEach(deck => {
                deck.cardIds.forEach(cardId => allCardIds.add(cardId));
            });

            // Filter cards related to selected decks
            const selectedCards = cardsData.filter(card => allCardIds.has(card.id));

            // Create the data object to export
            const exportData = {
                version: "1.1",
                type: selectedDecks.length === 1 ? "single_deck" : "multi_deck",
                exportDate: new Date().toISOString(),
                decksData: selectedDecks,
                cardsData: selectedCards
            };

            // Add deck count to filename if multiple decks
            let adjustedFilename = filename;
            if (selectedDecks.length > 1) {
                adjustedFilename = `${filename}_${selectedDecks.length}decks`;
            } else if (selectedDecks.length === 1) {
                adjustedFilename = `${filename}_${selectedDecks[0].name.replace(/[^\w\s]/gi, '_')}`;
            }

            // Convert to JSON string
            const jsonString = JSON.stringify(exportData, null, 2);

            // Create a blob and download link
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            // Create a temporary link element and trigger download
            const a = document.createElement('a');
            a.href = url;
            a.download = `${adjustedFilename}.json`;
            document.body.appendChild(a);
            a.click();

            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);

            closeExportModal();
            showNotification(`已匯出 ${selectedDecks.length} 個卡組`);
        }

        // Add sort change event listeners
        deckSortSelect.addEventListener('change', (e) => {
            deckSortPreference = e.target.value;
            loadDeckList();
        });

        manageDeckSortSelect.addEventListener('change', (e) => {
            manageDeckSortPreference = e.target.value;
            loadAllDecks();
        });

        // Add search input event listeners
        deckSearchInput.addEventListener('input', () => {
            loadDeckList();
        });

        cardSearchInput.addEventListener('input', () => {
            loadAllCards();
        });

        manageDeckSearchInput.addEventListener('input', () => {
            loadAllDecks();
        });

        // Navigation handlers
        reviewBtn.addEventListener('click', () => showSection('review'));
        createCardBtn.addEventListener('click', () => showSection('createCard'));
        manageCardBtn.addEventListener('click', () => showSection('manageCard'));
        manageDeckBtn.addEventListener('click', () => showSection('manageDeck'));

        // Flip sides button handler
        flipSidesBtn.addEventListener('click', () => {
            sidesFlipped = !sidesFlipped;
            showCurrentCard();
        });

        // Image upload button handlers
        frontImageBtn.addEventListener('click', () => {
            cardFrontImageInput.click();
        });

        backImageBtn.addEventListener('click', () => {
            cardBackImageInput.click();
        });

        // Remove front image
        removeFrontImage.addEventListener('click', () => {
            frontImageData = null;
            cardFrontImageInput.value = '';
            frontImageName.textContent = '';
            frontImagePreview.classList.add('hidden');
        });

        // Remove back image
        removeBackImage.addEventListener('click', () => {
            backImageData = null;
            cardBackImageInput.value = '';
            backImageName.textContent = '';
            backImagePreview.classList.add('hidden');
        });

        // Edit card image handlers
        editFrontImageBtn.addEventListener('click', () => {
            editCardFrontImage.click();
        });

        editBackImageBtn.addEventListener('click', () => {
            editCardBackImage.click();
        });

        // Remove edit front image
        removeEditFrontImage.addEventListener('click', () => {
            editFrontImageData = null;
            editCardFrontImage.value = '';
            editFrontImagePreview.classList.add('hidden');
        });

        // Remove edit back image
        removeEditBackImage.addEventListener('click', () => {
            editBackImageData = null;
            editCardBackImage.value = '';
            editBackImagePreview.classList.add('hidden');
        });

        // Toggle deck dropdown for create card
        // 讓整個選擇區都可以點擊
        const selectedDecksBar = document.querySelector('.multiselect-dropdown .flex.items-center.border');
        selectedDecksBar.addEventListener('click', (e) => {
            // 阻止事件冒泡，防止觸發外部點擊事件
            e.stopPropagation();

            deckOptions.classList.toggle('hidden');

            // 加載卡組選項
            if (!deckOptions.classList.contains('hidden')) {
                loadDeckOptionsForCard();
            }
        });

        // 添加點擊其他地方時關閉下拉菜單
        document.addEventListener('click', (e) => {
            // 檢查點擊是否在下拉菜單外
            if (!deckOptions.contains(e.target) && !selectedDecksBar.contains(e.target)) {
                deckOptions.classList.add('hidden');
            }
        });

        // 防止點擊選項時關閉菜單
        deckOptions.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // 为卡組选择添加搜索功能
        function initSearchableDeckSelector() {
            // 获取相关元素
            const selectedDecksContainer = document.getElementById('selectedDecks');
            const selectedDecksPlaceholder = document.getElementById('selectedDecksPlaceholder');
            const deckDropdownToggle = document.getElementById('toggleDeckDropdown');
            const deckOptions = document.getElementById('deckOptions');

            // 创建搜索输入框
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.id = 'deckSearchForCard';
            searchInput.placeholder = '搜尋卡組...';
            searchInput.className = 'flex-1 bg-transparent border-none focus:outline-none focus:ring-0 text-base';

            // 替换占位符为搜索框
            if (selectedDecksPlaceholder) {
                selectedDecksPlaceholder.replaceWith(searchInput);
            } else {
                // 如果占位符不存在，就添加到选择区容器开头
                selectedDecksContainer.prepend(searchInput);
            }

            // 点击整个选择区域时打开下拉菜单
            const selectArea = document.querySelector('.multiselect-dropdown .flex.items-center.border');
            selectArea.addEventListener('click', function(e) {
                // 阻止事件冒泡
                e.stopPropagation();

                // 显示选项菜单
                deckOptions.classList.remove('hidden');

                // 加载选项
                loadDeckOptionsForCard(searchInput.value.trim());

                // 聚焦搜索框
                searchInput.focus();
            });

            // 点击其他区域关闭下拉菜单
            document.addEventListener('click', function(e) {
                if (!deckOptions.contains(e.target) && !selectArea.contains(e.target)) {
                    deckOptions.classList.add('hidden');
                }
            });

            // 设置搜索框事件 - 自動彈出菜單的重點部分
            searchInput.addEventListener('focus', function(e) {
                // 獲得焦點時自動彈出菜單
                e.stopPropagation();
                deckOptions.classList.remove('hidden');
                loadDeckOptionsForCard(this.value.trim());
            });

            searchInput.addEventListener('input', function(e) {
                e.stopPropagation();
                // 確保菜單是開啟的
                deckOptions.classList.remove('hidden');
                loadDeckOptionsForCard(this.value.trim());
            });

            searchInput.addEventListener('click', function(e) {
                // 阻止事件冒泡，防止触发选择区域的点击事件
                e.stopPropagation();
                // 確保點擊時也自動彈出菜單
                deckOptions.classList.remove('hidden');
                loadDeckOptionsForCard(this.value.trim());
            });

            searchInput.addEventListener('keydown', function(e) {
                // ESC键关闭下拉菜单
                if (e.key === 'Escape') {
                    deckOptions.classList.add('hidden');
                }
            });

            // 阻止下拉选项区域的点击事件冒泡
            deckOptions.addEventListener('click', function(e) {
                e.stopPropagation();
            });

            console.log("已初始化可搜索的卡組選擇器");
        }

        // Show section handler
        function showSection(section) {
            // Reset active tab styling
            reviewBtn.classList.remove('border-primary');
            createCardBtn.classList.remove('border-primary');
            manageCardBtn.classList.remove('border-primary');
            manageDeckBtn.classList.remove('border-primary');

            reviewBtn.classList.add('border-transparent');
            createCardBtn.classList.add('border-transparent');
            manageCardBtn.classList.add('border-transparent');
            manageDeckBtn.classList.add('border-transparent');

            // Hide all sections
            reviewSection.classList.add('hidden');
            createCardSection.classList.add('hidden');
            manageCardSection.classList.add('hidden');
            manageDeckSection.classList.add('hidden');

            // Clear all timers when switching sections
            clearAllDrillTimers();

            if (section === 'review') {
                reviewBtn.classList.remove('border-transparent');
                reviewBtn.classList.add('border-primary');
                reviewSection.classList.remove('hidden');
                showReviewStage('deckSelection');
                loadDeckList();
            } else if (section === 'createCard') {
                createCardBtn.classList.remove('border-transparent');
                createCardBtn.classList.add('border-primary');
                createCardSection.classList.remove('hidden');

                // Check if there are decks available
                if (decksData.length === 0) {
                    noDeckWarning.classList.remove('hidden');
                    deckSelectionForCard.classList.add('hidden');
                    cardForm.classList.add('hidden');

                    // 初始化警告中的連結
                    initCreateCardWarningLink();
                } else {
                    noDeckWarning.classList.add('hidden');
                    deckSelectionForCard.classList.remove('hidden');
                    cardForm.classList.remove('hidden');

                    // Update selected decks display (no reset)
                    updateSelectedDecksDisplay();

                    initSearchableDeckSelector();
                }
            } else if (section === 'manageCard') {
                manageCardBtn.classList.remove('border-transparent');
                manageCardBtn.classList.add('border-primary');
                manageCardSection.classList.remove('hidden');
                loadDeckFilterOptions();
                loadAllCards();

                // Reset batch selection
                selectedCardIds.clear();
                updateBatchDeleteButton();
            } else if (section === 'manageDeck') {
                manageDeckBtn.classList.remove('border-transparent');
                manageDeckBtn.classList.add('border-primary');
                manageDeckSection.classList.remove('hidden');
                loadAllDecks();

                // Reset batch selection for decks
                selectedDeckIds2.clear();
                updateBatchDeleteDecksButton();
            }
        }

        // Load deck options for card creation
        function loadDeckOptionsForCard(keyword = '') {
            deckOptions.innerHTML = '';

            // 過濾卡組
            let filteredDecks = decksData;
            if (keyword) {
                keyword = keyword.toLowerCase();
                filteredDecks = decksData.filter(deck =>
                    deck.name.toLowerCase().includes(keyword) ||
                    (deck.description && deck.description.toLowerCase().includes(keyword))
                );
            }

            // 按名稱排序
            filteredDecks.sort((a, b) => a.name.localeCompare(b.name));

            if (filteredDecks.length === 0) {
                const noResultItem = document.createElement('div');
                noResultItem.className = 'p-2 text-gray-500 dark:text-gray-400 text-center';
                noResultItem.textContent = '沒有匹配的卡組';
                deckOptions.appendChild(noResultItem);
                return;
            }

            filteredDecks.forEach(deck => {
                const option = document.createElement('div');
                option.className = `multiselect-option p-2 ${selectedDeckIds.includes(deck.id) ? 'selected' : ''}`;
                option.setAttribute('data-deck-id', deck.id);

                // 顯示卡組名稱和數量
                option.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span>${deck.name}</span>
                        <span class="text-xs text-gray-500 dark:text-gray-400">${deck.cardIds.length} 張</span>
                    </div>
                    ${deck.description ? `<div class="text-xs text-gray-500 dark:text-gray-500">${deck.description}</div>` : ''}
                `;

                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const deckId = parseInt(option.getAttribute('data-deck-id'));
                    toggleDeckSelection(deckId);
                    option.classList.toggle('selected');
                    updateSelectedDecksDisplay(); // 使用您原有的更新顯示函數
                });

                deckOptions.appendChild(option);
            });
        }

        // Toggle deck selection for card creation
        function toggleDeckSelection(deckId) {
            const index = selectedDeckIds.indexOf(deckId);
            if (index === -1) {
                selectedDeckIds.push(deckId);
            } else {
                selectedDeckIds.splice(index, 1);
            }

            updateSelectedDecksDisplay();
        }

        // Update selected decks display
        function updateSelectedDecksDisplay() {
            if (selectedDeckIds.length === 0) {
                // 创建搜索输入框
                const searchInput = document.createElement('input');
                searchInput.type = 'text';
                searchInput.id = 'deckSearchForCard';
                searchInput.placeholder = '搜尋卡組...';
                searchInput.className = 'flex-1 bg-transparent border-none focus:outline-none focus:ring-0 text-base';

                selectedDecks.innerHTML = '';
                selectedDecks.appendChild(searchInput);
                return;
            }

            selectedDecks.innerHTML = '';



            selectedDeckIds.forEach(deckId => {
                const deck = decksData.find(d => d.id === deckId);
                if (!deck) return;

                const tag = document.createElement('span');
                tag.className = 'bg-primary bg-opacity-10 text-primary text-sm px-2 py-1 rounded-full flex items-center';
                tag.innerHTML = `
                    ${deck.name}
                    <button type="button" class="ml-1 focus:outline-none" data-deck-id="${deckId}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;

                // Add removal button event
                tag.querySelector('button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const deckId = parseInt(e.currentTarget.getAttribute('data-deck-id'));
                    toggleDeckSelection(deckId);

                    // Also update the dropdown options
                    const option = deckOptions.querySelector(`[data-deck-id="${deckId}"]`);
                    if (option) {
                        option.classList.remove('selected');
                    }
                });

                selectedDecks.appendChild(tag);
            });

            // 重新設置搜索框的事件處理
            const searchInputAfter = document.getElementById('deckSearchForCard');
            if (searchInputAfter) {
                searchInputAfter.addEventListener('focus', function(e) {
                    e.stopPropagation();
                    deckOptions.classList.remove('hidden');
                    loadDeckOptionsForCard(this.value.trim());
                });

                searchInputAfter.addEventListener('input', function(e) {
                    e.stopPropagation();
                    deckOptions.classList.remove('hidden');
                    loadDeckOptionsForCard(this.value.trim());
                });

                searchInputAfter.addEventListener('click', function(e) {
                    e.stopPropagation();
                    deckOptions.classList.remove('hidden');
                    loadDeckOptionsForCard(this.value.trim());
                });

                searchInputAfter.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape') {
                        deckOptions.classList.add('hidden');
                    }
                });
            }
        }

        // Load deck filter options
        function loadDeckFilterOptions() {
            // Clear all options except "All"
            while (deckFilterSelect.options.length > 1) {
                deckFilterSelect.remove(1);
            }

            // Add deck options
            decksData.forEach(deck => {
                const option = document.createElement('option');
                option.value = deck.id;
                option.textContent = deck.name;
                deckFilterSelect.appendChild(option);
            });
        }

        // Show different review stages
        // 在showReviewStage函數中添加視口適應代碼
        function showReviewStage(stage) {
            deckSelection.classList.add('hidden');
            modeSelection.classList.add('hidden');
            reviewInterface.classList.add('hidden');
            reviewCompleteMessage.classList.add('hidden');

            if (stage === 'deckSelection') {
                deckSelection.classList.remove('hidden');

                // 重設視窗滾動位置
                window.scrollTo(0, 0);

                // 將deckList容器設為自適應高度
                deckList.style.maxHeight = 'calc(100vh - 280px)';
                deckList.style.overflowY = 'auto';

            } else if (stage === 'modeSelection') {
                modeSelection.classList.remove('hidden');
                window.scrollTo(0, 0);

            } else if (stage === 'reviewInterface') {
                reviewInterface.classList.remove('hidden');
                window.scrollTo(0, 0);

                // 設置複習界面為彈性布局，自適應螢幕高度
                reviewInterface.classList.add('flex', 'flex-col', 'h-[calc(100vh-170px)]');

                // 調整卡片容器高度
                const availableHeight = window.innerHeight - 220; // 扣除頁頭和其他元素高度
                cardContainer.style.height = `${Math.max(300, availableHeight * 0.6)}px`;

                // 確保評分按鈕在視圖內
                const buttonsContainer = document.getElementById('ratingButtons').parentElement;
                buttonsContainer.classList.add('mt-auto', 'pb-4');

            } else if (stage === 'reviewComplete') {
                reviewCompleteMessage.classList.remove('hidden');
                window.scrollTo(0, 0);
            }
                // 調整表單布局和高度
                cardForm.classList.add('flex', 'flex-col');

                // 調整textarea高度，使其更自適應
                const textareaHeight = window.innerHeight < 700 ? '60px' : '100px';
                document.querySelectorAll('#cardForm textarea').forEach(textarea => {
                    textarea.style.height = textareaHeight;
                });

                // 使預覽圖片更緊湊
                const previewHeight = window.innerHeight < 700 ? '80px' : '150px';
                document.querySelectorAll('#frontPreviewImg, #backPreviewImg').forEach(img => {
                    img.style.maxHeight = previewHeight;
                });

                // 如果是窄屏設備，進一步優化布局
                if (window.innerWidth < 640) {
                    document.querySelectorAll('.input-group').forEach(group => {
                        group.classList.add('flex-col');
                    });
                    document.querySelectorAll('.input-group button').forEach(button => {
                        button.classList.add('mt-2', 'w-full');
                    });
                }

        }

        // Sort decks based on preference
        function sortDecks(decks, preference) {
            const sortedDecks = [...decks];

            switch (preference) {
                case 'name':
                    sortedDecks.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'cards':
                    sortedDecks.sort((a, b) => b.cardIds.length - a.cardIds.length);
                    break;
                case 'date-new':
                    sortedDecks.sort((a, b) => b.createdAt - a.createdAt);
                    break;
                case 'date-old':
                    sortedDecks.sort((a, b) => a.createdAt - b.createdAt);
                    break;
                default:
                    sortedDecks.sort((a, b) => a.name.localeCompare(b.name));
            }

            return sortedDecks;
        }

        // Filter decks by search text
        function filterDecksBySearch(decks, searchText) {
            if (!searchText) return decks;

            const lowerSearchText = searchText.toLowerCase();
            return decks.filter(deck =>
                deck.name.toLowerCase().includes(lowerSearchText) ||
                (deck.description && deck.description.toLowerCase().includes(lowerSearchText))
            );
        }

        // Load deck list for selection
        function loadDeckList() {
            deckList.innerHTML = '';

            if (decksData.length === 0) {
                deckList.innerHTML = `
                    <div class="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">
                        沒有可用的卡組。
                        <a href="#" id="createFirstDeckLink" class="text-primary hover:underline">建立第一個卡組</a>
                    </div>
                `;
                document.getElementById('createFirstDeckLink').addEventListener('click', (e) => {
                    e.preventDefault();
                    openNewDeckModal();
                });
                return;
            }

            // Apply search filter
            const searchText = deckSearchInput.value.trim();
            let filteredDecks = filterDecksBySearch(decksData, searchText);

            // Apply sorting
            const sortedDecks = sortDecks(filteredDecks, deckSortPreference);

            if (sortedDecks.length === 0) {
                deckList.innerHTML = '<div class="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">沒有符合搜尋條件的卡組</div>';
                return;
            }

            sortedDecks.forEach(deck => {
                const cardCount = deck.cardIds.length;
                const deckElement = document.createElement('div');
                deckElement.className = 'bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-300 dark:border-gray-700 cursor-pointer hover:border-primary dark:hover:border-primary';
                deckElement.setAttribute('data-deck-id', deck.id);

                deckElement.innerHTML = `
                    <h3 class="font-medium text-lg mb-1">${deck.name}</h3>
                    <p class="text-gray-600 dark:text-gray-400 text-sm mb-2">${deck.description || '無描述'}</p>
                    <p class="text-xs text-gray-500 dark:text-gray-500">包含 ${cardCount} 張字卡</p>
                `;

                deckElement.addEventListener('click', () => selectDeck(deck.id));
                deckList.appendChild(deckElement);
            });
        }

        // Select a deck for review
        function selectDeck(deckId) {
            const deck = decksData.find(d => d.id === deckId);
            if (!deck) return;

            // 檢查卡組是否為空
            if (deck.cardIds.length === 0) {
                // 自動轉跳到建立字卡頁面
                showSection('createCard');

                // 選中該卡組
                selectedDeckIds = [deckId];

                // 更新選中卡組的顯示
                updateSelectedDecksDisplay();

                // 顯示一個提示，告知用戶已自動轉跳
                showNotification(`已選擇"${deck.name}"卡組。請添加字卡。`);
                return;
            }

            currentDeck = deck;
            showReviewStage('modeSelection');

            // Add mode selection event listeners
            document.querySelectorAll('[data-mode]').forEach(modeElement => {
                modeElement.addEventListener('click', () => {
                    const mode = modeElement.getAttribute('data-mode');
                    selectMode(mode);
                });
            });
        }

        // Select review mode
        function selectMode(mode) {
            currentMode = mode;

            // Reset sides flipped status
            sidesFlipped = false;

            initializeReview();
        }

        // Shuffle an array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Initialize review session
        function initializeReview() {
            // Reset drill mode counters
            drillReviewedCount = 0;
            reviewCycleCount = 0;

            // Load cards for current deck
            cardsToReview = [];

            // Get all cards from the deck
            const deckCards = [];
            currentDeck.cardIds.forEach(cardId => {
                const card = cardsData.find(c => c.id === cardId);
                if (card) {
                    deckCards.push({...card});
                }
            });

            // Shuffle cards for this review session
            cardsToReview = shuffleArray(deckCards);

            // Update UI
            currentDeckName.textContent = currentDeck.name;
            currentModeName.textContent = currentMode === 'daily' ? '日常模式' : '操練模式';

            // Start review
            currentCardIndex = 0;
            showReviewStage('reviewInterface');

            if (cardsToReview.length > 0) {
                showCurrentCard();
            } else {
                showReviewStage('reviewComplete');
            }

            // Add exit review button handler
            exitReviewBtn.addEventListener('click', () => {
                clearAllDrillTimers();
                showReviewStage('deckSelection');
            });

            // Add restart and choose deck button handlers
            restartDeckBtn.addEventListener('click', () => initializeReview());
            backToDeckSelectionBtn.addEventListener('click', () => showReviewStage('deckSelection'));
        }

        // 創建一個帶有縮放和拖動功能的圖片容器
        function createZoomableImage(imageUrl) {

          // 創建容器
          const container = document.createElement('div');
          container.className = "relative flex justify-center items-center w-full overflow-hidden mt-4"; // 增加頂部間距

            // 創建圖片包裝器用於拖動
            const imageWrapper = document.createElement('div');
            imageWrapper.className = "transform-gpu";

            // 創建圖片
            const img = document.createElement('img');
            img.src = imageUrl;
            img.className = "max-h-70 md:max-h-[28rem] max-w-full object-contain rounded cursor-move";

            // 保存變換狀態
            const transform = {
                scale: 1,
                translateX: 0,
                translateY: 0
            };

            // 拖動狀態
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;

            // 更新圖片變換
            function updateTransform() {
                imageWrapper.style.transform = `translate(${transform.translateX}px, ${transform.translateY}px) scale(${transform.scale})`;
            }

            // 滑鼠拖動處理
            imageWrapper.addEventListener('mousedown', (e) => {
                if (transform.scale <= 1) return; // 只有放大時才能拖動

                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;

                // 變更游標樣式
                imageWrapper.style.cursor = 'grabbing';
                e.preventDefault(); // 防止選中文字
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                // 計算移動距離
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;

                // 更新位置
                transform.translateX += deltaX;
                transform.translateY += deltaY;

                // 更新變換
                updateTransform();

                // 更新記錄的位置
                lastX = e.clientX;
                lastY = e.clientY;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    imageWrapper.style.cursor = 'move';
                }
            });

            // 觸控拖動處理
            imageWrapper.addEventListener('touchstart', (e) => {
                if (transform.scale <= 1) return; // 只有放大時才能拖動
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                }
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                if (e.touches.length === 1) {
                    // 計算移動距離
                    const deltaX = e.touches[0].clientX - lastX;
                    const deltaY = e.touches[0].clientY - lastY;

                    // 更新位置
                    transform.translateX += deltaX;
                    transform.translateY += deltaY;

                    // 更新變換
                    updateTransform();

                    // 更新記錄的位置
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                }
            }, { passive: false });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });

            // 創建縮放控制按鈕
            const zoomControls = document.createElement('div');
            zoomControls.className = "absolute top-2 right-2 flex space-x-1 bg-black bg-opacity-50 rounded p-1 z-10";

            // 放大按鈕
            const zoomInBtn = document.createElement('button');
            zoomInBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg>';
            zoomInBtn.className = "focus:outline-none";
            zoomInBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止點擊事件冒泡觸發卡片翻轉

                // 放大
                transform.scale = Math.min(transform.scale + 0.2, 3);

                // 更新變換
                updateTransform();
            });

            // 縮小按鈕
            const zoomOutBtn = document.createElement('button');
            zoomOutBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18 12H6" /></svg>';
            zoomOutBtn.className = "focus:outline-none";
            zoomOutBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止點擊事件冒泡觸發卡片翻轉

                // 縮小
                transform.scale = Math.max(transform.scale - 0.2, 0.5);

                // 如果縮小到原始大小以下，重設位置
                if (transform.scale <= 1) {
                    transform.translateX = 0;
                    transform.translateY = 0;
                }

                // 更新變換
                updateTransform();
            });

            // 重置按鈕
            const resetBtn = document.createElement('button');
            resetBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>';
            resetBtn.className = "focus:outline-none";
            resetBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止點擊事件冒泡觸發卡片翻轉

                // 重設變換
                transform.scale = 1;
                transform.translateX = 0;
                transform.translateY = 0;

                // 更新變換
                updateTransform();
            });

            // 添加滾輪縮放支持
            imageWrapper.addEventListener('wheel', function(e) {
                e.preventDefault();
                e.stopPropagation();

                // 計算以滑鼠位置為中心的縮放
                const rect = imageWrapper.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // 獲取滑鼠相對於圖片的比例位置
                const imgX = mouseX - transform.translateX;
                const imgY = mouseY - transform.translateY;

                // 計算滾輪方向的縮放因子
                const delta = e.deltaY < 0 ? 0.1 : -0.1;
                const oldScale = transform.scale;
                transform.scale = Math.min(Math.max(oldScale + delta, 0.5), 3);

                // 如果縮小到原始大小以下，重設位置
                if (transform.scale <= 1) {
                    transform.translateX = 0;
                    transform.translateY = 0;
                } else {
                    // 計算縮放後的偏移量，使滑鼠位置保持在同一點上
                    const scaleRatio = transform.scale / oldScale;
                    const newImgX = imgX * scaleRatio;
                    const newImgY = imgY * scaleRatio;

                    transform.translateX += imgX - newImgX;
                    transform.translateY += imgY - newImgY;
                }

                // 更新變換
                updateTransform();
            }, { passive: false });

            // 觸控捏合縮放
            let initialDistance = 0;
            let initialScale = 1;

            imageWrapper.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();

                    // 獲取兩個觸摸點
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];

                    // 計算初始距離
                    initialDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );

                    // 保存當前縮放
                    initialScale = transform.scale;

                    // 計算捏合中心點
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;

                    // 獲取中心點相對於圖片的位置
                    const rect = imageWrapper.getBoundingClientRect();
                    lastX = centerX;
                    lastY = centerY;
                }
            }, { passive: false });

            imageWrapper.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();

                    // 獲取兩個觸摸點
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];

                    // 計算當前距離
                    const currentDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );

                    // 計算縮放因子
                    const scaleFactor = currentDistance / initialDistance;
                    const oldScale = transform.scale;
                    transform.scale = Math.min(Math.max(initialScale * scaleFactor, 0.5), 3);

                    // 計算捏合中心點
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;

                    // 更新拖動位置（同時進行縮放和拖動）
                    if (oldScale > 1 || transform.scale > 1) {
                        const deltaX = centerX - lastX;
                        const deltaY = centerY - lastY;

                        transform.translateX += deltaX;
                        transform.translateY += deltaY;

                        lastX = centerX;
                        lastY = centerY;
                    }

                    // 如果縮小到原始大小以下，重設位置
                    if (transform.scale <= 1) {
                        transform.translateX = 0;
                        transform.translateY = 0;
                    }

                    // 更新變換
                    updateTransform();
                }
            }, { passive: false });

            // 組裝控制按鈕
            zoomControls.appendChild(zoomInBtn);
            zoomControls.appendChild(zoomOutBtn);
            zoomControls.appendChild(resetBtn);

            // 組裝容器
            imageWrapper.appendChild(img);
            container.appendChild(imageWrapper);
            container.appendChild(zoomControls);

            return container;
        }

        // 操練模式 - 根據難度重新插入字卡
        function reinsertCardBasedOnDifficulty(currentIndex, interval) {
            if (interval <= 0 || cardsToReview.length <= 1) return currentIndex;

            // 取出當前卡片
            const currentCard = cardsToReview[currentIndex];

            // 計算重新插入的位置
            let insertPosition = currentIndex + interval;

            // 如果位置超出數組範圍，則循環回到合理範圍內
            if (insertPosition >= cardsToReview.length) {
                insertPosition = insertPosition % cardsToReview.length;
            }

            // 從數組中移除當前卡片
            cardsToReview.splice(currentIndex, 1);

            // 在新位置插入卡片
            cardsToReview.splice(insertPosition, 0, currentCard);

            // 返回調整後的當前索引（因為移除了當前卡片，索引需要調整）
            return currentIndex > 0 ? currentIndex - 1 : 0;
        }

        // Restart drill mode
        function restartDrill() {
            // Start a new cycle with reshuffled cards
            reviewCycleCount++;

            // Get all cards from the deck
            const deckCards = [];
            currentDeck.cardIds.forEach(cardId => {
                const card = cardsData.find(c => c.id === cardId);
                if (card) {
                    // Reset drill-specific properties
                    const cardCopy = {...card};
                    delete cardCopy.drillInterval;
                    delete cardCopy.removed;
                    deckCards.push(cardCopy);
                }
            });

            // Shuffle cards for the new cycle
            cardsToReview = shuffleArray(deckCards);

            // Start review
            currentCardIndex = 0;
            showCurrentCard();
        }

        // Clear all drill mode timers
        function clearAllDrillTimers() {
            drillTimers.forEach(timerId => clearTimeout(timerId));
            drillTimers = [];
        }

        // Flip card handler
        flipBtn.addEventListener('click', () => {
            cardFront.classList.toggle('hidden');
            cardBack.classList.toggle('hidden');

            // If showing the answer, display rating buttons
            if (!cardBack.classList.contains('hidden')) {
                ratingButtons.classList.remove('hidden');
            } else {
                ratingButtons.classList.add('hidden');
            }
        });

        // Handle rating buttons
        document.querySelectorAll('.rating-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const rating = parseInt(e.target.dataset.rating);
                processCardRating(rating);
            });
        });

        // Process card rating based on mode
        function processCardRating(rating) {
            const card = cardsToReview[currentCardIndex];

            if (currentMode === 'daily') {
                // Daily mode - update using SM-2 algorithm
                updateCardSchedule(card, rating);
                moveToNextCard();
            } else if (currentMode === 'drill') {
                // 操練模式 - 根據難度設置間隔
                scheduleDrillCard(card, rating);

                // 增加已檢閱計數
                drillReviewedCount++;

                // 如果評級不是"簡單"(4)，則根據設置的間隔重新插入卡片
                if (rating < 4) {
                    // 根據難度重新插入卡片
                    currentCardIndex = reinsertCardBasedOnDifficulty(currentCardIndex, card.drillInterval);
                } else {
                    // 如果是"簡單"，則直接從列表中移除
                    cardsToReview.splice(currentCardIndex, 1);

                    // 調整索引（如果剛才移除的是最後一張卡片）
                    if (currentCardIndex >= cardsToReview.length && cardsToReview.length > 0) {
                        currentCardIndex = 0; // 回到第一張卡片
                    }
                }

                // 檢查是否所有卡片都已被移除
                if (cardsToReview.length === 0) {
                    // 顯示新一輪開始的提示
                    showNotification('所有卡片都已複習完畢，開始新一輪操練！');

                    // 重新載入所有卡片開始新的循環
                    restartDrill();
                } else {
                    // 顯示下一張卡片
                    currentCardIndex++;
                    if (currentCardIndex >= cardsToReview.length) {
                        currentCardIndex = 0;
                    }
                    showCurrentCard();
                }
            }
        }

        // Schedule card in drill mode
        function scheduleDrillCard(card, rating) {
            // Set interval based on difficulty rating
            switch(rating) {
                case 1: // Very difficult
                    card.drillInterval = 5; // Review after 5 cards
                    break;
                case 2: // Difficult
                    card.drillInterval = 10; // Review after 10 cards
                    break;
                case 3: // Good
                    card.drillInterval = 20; // Review after 20 cards
                    break;
                case 4: // Easy - remove card from drill session
                    card.removed = true;
                    break;
            }

            // Update card difficulty for future reference
            if (rating === 4) {
                card.difficulty = "easy";
            } else if (rating === 3) {
                card.difficulty = "medium";
            } else {
                card.difficulty = "hard";
            }

            // Update original card in cardsData with new difficulty
            const originalCard = cardsData.find(c => c.id === card.id);
            if (originalCard) {
                originalCard.difficulty = card.difficulty;
            }
        }

        // Update card schedule using SM-2 algorithm
        function updateCardSchedule(card, rating) {
            // Update card difficulty based on rating
            if (rating === 4) {
                card.difficulty = "easy";
            } else if (rating === 3) {
                card.difficulty = "medium";
            } else {
                card.difficulty = "hard";
            }

            // Update card using modified SM-2 algorithm
            if (rating < 3) {
                // If rating is 1 or 2 (difficult), reset repetitions
                card.repetitions = 0;
                card.interval = rating === 1 ? 0.25 : 0.5; // Very difficult: 0.25, Difficult: 0.5
            } else {
                // If rating is 3 or 4 (good/easy)
                card.repetitions = card.repetitions || 0;
                card.repetitions++;

                // Calculate new interval
                if (card.repetitions === 1) {
                    card.interval = 1; // 1 day
                } else if (card.repetitions === 2) {
                    card.interval = 3; // 3 days
                } else {
                    // Adjust interval based on ease factor
                    card.interval = card.interval || 1;
                    card.easeFactor = card.easeFactor || 2.0;
                    card.interval = Math.round(card.interval * card.easeFactor);
                }

                // Adjust ease factor based on performance
                if (rating === 4) { // Easy
                    card.easeFactor = (card.easeFactor || 2.0) + 0.15;
                } else if (rating === 3) { // Good
                    card.easeFactor = (card.easeFactor || 2.0) - 0.05;
                }

                // Ensure ease factor stays within reasonable bounds
                if (card.easeFactor < 1.3) card.easeFactor = 1.3;
            }

            // Calculate next review date (convert interval from days to milliseconds)
            card.nextReview = Date.now() + (card.interval * 24 * 60 * 60 * 1000);

            // Update original card in cardsData
            const cardIndex = cardsData.findIndex(c => c.id === card.id);
            if (cardIndex !== -1) {
                cardsData[cardIndex] = {...card};
            }
        }

        // Show current card to review
        function showCurrentCard() {
            // 重置卡片狀態
            cardFront.classList.remove('hidden');
            cardBack.classList.add('hidden');
            ratingButtons.classList.add('hidden');

            // 设置卡片布局样式
            cardFront.className = "flex flex-col w-full h-full justify-between"; // 使用justify-between分配空间
            cardBack.className = "flex flex-col w-full h-full justify-between hidden";

            // 确保文字区域有最小高度
            frontText.style.minHeight = "80px";
            backText.style.minHeight = "80px";

            // 增加文字区域的边距
            frontText.className = "mb-6 px-2";
            backText.className = "mb-6 px-2";

            // 獲取當前卡片
            const card = cardsToReview[currentCardIndex];
            if (!card) return;

            // 根據sidesFlipped決定顯示方式
            if (sidesFlipped) {
                // 正反面互換
                frontText.innerHTML = card.backText || '';
                backText.innerHTML = card.frontText || '';

                // 處理圖片顯示
                frontImage.innerHTML = '';
                backImage.innerHTML = '';

                if (card.backImage) {
                    const imgContainer = createZoomableImage(card.backImage);
                    frontImage.appendChild(imgContainer);
                }

                if (card.frontImage) {
                    const imgContainer = createZoomableImage(card.frontImage);
                    backImage.appendChild(imgContainer);
                }
            } else {
                // 正常顯示
                frontText.innerHTML = card.frontText || '';
                backText.innerHTML = card.backText || '';

                // 增加間距類
                frontText.className = "mb-6 px-2"; // 增加底部間距和左右內邊距
                backText.className = "mb-6 px-2";  // 增加底部間距和左右內邊距

                // 處理圖片顯示
                frontImage.innerHTML = '';
                backImage.innerHTML = '';

                if (card.frontImage) {
                    const imgContainer = createZoomableImage(card.frontImage);
                    frontImage.appendChild(imgContainer);
                }

                if (card.backImage) {
                    const imgContainer = createZoomableImage(card.backImage);
                    backImage.appendChild(imgContainer);
                }
            }
        }

        // Move to next card or finish review
        function moveToNextCard() {
            currentCardIndex++;

            if (currentCardIndex < cardsToReview.length) {
                showCurrentCard();
            } else {
                // 日常模式下顯示恭喜提示並自動轉跳
                if (currentMode === 'daily') {
                    // 顯示恭喜提示
                    showNotification('恭喜你！你已經複習完這個卡組的所有內容了！', 3000);

                    // 延遲一些時間後轉跳到選擇卡組頁面
                    setTimeout(() => {
                        showReviewStage('deckSelection');
                    }, 2000);
                } else {
                    // 其他模式仍然顯示完成界面
                    showReviewStage('reviewComplete');
                }
            }
        }

        // 儲存編輯器格式設定的變數
        let savedFrontFormats = {};
        let savedBackFormats = {};

        // 修改卡片建立處理函數，保存字體大小設定
        cardForm.addEventListener('submit', function(e) {
            e.preventDefault();

            const frontContent = frontQuill.root.innerHTML.trim();
            const backContent = backQuill.root.innerHTML.trim();

            if (selectedDeckIds.length === 0) {
                showNotification('請選擇至少一個卡組');
                return;
            }

            // 保存當前的格式設定（包括字體大小）
            // 為前面編輯器保存格式
            if (!frontQuill.getSelection()) {
                frontQuill.setSelection(0, 0);
            }
            savedFrontFormats = frontQuill.getFormat();

            // 為背面編輯器保存格式
            if (!backQuill.getSelection()) {
                backQuill.setSelection(0, 0);
            }
            savedBackFormats = backQuill.getFormat();

            if (frontContent !== '<p><br></p>' || frontImageData || backContent !== '<p><br></p>' || backImageData) {
                const newCardId = addNewCard(
                    frontContent !== '<p><br></p>' ? frontContent : '',
                    frontImageData,
                    backContent !== '<p><br></p>' ? backContent : '',
                    backImageData
                );

                // 添加卡片到選定的卡組
                selectedDeckIds.forEach(deckId => {
                    const deckIndex = decksData.findIndex(deck => deck.id === deckId);
                    if (deckIndex !== -1) {
                        decksData[deckIndex].cardIds.push(newCardId);
                    }
                });

                // 清空內容但保留格式設定（包括字體大小）
                clearEditorContentButKeepFormat(frontQuill, savedFrontFormats);
                clearEditorContentButKeepFormat(backQuill, savedBackFormats);

                // 重置圖片相關內容
                frontImageData = null;
                backImageData = null;
                frontImageName.textContent = '';
                backImageName.textContent = '';
                frontImagePreview.classList.add('hidden');
                backImagePreview.classList.add('hidden');

                // 聚焦到前面的編輯器以便繼續添加字卡
                setTimeout(() => {
                    frontQuill.focus();
                }, 0);

                showNotification('字卡建立成功');
                showStorageReminder();
            } else {
                showNotification('請至少添加一些內容到字卡');
            }
        });

        // 清空編輯器內容但保留格式的函數，包括字體大小
        function clearEditorContentButKeepFormat(quill, formats) {
            // 清空內容
            quill.setText('');

            // 恢復之前保存的格式
            if (formats) {
                // 選中新創建的空行
                quill.setSelection(0, 1);

                // 應用所有保存的格式
                Object.keys(formats).forEach(format => {
                    // 應用格式，包括對齊和字體大小
                    if (format === 'align' || format === 'size') {
                        quill.format(format, formats[format]);
                    }
                });

                // 清除選擇
                quill.setSelection(null);
            }
        }

        // 在切換頁面時重置所有格式
        function resetEditorFormats() {
            savedFrontFormats = {};
            savedBackFormats = {};

            if (frontQuill) {
                try {
                    // 檢查編輯器是否準備好且有內容
                    if (frontQuill.getLength() > 0) {
                        frontQuill.setSelection(0, frontQuill.getLength());
                        frontQuill.format('align', false);
                        frontQuill.format('size', false);
                        frontQuill.setSelection(null);
                    }
                } catch (e) {
                    console.log("重置前面編輯器格式失敗:", e);
                }
            }

            if (backQuill) {
                try {
                    if (backQuill.getLength() > 0) {
                        backQuill.setSelection(0, backQuill.getLength());
                        backQuill.format('align', false);
                        backQuill.format('size', false);
                        backQuill.setSelection(null);
                    }
                } catch (e) {
                    console.log("重置背面編輯器格式失敗:", e);
                }
            }
        }

        // 修改頁面切換函數，在切換時重置格式
        const originalShowSection = showSection;
        showSection = function(section) {
            // 在切換頁面前重置格式
            resetEditorFormats();

            // 調用原始函數
            originalShowSection(section);
        };

        // 添加監聽器以確保在切換頁面時重置格式
        document.querySelectorAll('#reviewBtn, #createCardBtn, #manageCardBtn, #manageDeckBtn').forEach(btn => {
            btn.addEventListener('click', resetEditorFormats);
        });

        // 確保字體大小在字卡顯示時正確呈現
        function fixFontSizeDisplay() {
          // 1. 首先確保CSS選擇器正確匹配字卡顯示區域
          const styleElement = document.createElement('style');
          styleElement.textContent = `
            /* 編輯器字體大小設定 */
            .ql-size-small, p.ql-size-small, .ql-size-small p {
              font-size: 0.75em !important;
            }

            .ql-size-large, p.ql-size-large, .ql-size-large p {
              font-size: 1.5em !important;
            }

            .ql-size-huge, p.ql-size-huge, .ql-size-huge p {
              font-size: 2em !important;
            }

            /* 確保字卡顯示區域的字體大小設定 */
            #cardFront .ql-size-small,
            #cardBack .ql-size-small,
            #frontText .ql-size-small,
            #backText .ql-size-small,
            #cardFront p.ql-size-small,
            #cardBack p.ql-size-small,
            #frontText p.ql-size-small,
            #backText p.ql-size-small {
              font-size: 0.75em !important;
            }

            #cardFront .ql-size-large,
            #cardBack .ql-size-large,
            #frontText .ql-size-large,
            #backText .ql-size-large,
            #cardFront p.ql-size-large,
            #cardBack p.ql-size-large,
            #frontText p.ql-size-large,
            #backText p.ql-size-large {
              font-size: 1.5em !important;
            }

            #cardFront .ql-size-huge,
            #cardBack .ql-size-huge,
            #frontText .ql-size-huge,
            #backText .ql-size-huge,
            #cardFront p.ql-size-huge,
            #cardBack p.ql-size-huge,
            #frontText p.ql-size-huge,
            #backText p.ql-size-huge {
              font-size: 2em !important;
            }
          `;
          document.head.appendChild(styleElement);

          // 2. 修改顯示卡片內容的函數，確保字體大小類被保留
          const originalShowCurrentCard = window.showCurrentCard;
          window.showCurrentCard = function() {
            originalShowCurrentCard.apply(this, arguments);

            // 確保字體大小類被正確應用
            const card = cardsToReview[currentCardIndex];
            if (!card) return;

            // 處理前面內容
            if (card.frontText) {
              // 檢查我們是否顯示前面還是背面
              const targetElement = sidesFlipped ? backText : frontText;
              fixFontSizeInHTML(targetElement);
            }

            // 處理背面內容
            if (card.backText) {
              // 檢查我們是否顯示前面還是背面
              const targetElement = sidesFlipped ? frontText : backText;
              fixFontSizeInHTML(targetElement);
            }
          };

          // 3. 添加函數來確保字體大小類被正確處理
          function fixFontSizeInHTML(element) {
            if (!element) return;

            // 尋找所有帶有字體大小類的元素
            const sizeElements = element.querySelectorAll('[class*="ql-size-"]');

            // 確保這些元素的字體大小被正確應用
            sizeElements.forEach(el => {
              // 確保字體大小類被設置為!important
              const computedStyle = window.getComputedStyle(el);
              const currentSize = computedStyle.fontSize;

              if (el.classList.contains('ql-size-small')) {
                el.style.setProperty('font-size', '0.75em', 'important');
              } else if (el.classList.contains('ql-size-large')) {
                el.style.setProperty('font-size', '1.5em', 'important');
              } else if (el.classList.contains('ql-size-huge')) {
                el.style.setProperty('font-size', '2em', 'important');
              }
            });

            // 修復特殊情況：如果字體大小類被應用到<p>標籤，而內容在其中
            const paragraphs = element.querySelectorAll('p[class*="ql-size-"]');
            paragraphs.forEach(p => {
              const sizeClass = Array.from(p.classList).find(cls => cls.startsWith('ql-size-'));
              if (sizeClass) {
                // 確保段落內的所有文本和元素都繼承字體大小
                p.style.setProperty('font-size', sizeClass === 'ql-size-small' ? '0.75em' :
                                   sizeClass === 'ql-size-large' ? '1.5em' :
                                   sizeClass === 'ql-size-huge' ? '2em' : 'inherit', 'important');
              }
            });
          }

          // 4. 修改卡片保存函數，確保字體大小設定被保存
          const originalAddNewCard = window.addNewCard;
          window.addNewCard = function(frontText, frontImage, backText, backImage) {
            // 確保HTML中的字體大小類被保存
            if (frontText) {
              frontText = ensureFontSizePresereved(frontText);
            }

            if (backText) {
              backText = ensureFontSizePresereved(backText);
            }

            return originalAddNewCard(frontText, frontImage, backText, backImage);
          };

          function ensureFontSizePresereved(html) {
            // 創建臨時元素來處理HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;

            // 確保所有字體大小類都被正確設置
            const sizeElements = temp.querySelectorAll('[class*="ql-size-"]');
            sizeElements.forEach(el => {
              // 添加內聯樣式以確保字體大小被保留
              if (el.classList.contains('ql-size-small')) {
                el.style.fontSize = '0.75em';
              } else if (el.classList.contains('ql-size-large')) {
                el.style.fontSize = '1.5em';
              } else if (el.classList.contains('ql-size-huge')) {
                el.style.fontSize = '2em';
              }
            });

            return temp.innerHTML;
          }
        }

        // 在頁面加載完成後執行此函數
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', fixFontSizeDisplay);
        } else {
          fixFontSizeDisplay();
        }

        // Add new card
        function addNewCard(frontText, frontImage, backText, backImage) {
            const newCardId = Date.now();

            const newCard = {
                id: newCardId,
                frontText: frontText,
                frontImage: frontImage,
                backText: backText,
                backImage: backImage,
                nextReview: Date.now(),
                repetitions: 0,
                easeFactor: 2.0,
                interval: 1.0
            };

            cardsData.push(newCard);
            return newCardId;
        }

        // Load all cards for management
        function loadAllCards() {
            allCardsContainer.innerHTML = '';

            // Get search and filter values
            const searchText = cardSearchInput.value.toLowerCase();
            const selectedDeckId = deckFilterSelect.value;

            // Filter cards
            let filteredCards = cardsData;

            // Apply search filter
            if (searchText) {
                filteredCards = filteredCards.filter(card =>
                    (card.frontText && stripHtml(card.frontText).toLowerCase().includes(searchText)) ||
                    (card.backText && stripHtml(card.backText).toLowerCase().includes(searchText))
                );
            }

            // Apply deck filter
            if (selectedDeckId !== 'all') {
                const deckId = parseInt(selectedDeckId);
                const deck = decksData.find(d => d.id === deckId);
                if (deck) {
                    filteredCards = filteredCards.filter(card => deck.cardIds.includes(card.id));
                }
            }

            if (filteredCards.length === 0) {
                allCardsContainer.innerHTML = '<p class="text-center py-4">沒有符合條件的字卡</p>';
                return;
            }

            // Reset select all checkbox
            selectAllCards.checked = false;

            filteredCards.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.className = 'bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-300 dark:border-gray-700';

                // Determine if card has a difficulty rating
                let difficultyBadge = '';
                if (card.difficulty) {
                    let difficultyLabel;
                    let difficultyClass;

                    switch (card.difficulty) {
                        case 'easy':
                            difficultyLabel = '簡單';
                            difficultyClass = 'bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-100';
                            break;
                        case 'medium':
                            difficultyLabel = '中等';
                            difficultyClass = 'bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-100';
                            break;
                        case 'hard':
                            difficultyLabel = '困難';
                            difficultyClass = 'bg-red-100 dark:bg-red-900 text-red-800 dark:text-red-100';
                            break;
                        default:
                            difficultyLabel = '未知';
                            difficultyClass = 'bg-gray-100 dark:bg-gray-800';
                    }

                    difficultyBadge = `
                        <span class="text-xs px-2 py-1 rounded-full ${difficultyClass}">
                            ${difficultyLabel}
                        </span>
                    `;
                }

                // Find which decks contain this card
                const containingDecks = decksData.filter(deck => deck.cardIds.includes(card.id));
                let deckBadges = '';

                if (containingDecks.length > 0) {
                    const deckList = containingDecks.map(deck =>
                        `<span class="text-xs px-2 py-1 bg-primary bg-opacity-10 text-primary rounded-full">
                            ${deck.name}
                        </span>`
                    ).join('');

                    deckBadges = `
                        <div class="mt-2 flex flex-wrap gap-2">
                            ${deckList}
                        </div>
                    `;
                }

                // Create front content preview
                let frontContent = `<div class="font-medium quill-content-preview">${card.frontText || ""}</div>`;
                if (card.frontImage) {
                    frontContent += `<div class="mt-2"><img src="${card.frontImage}" class="h-12 rounded"></div>`;
                }

                // Create back content preview
                let backContent = `<div class="text-gray-600 dark:text-gray-400 mt-1 quill-content-preview">${card.backText || ""}</div>`;
                if (card.backImage) {
                    backContent += `<div class="mt-2"><img src="${card.backImage}" class="h-12 rounded"></div>`;
                }

                // Check if card is selected
                const isSelected = selectedCardIds.has(card.id);

                cardElement.innerHTML = `
                    <div class="flex items-start">
                        <input type="checkbox" class="card-checkbox mt-1 mr-3" value="${card.id}" ${isSelected ? 'checked' : ''}>
                        <div class="flex flex-1 justify-between items-start">
                            <div class="flex-1 pr-4">
                                ${frontContent}
                                ${backContent}
                                <div class="mt-2 flex flex-wrap gap-2">
                                    ${difficultyBadge}
                                    <span class="text-xs px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded-full">
                                        下次複習: ${formatDate(card.nextReview)}
                                    </span>
                                    <span class="text-xs px-2 py-1 bg-gray-100 dark:bg-gray-700 rounded-full">
                                        複習次數: ${card.repetitions || 0}
                                    </span>
                                </div>
                                ${deckBadges}
                            </div>
                            <div class="flex space-x-2">
                                <button class="edit-card-btn text-blue-500 hover:text-blue-700" data-id="${card.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                                    </svg>
                                </button>
                                <button class="delete-card-btn text-red-500 hover:text-red-700" data-id="${card.id}">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                allCardsContainer.appendChild(cardElement);
            });

            // Add card checkbox event listeners
            document.querySelectorAll('.card-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const cardId = parseInt(this.value);
                    if (this.checked) {
                        selectedCardIds.add(cardId);
                    } else {
                        selectedCardIds.delete(cardId);
                    }
                    updateBatchDeleteButton();
                });
            });

            // Add edit card event listeners
            document.querySelectorAll('.edit-card-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const cardId = parseInt(e.currentTarget.dataset.id);
                    openCardEditModal(cardId);
                });
            });

            // Add delete card event listeners
            document.querySelectorAll('.delete-card-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const cardId = parseInt(e.currentTarget.dataset.id);
                    deleteCard(cardId);
                });
            });
        }

        // 移除HTML標籤，用於搜索
        function stripHtml(html) {
            const temporalDiv = document.createElement("div");
            temporalDiv.innerHTML = html;
            return temporalDiv.textContent || temporalDiv.innerText || "";
        }

        // Open card edit modal
        function openCardEditModal(cardId) {
            const card = cardsData.find(c => c.id === cardId);
            if (!card) return;

            editingCardId = cardId;

            // 設置Quill編輯器內容
            editFrontQuill.root.innerHTML = card.frontText || '';
            editBackQuill.root.innerHTML = card.backText || '';

            // Reset image data
            editFrontImageData = card.frontImage;
            editBackImageData = card.backImage;

            // Set image previews
            if (card.frontImage) {
                editFrontPreviewImg.src = card.frontImage;
                editFrontImagePreview.classList.remove('hidden');
            } else {
                editFrontImagePreview.classList.add('hidden');
            }

            if (card.backImage) {
                editBackPreviewImg.src = card.backImage;
                editBackImagePreview.classList.remove('hidden');
            } else {
                editBackImagePreview.classList.add('hidden');
            }

            // Load deck options
            loadCardEditDeckOptions(cardId);

            // Show modal
            cardEditModal.classList.remove('hidden');

            // Setup event listeners
            closeCardEditBtn.addEventListener('click', closeCardEditModal);
            saveCardEditBtn.addEventListener('click', saveCardEdit);

            // Add click outside to close functionality
            document.addEventListener('click', handleCardEditOutsideClick);
        }

        // Load deck options for card editing
        function loadCardEditDeckOptions(cardId) {
            editCardDecksList.innerHTML = '';

            if (decksData.length === 0) {
                editCardDecksList.innerHTML = '<p class="text-gray-500 text-sm py-2">尚未建立任何卡組</p>';
                return;
            }

            decksData.forEach(deck => {
                const isInDeck = deck.cardIds.includes(cardId);

                const deckOption = document.createElement('div');
                deckOption.className = 'flex items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';
                deckOption.innerHTML = `
                    <input type="checkbox" id="deck-${deck.id}" data-deck-id="${deck.id}" class="mr-2" ${isInDeck ? 'checked' : ''}>
                    <label for="deck-${deck.id}" class="flex-1 cursor-pointer">${deck.name}</label>
                `;

                editCardDecksList.appendChild(deckOption);
            });
        }

        // Close card edit modal
        function closeCardEditModal() {
            cardEditModal.classList.add('hidden');
            document.removeEventListener('click', handleCardEditOutsideClick);
            editingCardId = null;
        }

        // Handle click outside the card edit modal to close it
        function handleCardEditOutsideClick(event) {
            const modalContent = cardEditModal.querySelector('div');
            if (cardEditModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeCardEditModal();
            }
        }

        // Save card edit
        function saveCardEdit() {
            const cardIndex = cardsData.findIndex(c => c.id === editingCardId);
            if (cardIndex === -1) return;

            const frontContent = editFrontQuill.root.innerHTML.trim();
            const backContent = editBackQuill.root.innerHTML.trim();

            if (frontContent === '<p><br></p>' && backContent === '<p><br></p>' && !editFrontImageData && !editBackImageData) {
                showNotification('字卡必須至少包含一些內容');
                return;
            }

            // Update card data
            cardsData[cardIndex].frontText = frontContent !== '<p><br></p>' ? frontContent : '';
            cardsData[cardIndex].backText = backContent !== '<p><br></p>' ? backContent : '';
            cardsData[cardIndex].frontImage = editFrontImageData;
            cardsData[cardIndex].backImage = editBackImageData;

            // Update card's deck membership
            const selectedDeckIds = Array.from(editCardDecksList.querySelectorAll('input[type="checkbox"]:checked'))
                .map(checkbox => parseInt(checkbox.getAttribute('data-deck-id')));

            // Remove card from all decks
            decksData.forEach(deck => {
                deck.cardIds = deck.cardIds.filter(id => id !== editingCardId);
            });

            // Add card to selected decks
            selectedDeckIds.forEach(deckId => {
                const deckIndex = decksData.findIndex(deck => deck.id === deckId);
                if (deckIndex !== -1) {
                    decksData[deckIndex].cardIds.push(editingCardId);
                }
            });

            closeCardEditModal();
            loadAllCards();
            showNotification('字卡已更新');

            // Show storage reminder as data has changed
            showStorageReminder();
        }

        // Delete a card
        function deleteCard(cardId) {
            // Remove card from cardsData
            cardsData = cardsData.filter(card => card.id !== cardId);

            // Remove card from all decks
            decksData.forEach(deck => {
                deck.cardIds = deck.cardIds.filter(id => id !== cardId);
            });

            // Remove from selection if it was selected
            selectedCardIds.delete(cardId);
            updateBatchDeleteButton();

            loadAllCards();
            showNotification('字卡已刪除');

            // Show storage reminder as data has changed
            showStorageReminder();
        }

        // Load all decks for management
        function loadAllDecks() {
            allDecksContainer.innerHTML = '';

            if (decksData.length === 0) {
                allDecksContainer.innerHTML = `
                    <div class="text-center py-8 text-gray-500 dark:text-gray-400">
                        沒有可用的卡組。請先建立卡組。
                    </div>
                `;
                return;
            }

            // Apply search filter
            const searchText = manageDeckSearchInput.value.trim();
            let filteredDecks = filterDecksBySearch(decksData, searchText);

            // Apply sorting
            const sortedDecks = sortDecks(filteredDecks, manageDeckSortPreference);

            if (sortedDecks.length === 0) {
                allDecksContainer.innerHTML = '<div class="text-center py-8 text-gray-500 dark:text-gray-400">沒有符合搜尋條件的卡組</div>';
                return;
            }

            // Reset select all checkbox
            selectAllDecks.checked = false;

            sortedDecks.forEach(deck => {
                const deckElement = document.createElement('div');
                deckElement.className = 'bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-300 dark:border-gray-700';

                const cardCount = deck.cardIds.length;
                const createdDate = formatDate(deck.createdAt || Date.now());
                const isSelected = selectedDeckIds2.has(deck.id);

                deckElement.innerHTML = `
                    <div class="flex items-start">
                        <input type="checkbox" class="deck-checkbox mt-1 mr-3" value="${deck.id}" ${isSelected ? 'checked' : ''}>
                        <div class="flex flex-1 justify-between items-start">
                            <div class="flex-1 pr-4">
                                <h3 class="font-medium text-lg mb-1">${deck.name}</h3>
                                <p class="text-gray-600 dark:text-gray-400 text-sm mb-2">${deck.description || '無描述'}</p>
                                <div class="text-xs text-gray-500 dark:text-gray-500 flex flex-wrap gap-2">
                                    <span>包含 ${cardCount} 張字卡</span>
                                    <span>建立於: ${createdDate}</span>
                                </div>
                            </div>
                            <div class="flex space-x-2">
                                <button class="export-deck-btn text-green-500 hover:text-green-700" data-id="${deck.id}" title="匯出卡組">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                    </svg>
                                </button>
                                <button class="edit-deck-btn text-blue-500 hover:text-blue-700" data-id="${deck.id}" title="編輯卡組">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                                    </svg>
                                </button>
                                <button class="delete-deck-btn text-red-500 hover:text-red-700" data-id="${deck.id}" title="刪除卡組">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                allDecksContainer.appendChild(deckElement);
            });

            // Add deck checkbox event listeners
            document.querySelectorAll('.deck-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const deckId = parseInt(this.value);
                    if (this.checked) {
                        selectedDeckIds2.add(deckId);
                    } else {
                        selectedDeckIds2.delete(deckId);
                    }
                    updateBatchDeleteDecksButton();
                });
            });

            // Add export deck event listeners
            document.querySelectorAll('.export-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const deckId = parseInt(e.currentTarget.dataset.id);
                    exportSingleDeck(deckId);
                });
            });

            // Add edit deck event listeners
            document.querySelectorAll('.edit-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const deckId = parseInt(e.currentTarget.dataset.id);
                    openDeckEditModal(deckId);
                });
            });

            // Add delete deck event listeners
            document.querySelectorAll('.delete-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const deckId = parseInt(e.currentTarget.dataset.id);
                    deleteDeck(deckId);
                });
            });
        }

        // Export a single deck
        function exportSingleDeck(deckId) {
            const deck = decksData.find(deck => deck.id === deckId);
            if (!deck) {
                showNotification('找不到指定的卡組');
                return;
            }

            // Get all cards from this deck
            const deckCards = cardsData.filter(card => deck.cardIds.includes(card.id));

            const exportData = {
                version: "1.1",
                type: "single_deck",
                exportDate: new Date().toISOString(),
                decksData: [deck],
                cardsData: deckCards
            };

            // Generate filename
            const safeFileName = deck.name.replace(/[^\w\s]/gi, '_');
            const dateStr = new Date().toISOString().split('T')[0].replace(/-/g, '');
            const filename = `${safeFileName}_${dateStr}.json`;

            // Convert to JSON
            const jsonStr = JSON.stringify(exportData, null, 2);

            // Create and trigger download
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();

            // Cleanup
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);

            showNotification(`成功匯出卡組：${deck.name}`);
        }

        // Open deck edit modal
        function openDeckEditModal(deckId) {
            const deck = decksData.find(d => d.id === deckId);
            if (!deck) return;

            editingDeckId = deckId;
            editDeckNameInput.value = deck.name;
            editDeckDescriptionInput.value = deck.description || '';

            // Load cards in deck
            loadDeckCards(deck);

            // Load available cards (cards not in this deck)
            loadAvailableCards(deck);

            // Show modal
            deckEditModal.classList.remove('hidden');

            // Setup event listeners
            closeDeckEditBtn.addEventListener('click', closeDeckEditModal);
            saveDeckEditBtn.addEventListener('click', saveDeckEdit);

            // Add click outside to close functionality
            document.addEventListener('click', handleDeckEditOutsideClick);
        }

        // Load cards in deck for editing
        function loadDeckCards(deck) {
            deckCardsList.innerHTML = '';

            if (deck.cardIds.length === 0) {
                deckCardsList.innerHTML = '<p class="text-gray-500 text-sm py-2">此卡組中沒有字卡</p>';
                return;
            }

            deck.cardIds.forEach(cardId => {
                const card = cardsData.find(c => c.id === cardId);
                if (!card) return;

                const cardElement = document.createElement('div');
                cardElement.className = 'flex justify-between items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';

                let frontPreview = stripHtml(card.frontText);
                if (frontPreview && frontPreview.length > 20) {
                    frontPreview = frontPreview.substring(0, 20) + '...';
                }

                cardElement.innerHTML = `
                    <span class="text-sm">${frontPreview || '無文字'}</span>
                    <button class="remove-from-deck-btn text-red-500 hover:text-red-700 text-sm" data-card-id="${cardId}">
                        移除
                    </button>
                `;

                deckCardsList.appendChild(cardElement);
            });

            // Add remove card from deck event listeners
            document.querySelectorAll('.remove-from-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const cardId = parseInt(e.currentTarget.dataset.cardId);
                    removeCardFromDeck(cardId);
                });
            });
        }

        // Load available cards for deck editing
        function loadAvailableCards(deck) {
            availableCardsList.innerHTML = '';

            const availableCards = cardsData.filter(card => !deck.cardIds.includes(card.id));

            if (availableCards.length === 0) {
                availableCardsList.innerHTML = '<p class="text-gray-500 text-sm py-2">沒有可添加的字卡</p>';
                return;
            }

            availableCards.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.className = 'flex justify-between items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';

                let frontPreview = stripHtml(card.frontText);
                if (frontPreview && frontPreview.length > 20) {
                    frontPreview = frontPreview.substring(0, 20) + '...';
                }

                cardElement.innerHTML = `
                    <span class="text-sm">${frontPreview || '無文字'}</span>
                    <button class="add-to-deck-btn text-green-500 hover:text-green-700 text-sm" data-card-id="${card.id}">
                        添加
                    </button>
                `;

                availableCardsList.appendChild(cardElement);
            });

            // Add add card to deck event listeners
            document.querySelectorAll('.add-to-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const cardId = parseInt(e.currentTarget.dataset.cardId);
                    addCardToDeck(cardId);
                });
            });
        }

        // Remove card from deck during editing
        function removeCardFromDeck(cardId) {
            const deckIndex = decksData.findIndex(d => d.id === editingDeckId);
            if (deckIndex === -1) return;

            decksData[deckIndex].cardIds = decksData[deckIndex].cardIds.filter(id => id !== cardId);

            // Reload card lists
            loadDeckCards(decksData[deckIndex]);
            loadAvailableCards(decksData[deckIndex]);
        }

        // Add card to deck during editing
        function addCardToDeck(cardId) {
            const deckIndex = decksData.findIndex(d => d.id === editingDeckId);
            if (deckIndex === -1) return;

            // Only add if not already in the deck
            if (!decksData[deckIndex].cardIds.includes(cardId)) {
                decksData[deckIndex].cardIds.push(cardId);
            }

            // Reload card lists
            loadDeckCards(decksData[deckIndex]);
            loadAvailableCards(decksData[deckIndex]);
        }

        // Close deck edit modal
        function closeDeckEditModal() {
            deckEditModal.classList.add('hidden');
            document.removeEventListener('click', handleDeckEditOutsideClick);
            editingDeckId = null;
        }

        // Handle click outside the deck edit modal to close it
        function handleDeckEditOutsideClick(event) {
            const modalContent = deckEditModal.querySelector('div');
            if (deckEditModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeDeckEditModal();
            }
        }

        // Save deck edit
        function saveDeckEdit() {
            const deckIndex = decksData.findIndex(d => d.id === editingDeckId);
            if (deckIndex === -1) return;

            const name = editDeckNameInput.value.trim();
            const description = editDeckDescriptionInput.value.trim();

            if (name) {
                decksData[deckIndex].name = name;
                decksData[deckIndex].description = description;

                closeDeckEditModal();
                loadAllDecks();
                showNotification('卡組已更新');

                // Show storage reminder as data has changed
                showStorageReminder();
            } else {
                showNotification('卡組名稱不能為空');
            }
        }

        // 自定義確認對話框
        function customConfirm(message, title, callback) {
            const confirmModal = document.getElementById('customConfirmModal');
            const confirmModalTitle = document.getElementById('confirmModalTitle');
            const confirmModalMessage = document.getElementById('confirmModalMessage');
            const confirmModalCancelBtn = document.getElementById('confirmModalCancelBtn');
            const confirmModalConfirmBtn = document.getElementById('confirmModalConfirmBtn');

            // 設置標題和消息
            confirmModalTitle.textContent = title || '確認操作';
            confirmModalMessage.textContent = message;

            // 顯示對話框
            confirmModal.classList.remove('hidden');

            // 點擊確認按鈕
            const confirmHandler = () => {
                confirmModal.classList.add('hidden');
                confirmModalConfirmBtn.removeEventListener('click', confirmHandler);
                confirmModalCancelBtn.removeEventListener('click', cancelHandler);
                document.removeEventListener('click', outsideClickHandler);
                callback(true);
            };

            // 點擊取消按鈕
            const cancelHandler = () => {
                confirmModal.classList.add('hidden');
                confirmModalConfirmBtn.removeEventListener('click', confirmHandler);
                confirmModalCancelBtn.removeEventListener('click', cancelHandler);
                document.removeEventListener('click', outsideClickHandler);
                callback(false);
            };

            // 點擊對話框外部
            const outsideClickHandler = (event) => {
                const modalContent = confirmModal.querySelector('div');
                if (confirmModal.contains(event.target) && !modalContent.contains(event.target)) {
                    cancelHandler();
                }
            };

            // 添加事件監聽器
            confirmModalConfirmBtn.addEventListener('click', confirmHandler);
            confirmModalCancelBtn.addEventListener('click', cancelHandler);
            document.addEventListener('click', outsideClickHandler);
        }

        // Delete a deck
        function deleteDeck(deckId) {
            // 使用自定義確認對話框替代confirm
            customConfirm('確定要刪除此卡組嗎？', '刪除卡組', (confirmed) => {
                if (confirmed) {
                    decksData = decksData.filter(deck => deck.id !== deckId);
                    loadAllDecks();
                    showNotification('卡組已刪除');

                    // 顯示存儲提醒
                    showStorageReminder();
                }
            });
        }

        // Helper: Format date
        function formatDate(timestamp) {
            const date = new Date(timestamp);
            return `${date.getFullYear()}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}`;
        }

        // Show notification
        function showNotification(message, duration = 2000) {
            const notification = document.createElement('div');
            notification.className = 'fixed bottom-4 right-4 bg-primary text-white px-4 py-2 rounded-lg shadow-lg transition-opacity duration-500';
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 500);
            }, duration);
        }

        // Show welcome message for first-time users
        function showWelcomeMessage() {
            const welcomeModal = document.createElement('div');
            welcomeModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            welcomeModal.id = 'welcomeModal';
            welcomeModal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                    <h2 class="text-xl font-semibold mb-4 text-primary">歡迎使用遺忘曲線字卡程式</h2>
                    <div class="space-y-4">
                        <p>此應用程式數據儲存在瀏覽器記憶體中，<strong class="text-red-500">不會自動保存</strong>。</p>
                        <p class="font-medium">為避免數據丟失，請注意：</p>
                        <ul class="list-disc pl-5 space-y-2">
                            <li>使用右上角的「匯出數據」按鈕定期保存您的卡組和字卡</li>
                            <li>重要更改後立即匯出保存</li>
                            <li>下次使用時，通過「匯入數據」按鈕載入您保存的檔案</li>
                        </ul>
                        <div class="flex justify-end pt-4">
                            <button id="welcomeCloseBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                                我明白了
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(welcomeModal);

            document.getElementById('welcomeCloseBtn').addEventListener('click', () => {
                welcomeModal.remove();
            });
        }

        // 初始化警告中的"建立第一個卡組"連結
        function initCreateCardWarningLink() {
            const createFirstDeckLinkInWarning = document.getElementById('createFirstDeckLinkInWarning');
            if (createFirstDeckLinkInWarning) {
                createFirstDeckLinkInWarning.addEventListener('click', (e) => {
                    e.preventDefault();
                    openNewDeckModal();
                });
            }
        }

        // Excel Import Functions
        // 初始化Excel導入功能
        function initExcelImport() {
            // 打開Excel導入對話框
            importExcelBtn.addEventListener('click', openExcelImportModal);

            // 關閉Excel導入對話框
            closeImportExcelBtn.addEventListener('click', closeExcelImportModal);

            // 處理Excel文件選擇
            excelFileInput.addEventListener('change', handleExcelFileSelect);

            // 下載Excel模板
            downloadExcelTemplateBtn.addEventListener('click', downloadExcelTemplate);

            // 步驟之間的切換
            nextToPreviewBtn.addEventListener('click', () => {
                showExcelStep(2);
                preparePreviewData();
            });

            // 處理"導入新檔案"按鈕點擊
            importNewFileBtn.addEventListener('click', function() {
                resetExcelImport();
                showExcelStep(1);
            });

            // 處理"完成"按鈕點擊
            finishImportBtn.addEventListener('click', function() {
                closeExcelImportModal();

                // 如果當前在複習頁面，確保視圖已更新到最新狀態
                if (!reviewSection.classList.contains('hidden')) {
                    showReviewStage('deckSelection');
                }
            });

            backToFileBtn.addEventListener('click', () => {
                showExcelStep(1);
            });

            importExcelDataBtn.addEventListener('click', importExcelData);
            finishImportBtn.addEventListener('click', function() {
                closeExcelImportModal();

                // 如果當前在複習頁面，確保視圖已更新到最新狀態
                if (!reviewSection.classList.contains('hidden')) {
                    showReviewStage('deckSelection');
                }
            });

            // 卡組選擇選項的處理
            document.querySelectorAll('input[name="deckOption"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    if (this.value === 'existing') {
                        existingDeckSelector.classList.remove('hidden');
                        newDeckInputs.classList.add('hidden');
                    } else {
                        existingDeckSelector.classList.add('hidden');
                        newDeckInputs.classList.remove('hidden');
                    }
                });
            });

            // 點擊對話框外部以關閉
            importExcelModal.addEventListener('click', function(e) {
                if (e.target === importExcelModal) {
                    closeExcelImportModal();
                }
            });
        }

        // 打開Excel導入對話框
        function openExcelImportModal() {
            resetExcelImport();
            importExcelModal.classList.remove('hidden');
            loadExistingDecks();
        }

        // 關閉Excel導入對話框
        function closeExcelImportModal() {
            importExcelModal.classList.add('hidden');
            resetExcelImport();
        }

        // 重置Excel導入數據和界面
        function resetExcelImport() {
            excelData = null;
            excelColumns = [];
            excelFileName = '';
            excelFileInput.value = '';
            excelFileNameDisplay.classList.add('hidden');
            excelFileNameDisplay.textContent = '';
            nextToPreviewBtn.disabled = true;
            showExcelStep(1);
            excelSheets = {};
            activeSheetName = '';
            sheetMappings = {};
            sheetOptions = {};
        }

        // 顯示指定的Excel匯入步驟
        function showExcelStep(step) {
            excelStep1.classList.add('hidden');
            excelStep2.classList.add('hidden');
            excelStep3.classList.add('hidden');

            if (step === 1) {
                excelStep1.classList.remove('hidden');
            } else if (step === 2) {
                excelStep2.classList.remove('hidden');
            } else if (step === 3) {
                excelStep3.classList.remove('hidden');
            }
        }

        // 處理Excel文件選擇
        function handleExcelFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            // 顯示文件名
            excelFileName = file.name;
            excelFileNameDisplay.textContent = `選擇的檔案: ${excelFileName}`;
            excelFileNameDisplay.classList.remove('hidden');

            // 讀取Excel文件
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });

                    // 檢查是否有工作表
                    if (workbook.SheetNames.length === 0) {
                        showNotification('Excel文件必須至少包含一個工作表');
                        resetExcelImport();
                        return;
                    }

                    // 處理所有工作表
                    workbook.SheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        const sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                        // 確保至少有標題行
                        if (sheetData.length < 2) {
                            console.warn(`工作表 "${sheetName}" 沒有足夠的數據，已忽略`);
                            return;
                        }

                        // 保存工作表數據
                        excelSheets[sheetName] = {
                            data: sheetData,
                            columns: sheetData[0]
                        };

                        // 設置默認卡組映射和列選擇
                        sheetMappings[sheetName] = {
                            deckOption: 'new',
                            deckId: '',
                            newDeckName: sheetName,
                            newDeckDescription: ''
                        };

                        sheetOptions[sheetName] = {
                            frontColumn: 0,
                            backColumn: 1
                        };
                    });

                    // 設置第一個工作表為活動工作表
                    activeSheetName = workbook.SheetNames[0];

                    // 啟用下一步按鈕
                    nextToPreviewBtn.disabled = false;

                } catch (error) {
                    console.error('解析Excel文件出錯:', error);
                    showNotification('解析Excel文件時出錯，請確保文件格式正確');
                    resetExcelImport();
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // 準備預覽數據 - 支持多工作表
        function preparePreviewData() {
            if (Object.keys(excelSheets).length === 0) return;

            // 更新工作表選項卡
            updateSheetTabs();

            // 顯示活動工作表的預覽數據
            showSheetPreview(activeSheetName);

            // 設置工作表映射選項
            updateSheetMappingOptions();

            // 更新格式狀態指示器
            const formatStatusValue = document.getElementById('formatStatusValue');
            if (formatStatusValue) {
                const hasFormatting = excelSheets[activeSheetName]?.hasFormatting;
                if (hasFormatting) {
                    formatStatusValue.textContent = '帶格式（粗體、斜體等將被保留）';
                    formatStatusValue.className = 'text-green-600 dark:text-green-400';
                } else {
                    formatStatusValue.textContent = '純文本（不保留格式）';
                    formatStatusValue.className = 'text-yellow-600 dark:text-yellow-400';
                }
            }
        }

        // 更新工作表選項卡
        function updateSheetTabs() {
            sheetTabsContainer.innerHTML = '';

            Object.keys(excelSheets).forEach(sheetName => {
                const tabElement = document.createElement('div');
                tabElement.className = `sheet-tab ${sheetName === activeSheetName ? 'active' : ''}`;
                tabElement.textContent = sheetName;
                tabElement.dataset.sheet = sheetName;

                tabElement.addEventListener('click', () => {
                    document.querySelectorAll('.sheet-tab').forEach(tab => tab.classList.remove('active'));
                    tabElement.classList.add('active');
                    activeSheetName = sheetName;
                    showSheetPreview(sheetName);

                    // 更新列選擇
                    updateColumnSelectors(sheetName);
                });

                sheetTabsContainer.appendChild(tabElement);
            });
        }

        // 顯示指定工作表的預覽
        function showSheetPreview(sheetName) {
            if (!excelSheets[sheetName]) return;

            const sheetData = excelSheets[sheetName].data;
            const columns = excelSheets[sheetName].columns;

            // 清空現有內容
            excelPreviewHead.innerHTML = '';
            excelPreviewBody.innerHTML = '';

            // 創建表頭
            const headerRow = document.createElement('tr');
            columns.forEach(column => {
                const th = document.createElement('th');
                th.className = 'px-3 py-2 text-left text-sm font-medium';
                th.textContent = column;
                headerRow.appendChild(th);
            });
            excelPreviewHead.appendChild(headerRow);

            // 添加最多5行預覽數據
            const previewRowCount = Math.min(sheetData.length - 1, 5);
            for (let i = 1; i <= previewRowCount; i++) {
                const row = sheetData[i];
                const tr = document.createElement('tr');
                tr.className = i % 2 === 0 ? 'bg-gray-50 dark:bg-gray-900' : '';

                row.forEach((cell, index) => {
                    const td = document.createElement('td');
                    td.className = 'px-3 py-2 text-sm';
                    td.textContent = cell != null ? cell.toString() : '';
                    if (td.textContent.length > 50) {
                        td.textContent = td.textContent.substring(0, 50) + '...';
                    }
                    tr.appendChild(td);
                });

                excelPreviewBody.appendChild(tr);
            }

            // 顯示總行數
            excelRowCount.textContent = `共 ${sheetData.length - 1} 行數據`;

            // 更新列選擇下拉框
            updateColumnSelectors(sheetName);
        }

        // 更新列選擇下拉框
        function updateColumnSelectors(sheetName) {
            frontColumnSelect.innerHTML = '';
            backColumnSelect.innerHTML = '';

            const columns = excelSheets[sheetName].columns;

            columns.forEach((column, index) => {
                // 前面列選擇器
                const frontOption = document.createElement('option');
                frontOption.value = index;
                frontOption.textContent = column;
                frontColumnSelect.appendChild(frontOption);

                // 背面列選擇器
                const backOption = document.createElement('option');
                backOption.value = index;
                backOption.textContent = column;
                backColumnSelect.appendChild(backOption);
            });

            // 設置已保存的選擇或默認選擇
            if (sheetOptions[sheetName]) {
                frontColumnSelect.value = sheetOptions[sheetName].frontColumn;
                backColumnSelect.value = sheetOptions[sheetName].backColumn;
            } else if (columns.length >= 2) {
                frontColumnSelect.value = 0;
                backColumnSelect.value = 1;
            }

            // 添加列選擇變更監聽器
            frontColumnSelect.onchange = () => {
                sheetOptions[sheetName].frontColumn = parseInt(frontColumnSelect.value);
            };

            backColumnSelect.onchange = () => {
                sheetOptions[sheetName].backColumn = parseInt(backColumnSelect.value);
            };
        }

        // 更新工作表映射選項
        function updateSheetMappingOptions() {
            sheetMappingContainer.innerHTML = '';

            Object.keys(excelSheets).forEach(sheetName => {
                const mapping = sheetMappings[sheetName];

                const mappingElement = document.createElement('div');
                mappingElement.className = 'border border-gray-300 dark:border-gray-700 rounded-lg p-3 mb-2';

                mappingElement.innerHTML = `
                    <h4 class="font-medium mb-2">工作表「${sheetName}」</h4>
                    <div class="space-y-2">
                        <div>
                            <label class="flex items-center">
                                <input type="radio" name="deckOption-${sheetName}" value="existing"
                                    ${mapping.deckOption === 'existing' ? 'checked' : ''} class="mr-2">
                                <span>添加到現有卡組</span>
                            </label>
                            <div class="existing-deck-selector ml-6 mt-1 ${mapping.deckOption === 'existing' ? '' : 'hidden'}">
                                <select class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                                    ${decksData.map(deck => `<option value="${deck.id}" ${mapping.deckId === deck.id.toString() ? 'selected' : ''}>${deck.name} (${deck.cardIds.length} 張字卡)</option>`).join('')}
                                </select>
                            </div>
                        </div>
                        <div>
                            <label class="flex items-center">
                                <input type="radio" name="deckOption-${sheetName}" value="new"
                                    ${mapping.deckOption === 'new' ? 'checked' : ''} class="mr-2">
                                <span>創建新卡組</span>
                            </label>
                            <div class="new-deck-inputs ml-6 mt-1 ${mapping.deckOption === 'new' ? '' : 'hidden'}">
                                <input type="text" placeholder="卡組名稱" value="${mapping.newDeckName}"
                                    class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 mb-2">
                                <textarea placeholder="卡組描述（選填）"
                                    class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800" rows="2">${mapping.newDeckDescription}</textarea>
                            </div>
                        </div>
                    </div>
                `;

                sheetMappingContainer.appendChild(mappingElement);

                // 添加事件監聽器
                const existingRadio = mappingElement.querySelector(`input[name="deckOption-${sheetName}"][value="existing"]`);
                const newRadio = mappingElement.querySelector(`input[name="deckOption-${sheetName}"][value="new"]`);
                const existingSelector = mappingElement.querySelector('.existing-deck-selector');
                const newInputs = mappingElement.querySelector('.new-deck-inputs');
                const deckSelect = mappingElement.querySelector('.existing-deck-selector select');
                const newDeckNameInput = mappingElement.querySelector('.new-deck-inputs input');
                const newDeckDescInput = mappingElement.querySelector('.new-deck-inputs textarea');

                existingRadio.addEventListener('change', function() {
                    if (this.checked) {
                        existingSelector.classList.remove('hidden');
                        newInputs.classList.add('hidden');
                        mapping.deckOption = 'existing';
                        mapping.deckId = deckSelect.value;
                    }
                });

                newRadio.addEventListener('change', function() {
                    if (this.checked) {
                        existingSelector.classList.add('hidden');
                        newInputs.classList.remove('hidden');
                        mapping.deckOption = 'new';
                    }
                });

                deckSelect.addEventListener('change', function() {
                    mapping.deckId = this.value;
                });

                newDeckNameInput.addEventListener('input', function() {
                    mapping.newDeckName = this.value;
                });

                newDeckDescInput.addEventListener('input', function() {
                    mapping.newDeckDescription = this.value;
                });
            });
        }

        // 加載現有的卡組到下拉選單
        function loadExistingDecks() {
            // 首先檢查元素是否存在
            const targetExistingDeck = document.getElementById('targetExistingDeck');

            // 如果元素不存在，直接返回
            if (!targetExistingDeck) {
                console.warn('找不到 targetExistingDeck 元素');
                return;
            }

            targetExistingDeck.innerHTML = '';

            if (decksData.length === 0) {
                // 如果沒有現有卡組，默認選擇"創建新卡組"
                const newRadio = document.querySelector('input[name="deckOption"][value="new"]');
                if (newRadio) {
                    newRadio.checked = true;
                }

                const existingDeckSelector = document.getElementById('existingDeckSelector');
                const newDeckInputs = document.getElementById('newDeckInputs');

                if (existingDeckSelector) existingDeckSelector.classList.add('hidden');
                if (newDeckInputs) newDeckInputs.classList.remove('hidden');

                // 添加一個提示選項
                const noDecksOption = document.createElement('option');
                noDecksOption.value = '';
                noDecksOption.textContent = '沒有現有卡組';
                noDecksOption.disabled = true;
                targetExistingDeck.appendChild(noDecksOption);
            } else {

                // 默認選擇"添加到現有卡組"
                document.querySelector('input[name="deckOption"][value="existing"]').checked = true;
                existingDeckSelector.classList.remove('hidden');
                newDeckInputs.classList.add('hidden');

                // 加載所有卡組
                decksData.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.id;
                    option.textContent = `${deck.name} (${deck.cardIds.length} 張字卡)`;
                    targetExistingDeck.appendChild(option);
                });
            }
        }

        // 下載Excel模板 - 更新為多工作表版本
        function downloadExcelTemplate() {
            // 創建工作簿
            const wb = XLSX.utils.book_new();

            // 創建示例工作表 1 - 英文單字
            const englishData = [
                ['正面內容', '背面內容', '備註(選填)'],
                ['Apple', '蘋果', '水果'],
                ['Book', '書本', '文具'],
                ['Computer', '電腦', '電子產品']
            ];
            const wsEnglish = XLSX.utils.aoa_to_sheet(englishData);
            XLSX.utils.book_append_sheet(wb, wsEnglish, '英文單字');

            // 創建示例工作表 2 - 歷史事件
            const historyData = [
                ['事件', '年代', '重要性'],
                ['中國改革開放', '1978年', '高'],
                ['柏林牆倒塌', '1989年', '高'],
                ['911事件', '2001年', '高']
            ];
            const wsHistory = XLSX.utils.aoa_to_sheet(historyData);
            XLSX.utils.book_append_sheet(wb, wsHistory, '歷史事件');

            // 生成Excel文件並下載
            XLSX.writeFile(wb, '字卡模板_多工作表.xlsx');
        }

        // 修改的importExcelData函數 - 支持多工作表
        function importExcelData() {
            if (Object.keys(excelSheets).length === 0) {
                showNotification('沒有可用的工作表數據');
                return;
            }

            // 收集導入結果
            const importResults = [];

            // 處理每個工作表
            for (const sheetName of Object.keys(excelSheets)) {
                const sheetData = excelSheets[sheetName].data;
                const mapping = sheetMappings[sheetName];
                const options = sheetOptions[sheetName];

                // 驗證必要的選擇
                if (options.frontColumn === options.backColumn) {
                    importResults.push({
                        sheetName,
                        success: false,
                        message: '正面和背面不能選擇相同的欄位'
                    });
                    continue;
                }

                // 獲取目標卡組或創建新卡組
                let targetDeckId;
                let targetDeckName;
                let newDeckCreated = false;

                try {
                    if (mapping.deckOption === 'existing') {
                        // 使用現有卡組
                        targetDeckId = parseInt(mapping.deckId);

                        const deckIndex = decksData.findIndex(d => d.id === targetDeckId);
                                                if (deckIndex === -1) {
                                                    importResults.push({
                                                        sheetName,
                                                        success: false,
                                                        message: '找不到選擇的卡組'
                                                    });
                                                    continue;
                                                }
                                                targetDeckName = decksData[deckIndex].name;
                                            } else {
                                                // 創建新卡組
                                                const deckName = mapping.newDeckName.trim();
                                                if (!deckName) {
                                                    importResults.push({
                                                        sheetName,
                                                        success: false,
                                                        message: '卡組名稱不能為空'
                                                    });
                                                    continue;
                                                }

                                                // 建立新卡組
                                                const newDeck = {
                                                    id: Date.now() + Math.floor(Math.random() * 1000), // 確保ID唯一
                                                    name: deckName,
                                                    description: mapping.newDeckDescription.trim(),
                                                    cardIds: [],
                                                    createdAt: Date.now()
                                                };

                                                decksData.push(newDeck);
                                                targetDeckId = newDeck.id;
                                                targetDeckName = newDeck.name;
                                                newDeckCreated = true;
                                            }

                                            // 取得目標卡組
                                            const targetDeck = decksData.find(d => d.id === targetDeckId);
                                            let importedCount = 0;
                                            let skippedCount = 0;

                                            // 從第二行開始循環（跳過標題）
                                            for (let i = 1; i < sheetData.length; i++) {
                                                const row = sheetData[i];

                                                // 獲取正面和背面內容
                                                const frontContent = row[options.frontColumn];
                                                const backContent = row[options.backColumn];

                                                // 跳過缺少必要內容的行
                                                if (!frontContent && !backContent) {
                                                    skippedCount++;
                                                    continue;
                                                }

                                                // 創建新字卡
                                                // 創建新字卡
                                                const newCardId = Date.now() + i + Math.floor(Math.random() * 1000);
                                                let frontText = '';
                                                let backText = '';

                                                // 處理 Google Sheets 格式化內容
                                                if (excelSheets[sheetName].hasFormatting) {
                                                    const frontCell = row[options.frontColumn];
                                                    const backCell = row[options.backColumn];

                                                    // 轉換為 HTML
                                                    frontText = frontCell ? convertDeltaToHTML(frontCell.delta || { ops: [] }) : '';
                                                    backText = backCell ? convertDeltaToHTML(backCell.delta || { ops: [] }) : '';
                                                } else {
                                                    // 普通文本處理
                                                    const frontContent = row[options.frontColumn];
                                                    const backContent = row[options.backColumn];
                                                    frontText = frontContent ? frontContent.toString() : '';
                                                    backText = backContent ? backContent.toString() : '';
                                                }

                                                const newCard = {
                                                    id: newCardId,
                                                    frontText: frontText,
                                                    backText: backText,
                                                    nextReview: Date.now(),
                                                    repetitions: 0,
                                                    easeFactor: 2.0,
                                                    interval: 1.0
                                                };

                                                // 添加新字卡
                                                cardsData.push(newCard);
                                                targetDeck.cardIds.push(newCardId);
                                                importedCount++;
                                            }

                                            // 記錄導入結果
                                            importResults.push({
                                                sheetName,
                                                success: true,
                                                targetDeckName,
                                                importedCount,
                                                skippedCount,
                                                newDeckCreated
                                            });

                                        } catch (error) {
                                            console.error(`工作表 "${sheetName}" 導入出錯:`, error);
                                            importResults.push({
                                                sheetName,
                                                success: false,
                                                message: '導入數據過程中發生錯誤'
                                            });
                                        }
                                    }

                                    // 顯示導入結果
                                    showExcelStep(3);
                                    displayMultiSheetImportResults(importResults);

                                    // 顯示提醒，更新相關UI
                                    showStorageReminder();
                                }

                                // 顯示多工作表導入結果
                                function displayMultiSheetImportResults(results) {
                                    importResults.innerHTML = '';

                                    let totalSuccess = 0;
                                    let totalFailed = 0;
                                    let totalCards = 0;

                                    // 彙總結果
                                    results.forEach(result => {
                                        if (result.success) {
                                            totalSuccess++;
                                            totalCards += result.importedCount;
                                        } else {
                                            totalFailed++;
                                        }
                                    });

                                    // 添加彙總資訊
                                    const summaryHTML = `
                                        <div class="mb-4 border-b pb-3 border-gray-300 dark:border-gray-700">
                                            <h3 class="font-medium mb-2 ${totalFailed > 0 ? 'text-yellow-600 dark:text-yellow-400' : 'text-green-600 dark:text-green-400'}">
                                                導入完成
                                            </h3>
                                            <p>成功處理 <span class="font-medium">${totalSuccess}</span> 個工作表，
                                               失敗 <span class="font-medium">${totalFailed}</span> 個工作表，
                                               共導入 <span class="font-medium">${totalCards}</span> 張字卡</p>
                                        </div>
                                    `;

                                    importResults.innerHTML = summaryHTML;

                                    // 添加每個工作表的詳細結果
                                    const detailsContainer = document.createElement('div');
                                    detailsContainer.className = "space-y-3";

                                    results.forEach(result => {
                                        const resultElement = document.createElement('div');
                                        resultElement.className = `p-3 rounded ${result.success ? 'bg-green-50 dark:bg-green-900/30' : 'bg-red-50 dark:bg-red-900/30'}`;

                                        if (result.success) {
                                            resultElement.innerHTML = `
                                                <h4 class="font-medium">工作表「${result.sheetName}」- 成功</h4>
                                                <p>導入 <span class="font-medium">${result.importedCount}</span> 張字卡${result.skippedCount > 0 ? `，跳過 ${result.skippedCount} 行數據` : ''}</p>
                                                <p>卡組: <span class="font-medium">${result.targetDeckName}</span> ${result.newDeckCreated ? '(新建)' : '(現有)'}</p>
                                            `;
                                        } else {
                                            resultElement.innerHTML = `
                                                <h4 class="font-medium text-red-600 dark:text-red-400">工作表「${result.sheetName}」- 失敗</h4>
                                                <p>${result.message || '未知錯誤'}</p>
                                            `;
                                        }

                                        detailsContainer.appendChild(resultElement);
                                    });

                                    importResults.appendChild(detailsContainer);

                                    // 添加導覽提示
                                    if (totalSuccess > 0) {
                                        const tipsElement = document.createElement('div');
                                        tipsElement.className = "mt-4 pt-4 border-t border-gray-300 dark:border-gray-700";
                                        tipsElement.innerHTML = `
                                            <p class="text-sm">你現在可以:</p>
                                            <ul class="list-disc pl-5 mt-2 text-sm space-y-1">
                                                <li>在「複習」頁面中選擇卡組進行複習</li>
                                                <li>在「管理卡組」頁面中查看或編輯卡組</li>
                                                <li>在「管理字卡」頁面中查看或編輯導入的字卡</li>
                                            </ul>
                                        `;
                                        importResults.appendChild(tipsElement);
                                    }
                                    // 預先更新複習頁面的卡組列表，確保導入後立即可見
                                    loadDeckList();

                                    // 如果用戶當前在複習頁面，確保視圖已正確更新
                                    if (!reviewSection.classList.contains('hidden')) {
                                        showReviewStage('deckSelection');
                                    }
                                }

                                // Initialize app
                                function initApp() {

                                  // 初始化 Google Sheets 導入功能
                                  initGSheetsImport();

                                  // 初始化 API 設置
                                  initApiSettings();

                                    // Initialize Quill editors
                                    initQuillEditors();

                                    // Setup image compression
                                    setupImageCompression();

                                    // Setup drag and drop for file upload
                                    setupDragAndDrop();

                                    // Setup storage reminders
                                    setupStorageReminders();

                                    // 初始化Excel導入功能
                                    initExcelImport();

                                    // 初始化Excel導出功能
                                    exportExcelBtn.addEventListener('click', openExportExcelModal);

                                    // Show welcome message for first time visitors
                                    if (!window.welcomeShown) {
                                        showWelcomeMessage();
                                        window.welcomeShown = true;
                                    }

                                    // 添加視窗大小變化監聽
                                    window.addEventListener('resize', function() {
                                        // 如果在複習界面，動態調整卡片容器高度
                                        if (!reviewInterface.classList.contains('hidden')) {
                                            const availableHeight = window.innerHeight - 220;
                                            cardContainer.style.height = `${Math.max(300, availableHeight * 0.6)}px`;
                                        }

                                        // 調整Quill編輯器外觀
                                        adjustQuillForDarkMode();
                                    });

                                    // Listen for dark mode changes
                                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', adjustQuillForDarkMode);

                                    // 初始觸發一次resize事件，以便在頁面加載時設置正確尺寸
                                    window.dispatchEvent(new Event('resize'));

                                    // Initialize the app with the review section
                                    showSection('review');
                                }

                                // Initialize app when DOM is ready
                                document.addEventListener('DOMContentLoaded', initApp);

                                // 為建立字卡按鈕添加Command+Enter或Ctrl+Enter快捷鍵
                                function setupCardSubmitShortcut() {
                                    // 添加全局鍵盤事件監聽
                                    document.addEventListener('keydown', function(e) {
                                        // 檢測是否是Command+Enter (Mac) 或 Ctrl+Enter (Windows/Linux)
                                        if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                                            // 只有當建立字卡頁面可見時才執行
                                            if (!createCardSection.classList.contains('hidden')) {

                                                // 防止可能的默認行為
                                                e.preventDefault();

                                                // 模擬點擊「建立字卡」按鈕
                                                const submitButton = cardForm.querySelector('button[type="submit"]');
                                                if (submitButton) {
                                                    // 添加按鈕點擊效果以提供視覺反饋
                                                    submitButton.classList.add('active');
                                                    setTimeout(() => {
                                                        submitButton.classList.remove('active');
                                                    }, 200);

                                                    // 觸發表單提交
                                                    submitButton.click();
                                                }
                                            }
                                        }
                                    });

                                    // 添加提示樣式
                                    const styleElement = document.createElement('style');
                                    styleElement.textContent = `
                                        button[type="submit"].active {
                                            transform: scale(0.95);
                                            box-shadow: 0 0 0 3px rgba(93, 92, 222, 0.3);
                                        }
                                    `;
                                    document.head.appendChild(styleElement);

                                    // 添加快捷鍵提示到按鈕上
                                    const submitButton = cardForm.querySelector('button[type="submit"]');
                                    if (submitButton) {
                                        // 檢測操作系統以顯示適當的快捷鍵提示
                                        const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
                                        const shortcutText = isMac ? '⌘+Enter' : 'Ctrl+Enter';

                                        // 創建提示元素
                                        const shortcutTip = document.createElement('span');
                                        shortcutTip.className = 'ml-2 text-xs text-white bg-black bg-opacity-30 px-2 py-1 rounded';
                                        shortcutTip.textContent = shortcutText;

                                        // 添加到按鈕中
                                        submitButton.appendChild(shortcutTip);

                                        // 更新按鈕樣式以容納提示
                                        submitButton.classList.add('flex', 'items-center', 'justify-center');
                                    }
                                }

                                // 確保DOM完全加載後運行
                                if (document.readyState === 'loading') {
                                    document.addEventListener('DOMContentLoaded', setupCardSubmitShortcut);
                                } else {
                                    setupCardSubmitShortcut();
                                }

                            </script>
                        </body>
                        </html>
