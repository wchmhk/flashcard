<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <script src="https://apis.google.com/js/api.js"></script>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="字卡">
    <link rel="apple-touch-icon" href="圖標URL.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>字卡程式</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

    <!-- Quill.js 編輯器相關文件 -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.0-rc.2/dist/quill.snow.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.0-rc.2/dist/quill.min.js"></script>

    <script>

    // Google API 密鑰配置
    let GOOGLE_API_KEY = '';

    // 從localStorage加載保存的API密鑰(如果有)
    if (localStorage.getItem('google_api_key')) {
        GOOGLE_API_KEY = localStorage.getItem('google_api_key');
    }

    </script>

    <style>

        /* 共用編輯器容器樣式 */
        .card-editor-container {
          margin-bottom: 1.5rem;
        }

        /* 上下輸入區容器 */
        .combined-editors {
          border: 1px solid rgb(209, 213, 219);
          border-bottom-left-radius: 0.5rem;
          border-bottom-right-radius: 0.5rem;
          overflow: hidden;
        }

        .dark .combined-editors {
          border-color: rgb(75, 85, 99);
        }

        /* 輸入區樣式 */
        .editor-section {
          position: relative;
          background-color: white;
        }

        .dark .editor-section {
          background-color: rgb(31, 41, 55);
        }

        /* 正面和背面輸入區分隔線 */
        .editor-divider {
          height: 1px;
          background-color: rgb(229, 231, 235);
        }

        .dark .editor-divider {
          background-color: rgb(75, 85, 99);
        }

        /* 編輯器內容區域 */
        .editor-content {
          padding: 0.75rem;
          min-height: 80px;
        }

        .editor-content .ql-editor {
          padding: 0;
          min-height: 80px;
        }

        /* 圖片按鈕樣式 */
        .image-btn {
          padding: 0.6rem;
          border: 1px solid rgb(209, 213, 219);
          border-radius: 0.5rem;
          background-color: rgb(243, 244, 246);
          transition: background-color 0.2s;
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .dark .image-btn {
          border-color: rgb(75, 85, 99);
          background-color: rgb(55, 65, 81);
        }

        .image-btn:hover {
          background-color: rgb(229, 231, 235);
        }

        .dark .image-btn:hover {
          background-color: rgb(75, 85, 99);
        }

        /* 圖片預覽區域調整 */
        #frontImagePreview, #backImagePreview {
          margin-top: 0.5rem;
        }

        /* 自定義多選下拉框樣式 */
        .multiselect-dropdown {
            position: relative;
        }
        .multiselect-options {
            position: absolute;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10;
        }
        .multiselect-option {
            cursor: pointer;
        }
        .multiselect-option:hover {
            background-color: rgba(93, 92, 222, 0.1);
        }
        .multiselect-option.selected {
            background-color: rgba(93, 92, 222, 0.2);
        }

        /* 改進表單佈局 */
        .input-group {
            display: flex;
            align-items: stretch;
            position: relative;
        }

        .input-group .ql-container {
            flex-grow: 1;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .input-group button {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        /* 拖拽上傳相關樣式 */
        .drag-area {
            position: relative;
            width: 100%;
        }

        .drag-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(93, 92, 222, 0.1);
            border: 2px dashed #5D5CDE;
            border-radius: 0.5rem;
            pointer-events: none;
            z-index: 10;
        }

        .drag-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #5D5CDE;
            font-weight: 500;
            text-align: center;
            pointer-events: none;
        }

        .input-group.drag-over .drag-overlay {
            display: block;
        }

        /* 暗模式拖拽樣式調整 */
        .dark .drag-overlay {
            background-color: rgba(93, 92, 222, 0.2);
        }

        /* Quill編輯器樣式調整 */
        .ql-toolbar.ql-snow {
            border-color: rgb(209, 213, 219);
            border-top-right-radius: 0.5rem;
            border-top-left-radius: 0.5rem;
        }

        .dark .ql-toolbar.ql-snow {
            border-color: rgb(75, 85, 99);
            background-color: rgb(31, 41, 55);
        }

        .ql-container.ql-snow {
            border-color: rgb(209, 213, 219);
            border-bottom-right-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }

        .dark .ql-container.ql-snow {
            border-color: rgb(75, 85, 99);
            background-color: rgb(31, 41, 55);
            color: white;
        }

        .dark .ql-toolbar.ql-snow .ql-picker,
        .dark .ql-toolbar.ql-snow .ql-stroke {
            color: white;
            stroke: white;
        }

        .dark .ql-toolbar.ql-snow .ql-fill {
            fill: white;
        }

        .dark .ql-snow .ql-picker-options {
            background-color: rgb(31, 41, 55);
        }

        /* 修改編輯器和按鈕布局相關樣式 */
        .editor-with-button {
            display: flex;
            flex-direction: column; /* 改為垂直排列 */
            align-items: stretch;
            width: 100%;
            position: relative;
        }

        /* 編輯器容器樣式 */
        .editor-with-button .ql-container.ql-snow {
            flex-grow: 1;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom: none; /* 移除底部邊框 */
            min-height: 100px;
        }

        /* 工具欄樣式 */
        .editor-with-button .ql-toolbar.ql-snow {
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            width: 100%; /* 確保寬度與編輯器一致 */
        }

        /* 按鈕區域樣式 */
        .editor-with-button .button-container {
            display: flex;
            width: 100%;
        }

        /* 按鈕樣式 */
        .editor-with-button button {
            padding: 0.5rem 1rem;
            border: 1px solid rgb(209, 213, 219);
            border-top: none; /* 移除頂部邊框使其與編輯器連接 */
            border-radius: 0 0 0.5rem 0.5rem; /* 只保留底部圓角 */
            background-color: rgb(243, 244, 246);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
            width: 100%; /* 讓按鈕填滿整個寬度 */
        }

        .dark .editor-with-button button {
            background-color: rgb(55, 65, 81);
            border-color: rgb(75, 85, 99);
        }

        .editor-with-button button:hover {
            background-color: rgb(229, 231, 235);
        }

        .dark .editor-with-button button:hover {
            background-color: rgb(75, 85, 99);
        }

        /* 字卡正面背面分隔線 */
        #cardFront, #cardBack {
            word-break: break-word;
        }

        /* 複習界面的字卡樣式 */
        #cardFront p, #cardBack p,
        #frontText, #backText {
            margin-bottom: 0.5rem;
        }

        /* 確保Quill編輯器在模態框中的可見性 */
        .modal-quill-editor {
            z-index: 100;
        }

        /* 工作表列表樣式 */
        .sheet-tab {
            cursor: pointer;
            padding: 0.5rem 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.25rem;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            display: inline-block;
        }

        .sheet-tab.active {
            background-color: #5D5CDE;
            color: white;
            border-color: #5D5CDE;
        }

        .dark .sheet-tab {
            border-color: #4b5563;
        }

        .dark .sheet-tab.active {
            background-color: #5D5CDE;
            border-color: #5D5CDE;
        }

        /* Quill編輯器對齊樣式 */
        .ql-align-center {
          text-align: center;
        }

        .ql-align-right {
          text-align: right;
        }

        .ql-align-justify {
          text-align: justify;
        }

        /* 確保卡片顯示區域也應用相同的樣式 */
        #cardFront .ql-align-center,
        #cardBack .ql-align-center,
        #frontText .ql-align-center,
        #backText .ql-align-center {
          text-align: center;
        }

        #cardFront .ql-align-right,
        #cardBack .ql-align-right,
        #frontText .ql-align-right,
        #backText .ql-align-right {
          text-align: right;
        }

        #cardFront .ql-align-justify,
        #cardBack .ql-align-justify,
        #frontText .ql-align-justify,
        #backText .ql-align-justify {
          text-align: justify;
        }

        #cardFront, #cardBack, #frontText, #backText, .ql-editor {
          font-size: 24px; /* 調整這個值改變默認字體大小 */
        }

        /* 處理圖片對齊 */
        .ql-align-center img {
          display: block;
          margin-left: auto;
          margin-right: auto;
        }

        .ql-align-right img {
          display: block;
          margin-left: auto;
          margin-right: 0;
        }

        .ql-align-justify img {
          display: block;
          width: 100%;
          height: auto;
        }

        /* 根據字型大小調整圖片尺寸 - 優化版 */
        .ql-size-small img {
          max-width: 40%;
          height: auto;
          transition: all 0.3s ease;
        }

        .ql-editor .ql-size-small img {
          margin: 5px auto;
          display: block;
        }

        .ql-size-large img {
          max-width: 75%;
          height: auto;
          transition: all 0.3s ease;
        }

        .ql-size-huge img {
          max-width: 100%;
          height: auto;
          transition: all 0.3s ease;
        }

        /* 確保按鈕在淺色模式下也能清晰可見 */
        /* 主要按鈕 */
        .bg-primary {
          background-color: #5D5CDE;
          border: 1px solid #5D5CDE;
        }

        /* 次要按鈕和白色文本按鈕在淺色模式下的樣式 */
        @media (prefers-color-scheme: light) {
          .bg-gray-500, .bg-red-500, .bg-yellow-500, .bg-blue-500, .bg-green-500,
          .bg-gray-300, .bg-red-600, .bg-yellow-600, .bg-blue-600, .bg-green-600 {
            border: 1px solid currentColor;
          }

          /* 特別處理白色文本按鈕 */
          button.text-white:not(.bg-primary) {
            border: 1px solid #718096;
          }

          /* 為沒有邊框的按鈕添加適當的對比度 */
          button.text-white:not([class*="border"]) {
            border: 1px solid #4a5568;
          }

          /* 评分按钮 */
          .rating-btn {
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
          }
        }

        /* 改進對比度的按鈕懸停效果 */
        .bg-red-500:hover, .bg-green-500:hover, .bg-blue-500:hover, .bg-yellow-500:hover {
          box-shadow: 0 0 0 2px rgba(0,0,0,0.1);
        }

        .dark .bg-red-500:hover, .dark .bg-green-500:hover,
        .dark .bg-blue-500:hover, .dark .bg-yellow-500:hover {
          box-shadow: 0 0 0 2px rgba(255,255,255,0.1);
        }

        /* 為刪除、編輯等操作按鈕添加深色模式支持 */
        .text-red-500, .text-blue-500, .text-green-500 {
          position: relative;
        }

        /* 淺色模式下操作按鈕的背景 */
        @media (prefers-color-scheme: light) {
          .text-red-500, .text-blue-500, .text-green-500 {
            background-color: rgba(0,0,0,0.05);
            border-radius: 4px;
            padding: 2px;
          }

          .text-red-500:hover, .text-blue-500:hover, .text-green-500:hover {
            background-color: rgba(0,0,0,0.1);
          }
        }

        /* 評分按鈕特別樣式 */
        .rating-btn {
          border: 1px solid transparent;
        }

        @media (prefers-color-scheme: light) {
          .rating-btn {
            border-color: currentColor;
          }
        }

        /* 修復模態框的按鈕 */
        .modal-btn {
          border: 1px solid transparent;
        }

        @media (prefers-color-scheme: light) {
          .modal-btn {
            border-color: currentColor;
          }
        }

        /* 修復翻轉按鈕在淺色模式下的顯示 */
        #flipBtn {
          border: 1px solid #5D5CDE;
        }

        /* 卡組編輯對話框樣式 */
        #deckEditModal .bg-white.dark\:bg-gray-800 {
          display: flex;
          flex-direction: column;
          max-height: 95vh;
          height: 95vh;
        }

        #deckEditModal .space-y-4 {
          flex-grow: 1;
          overflow-y: auto;
        }

        #deckCardsList, #availableCardsList {
          height: 30vh;
          max-height: 30vh;
          overflow-y: auto;
          scrollbar-width: thin;
        }

        /* 美化滾動條 */
        #deckCardsList::-webkit-scrollbar,
        #availableCardsList::-webkit-scrollbar {
          width: 6px;
        }

        #deckCardsList::-webkit-scrollbar-thumb,
        #availableCardsList::-webkit-scrollbar-thumb {
          background-color: rgba(156, 163, 175, 0.5);
          border-radius: 3px;
        }

        #deckCardsList::-webkit-scrollbar-track,
        #availableCardsList::-webkit-scrollbar-track {
          background-color: rgba(229, 231, 235, 0.3);
        }

        .dark #deckCardsList::-webkit-scrollbar-thumb,
        .dark #availableCardsList::-webkit-scrollbar-thumb {
          background-color: rgba(75, 85, 99, 0.5);
        }

        .dark #deckCardsList::-webkit-scrollbar-track,
        .dark #availableCardsList::-webkit-scrollbar-track {
          background-color: rgba(31, 41, 55, 0.3);
        }

        /* 確保卡片顯示時也保持這些樣式 */
        #cardFront .ql-align-center img,
        #cardBack .ql-align-center img,
        #frontText .ql-align-center img,
        #backText .ql-align-center img {
          display: block;
          margin-left: auto;
          margin-right: auto;
        }

        #cardFront .ql-align-right img,
        #cardBack .ql-align-right img,
        #frontText .ql-align-right img,
        #backText .ql-align-right img {
          display: block;
          margin-left: auto;
          margin-right: 0;
        }

        /* 字型大小對應的圖片樣式 - 優化版 */
        #cardFront .ql-size-small img,
        #cardBack .ql-size-small img,
        #frontText .ql-size-small img,
        #backText .ql-size-small img {
          max-width: 40%;
          height: auto;
          margin: 5px auto;
          display: block;
          transition: all 0.3s ease;
        }

        #cardFront .ql-size-large img,
        #cardBack .ql-size-large img,
        #frontText .ql-size-large img,
        #backText .ql-size-large img {
          max-width: 75%;
          height: auto;
          transition: all 0.3s ease;
        }

        #cardFront .ql-size-huge img,
        #cardBack .ql-size-huge img,
        #frontText .ql-size-huge img,
        #backText .ql-size-huge img {
          max-width: 100%;
          height: auto;
          transition: all 0.3s ease;
        }

        /* 標準字體大小的圖片樣式 */
        #cardFront img,
        #cardBack img,
        #frontText img,
        #backText img {
          max-width: 60%;
          height: auto;
          transition: all 0.3s ease;
        }

        .sortable-header {
            cursor: pointer;
            user-select: none; /* Prevent text selection on click */
        }
        .sortable-header.sort-asc::after {
            content: " ▲";
            font-size: 0.7em;
            margin-left: 4px;
        }
        .sortable-header.sort-desc::after {
            content: " ▼";
            font-size: 0.7em;
            margin-left: 4px;
        }

        /* 【新增】為內容顯示區塊的段落和列表添加間距，解決換行問題 */
        #cardFront p, #cardBack p,
        #keyConceptsContent p,
        .quill-content-preview-table p {
            margin-bottom: 1rem; /* 為每個段落下方增加間距 */
        }

        /* 【新增】處理列表的縮排和間距 */
        #cardFront ul, #cardFront ol,
        #cardBack ul, #cardBack ol,
        #keyConceptsContent ul, #keyConceptsContent ol,
        .quill-content-preview-table ul, .quill-content-preview-table ol {
            margin-left: 1.5rem;
            margin-bottom: 1rem;
        }

        /* 【新增】確保最後一個元素沒有多餘的底部間距 */
        #cardFront > *:last-child,
        #cardBack > *:last-child,
        #keyConceptsContent > *:last-child,
        .quill-content-preview-table > *:last-child {
            margin-bottom: 0;
        }

    </style>
</head>
<body class="bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-200 min-h-screen pt-0">
    <!-- Sticky Navigation Bar (changed from fixed) -->
    <div class="sticky top-0 w-full z-40 bg-white dark:bg-gray-900 shadow-md">
        <div class="container mx-auto px-4">
            <!-- Navigation tabs -->
            <div class="flex justify-center border-b border-gray-300 dark:border-gray-700 overflow-x-auto">
                <button id="keyConceptsBtn" class="py-3 px-4 border-b-2 border-transparent font-medium whitespace-nowrap">關鍵概念一覽表</button>
                <button id="reviewBtn" class="py-3 px-4 border-b-2 border-primary font-medium whitespace-nowrap">複習</button>
                <button id="createCardBtn" class="py-3 px-4 border-b-2 border-transparent font-medium whitespace-nowrap">建立字卡</button>
                <button id="manageDeckBtn" class="py-3 px-4 border-b-2 border-transparent font-medium whitespace-nowrap">管理卡組</button>
                <button id="manageCardBtn" class="py-3 px-4 border-b-2 border-transparent font-medium whitespace-nowrap">管理字卡</button>
                <button id="dataManagementBtn" class="py-3 px-4 border-b-2 border-transparent font-medium whitespace-nowrap">數據管理</button>
            </div>
        </div>
    </div>

    <!-- Main container for the flashcard app -->
    <div class="container mx-auto px-4 py-4 max-w-3xl flex flex-col min-h-[calc(100vh-4rem)]">

      <!-- Key Concepts Section -->
      <div id="keyConceptsSection" class="space-y-6 hidden">
          <!-- Container for sheet selection buttons -->
          <div id="keyConceptsSheetList" class="flex flex-wrap gap-2 mb-4 border-b border-gray-200 dark:border-gray-700 pb-4">
              <!-- Sheet buttons will be dynamically added here -->
          </div>

          <!-- Controls for Key Concepts (Search and Toggle All) -->
          <div id="keyConceptsControlsContainer" class="flex items-center gap-4 mb-4 hidden">
              <!-- Search Bar -->
              <div class="relative flex-grow">
                  <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                          <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                      </svg>
                  </div>
                  <input type="text" id="keyConceptsSearchInput" placeholder="在此工作表中搜尋..." class="bg-white dark:bg-gray-800 w-full pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary text-base">
              </div>
              <!-- Toggle All Button -->
              <button id="toggleAllConceptsBtn" class="px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg text-sm whitespace-nowrap hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors">
                  展開全部
              </button>
          </div>

          <!-- Container for the concepts of the selected sheet -->
          <div id="keyConceptsContent" class="space-y-3">
              <!-- The list of concepts will be rendered here -->
                <div class="text-center py-10 bg-gray-50 dark:bg-gray-800 rounded-lg">
                    <h3 class="text-lg font-medium">無可用數據</h3>
                    <p class="mt-2 text-gray-600 dark:text-gray-400">請先使用「從 Google Sheets 導入」功能載入您的概念表。</p>
                    <button id="goToImportBtnFromConcepts" class="mt-4 bg-primary hover:bg-opacity-80 text-white font-semibold py-2 px-4 rounded-lg transition-colors">
                        前往導入
                    </button>
                </div>
            </div>
        </div>
        <div id="reviewSection" class="space-y-6">
            <!-- Deck selection -->
            <div id="deckSelection" class="mb-8">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold">選擇卡組</h2>
                    <div class="flex items-center">
                        <label for="deckSortSelect" class="mr-2 text-sm">排序：</label>
                        <select id="deckSortSelect" class="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg px-2 py-1 text-sm">
                            <option value="name">名稱</option>
                            <option value="cards">字卡數量</option>
                            <option value="date-new">最新建立</option>
                            <option value="date-old">最舊建立</option>
                        </select>
                    </div>
                </div>

                <!-- Search bar for decks -->
                <div class="mb-4">
                    <div class="relative">
                        <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                            <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                            </svg>
                        </div>
                        <input type="text" id="deckSearchInput" placeholder="搜尋卡組..." class="bg-white dark:bg-gray-800 pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary w-full text-base">
                    </div>
                </div>

                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4" id="deckList">
                    <!-- Decks will be added here dynamically -->
                    <div class="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">
                        沒有可用的卡組。
                        <a href="#" id="createFirstDeckLink" class="text-primary hover:underline">建立第一個卡組</a>
                    </div>
                </div>
            </div>

            <!-- Mode selection (hidden initially) -->
            <div id="modeSelection" class="mb-8 hidden">
                <h2 class="text-xl font-semibold mb-4">選擇複習模式</h2>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-300 dark:border-gray-700 cursor-pointer hover:border-primary dark:hover:border-primary" data-mode="daily">
                        <h3 class="font-medium text-lg mb-2">日常模式</h3>
                        <p class="text-gray-600 dark:text-gray-400 text-sm">基於遺忘曲線複習，一次完整複習後結束</p>
                    </div>
                    <div class="bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-300 dark:border-gray-700 cursor-pointer hover:border-primary dark:hover:border-primary" data-mode="drill">
                        <h3 class="font-medium text-lg mb-2">操練模式</h3>
                        <p class="text-gray-600 dark:text-gray-400 text-sm">難度決定再次出現的間隔，間隔以複習的字卡數計算</p>
                    </div>
                </div>
            </div>

            <!-- Review interface (hidden initially) -->
            <div id="reviewInterface" class="space-y-4 hidden">
                <div class="flex justify-between items-center mb-1">
                    <div>
                        <span class="text-gray-700 dark:text-gray-300">卡組：</span>
                        <span id="currentDeckName" class="font-medium"></span>
                    </div>
                    <div>
                        <span class="text-gray-700 dark:text-gray-300">模式：</span>
                        <span id="currentModeName" class="font-medium"></span>
                    </div>
                </div>

                <div id="reviewInfo" class="flex justify-between items-center text-sm px-2 mb-2">
                    <button id="flipSidesBtn" class="text-blue-500 hover:text-blue-700 flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
                        </svg>
                        正反互換
                    </button>
                    <button id="exitReviewBtn" class="text-red-500 hover:text-red-700">結束複習</button>
                </div>

                <div id="reviewCard">
                    <div id="cardContainer" class="w-full h-96 bg-white dark:bg-gray-800 rounded-xl shadow-lg flex flex-col items-center justify-center cursor-pointer mb-4 border border-gray-300 dark:border-gray-700 transition-all duration-500 p-6 relative overflow-auto">
                        <div id="cardFront" class="text-xl font-medium text-center w-full h-full flex flex-col items-center justify-center">
                            <div id="frontText" class="mb-4"></div>
                            <div id="frontImage" class="flex-grow flex justify-center"></div>
                        </div>
                        <div id="cardBack" class="text-xl font-medium text-center w-full h-full hidden flex flex-col items-center justify-center">
                            <div id="backText" class="mb-4"></div>
                            <div id="backImage" class="mt-2 flex justify-center"></div>
                        </div>
                    </div>

                    <div class="text-center mb-4">
                        <button id="flipBtn" class="bg-primary hover:bg-opacity-80 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                            翻轉字卡
                        </button>
                    </div>

                    <div id="ratingButtons" class="flex justify-center space-x-4 mt-6 hidden">
                        <button class="rating-btn bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors" data-rating="1">很難</button>
                        <button class="rating-btn bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors" data-rating="2">困難</button>
                        <button class="rating-btn bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors" data-rating="3">良好</button>
                        <button class="rating-btn bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg transition-colors" data-rating="4">簡單</button>
                    </div>
                </div>

                <div id="reviewCompleteMessage" class="text-center py-10 hidden">
                    <p class="text-xl font-bold mb-4 text-primary">複習結束！</p>
                    <p class="text-lg mb-6">您已完成該卡組的所有字卡</p>
                    <div class="space-x-4">
                        <button id="restartDeckBtn" class="bg-primary hover:bg-opacity-80 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                            重新複習此卡組
                        </button>
                        <button id="backToDeckSelectionBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                            返回選擇卡組
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Create card section -->
        <div id="createCardSection" class="space-y-6 hidden">
            <div id="noDeckWarning" class="bg-yellow-100 dark:bg-yellow-900 border-l-4 border-yellow-500 p-4 mb-6 hidden">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-yellow-700 dark:text-yellow-200">
                            請先建立一個卡組再添加字卡。
                            <a href="#" id="createFirstDeckLinkInWarning" class="text-primary hover:underline ml-1">建立第一個卡組</a>
                        </p>
                    </div>
                </div>
            </div>

            <div id="deckSelectionForCard" class="mb-6">
                <div class="flex justify-between items-end mb-1">
                    <label for="deckSelectForCard" class="block text-sm font-medium">選擇卡組</label>
                    <button id="createNewDeckBtn" class="text-primary hover:text-primary-dark text-sm flex items-center ml-2" type="button">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                        </svg>
                        新增卡組
                    </button>
                </div>
                <div class="multiselect-dropdown">
                    <div class="flex items-center border border-gray-300 dark:border-gray-700 rounded-lg px-3 py-2 bg-white dark:bg-gray-800 text-base">
                        <div id="selectedDecks" class="flex-1 flex flex-wrap gap-2">
                            <span class="text-gray-500 dark:text-gray-400" id="selectedDecksPlaceholder">請選擇卡組</span>
                        </div>
                        <button type="button" id="toggleDeckDropdown" class="focus:outline-none">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                            </svg>
                        </button>
                    </div>
                    <div id="deckOptions" class="multiselect-options mt-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg shadow-lg hidden">
                        <!-- Deck options will be added here dynamically -->
                    </div>
                </div>
            </div>

            <form id="cardForm" class="space-y-6">
              <div class="card-editor-container space-y-4">
                <label class="block text-lg font-medium">字卡內容</label>

                <!-- 上下輸入區容器 -->
                <div class="combined-editors">
                  <!-- a. 正面輸入區 -->
                  <div class="editor-section front-section">
                    <div id="frontEditor" class="editor-content"></div>
                  </div>

                  <!-- b. 分隔線 -->
                  <div class="editor-divider"></div>

                  <!-- c. 背面輸入區 -->
                  <div class="editor-section back-section">
                    <div id="backEditor" class="editor-content"></div>
                  </div>
                </div>

                <!-- 拖放區域 -->
                <div class="flex space-x-2">
                  <div class="flex-1 drag-area" id="frontDragArea">
                    <div class="drag-overlay">
                      <div class="drag-text">拖放正面圖片</div>
                    </div>
                  </div>
                  <div class="flex-1 drag-area" id="backDragArea">
                    <div class="drag-overlay">
                      <div class="drag-text">拖放背面圖片</div>
                    </div>
                  </div>
                </div>

                <!-- 圖片預覽區域 -->
                <div class="grid grid-cols-2 gap-4">
                  <div id="frontImagePreview" class="hidden">
                    <div class="flex items-center">
                      <img id="frontPreviewImg" class="max-h-40 max-w-full rounded border border-gray-300 dark:border-gray-700" />
                      <button type="button" id="removeFrontImage" class="ml-2 text-red-500 hover:text-red-700 text-sm">
                        移除
                      </button>
                    </div>
                    <span id="frontImageName" class="text-sm text-gray-500 dark:text-gray-400 mt-1 block"></span>
                  </div>
                  <div id="backImagePreview" class="hidden">
                    <div class="flex items-center">
                      <img id="backPreviewImg" class="max-h-40 max-w-full rounded border border-gray-300 dark:border-gray-700" />
                      <button type="button" id="removeBackImage" class="ml-2 text-red-500 hover:text-red-700 text-sm">
                        移除
                      </button>
                    </div>
                    <span id="backImageName" class="text-sm text-gray-500 dark:text-gray-400 mt-1 block"></span>
                  </div>
                </div>

                <!-- 創建字卡的提交按鈕 -->
                <div class="mt-4 flex justify-end">
                  <button type="submit" class="bg-primary hover:bg-opacity-80 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                    建立字卡
                  </button>
                </div>
              </div>
            </form>
        </div>

        <!-- Manage cards section -->
        <div id="manageCardSection" class="space-y-6 hidden">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 mb-4">
                <h2 class="text-xl font-semibold">管理字卡</h2>
                <div class="flex space-x-2">
                    <button id="deleteBatchCardsBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm hidden">
                        刪除選中 (<span id="selectedCardCount">0</span>)
                    </button>
                    <button id="deleteAllCardsBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm">
                        刪除全部
                    </button>
                </div>
            </div>

            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <div class="relative flex-1">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                        <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <input type="text" id="cardSearchInput" placeholder="搜尋字卡內容..." class="bg-white dark:bg-gray-800 pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary w-full text-base">
                </div>

                <div class="sm:w-1/3">
                    <select id="deckFilterSelect" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary bg-white dark:bg-gray-800 text-base">
                        <option value="all">全部卡組</option>
                        <!-- Deck options will be added here dynamically -->
                    </select>
                </div>
            </div>

            <div class="flex items-center mb-4">
                <input type="checkbox" id="selectAllCards" class="mr-2 h-4 w-4">
                <label for="selectAllCards" class="text-sm">全選</label>
            </div>

            <!-- MODIFIED: allCardsContainer to hold a table -->
            <div id="allCardsContainer" class="overflow-x-auto shadow rounded-lg border border-gray-200 dark:border-gray-700">
                <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                  <thead class="bg-gray-50 dark:bg-gray-800">
                      <tr>
                          <th scope="col" class="py-3 px-4 text-left text-xs font-medium uppercase tracking-wider w-12">
                              <!-- Checkbox -->
                          </th>
                          <th scope="col" class="py-3 px-4 text-left text-xs font-medium uppercase tracking-wider sortable-header" data-sort-key="frontText">正面</th>
                          <th scope="col" class="py-3 px-4 text-left text-xs font-medium uppercase tracking-wider sortable-header" data-sort-key="backText">背面</th>
                          <th scope="col" class="py-3 px-4 text-left text-xs font-medium uppercase tracking-wider sortable-header" data-sort-key="decks">所屬卡組</th>
                          <th scope="col" class="py-3 px-4 text-left text-xs font-medium uppercase tracking-wider sortable-header" data-sort-key="difficulty">難度</th>
                          <th scope="col" class="py-3 px-4 text-left text-xs font-medium uppercase tracking-wider w-24">操作</th>
                      </tr>
                  </thead>
                    <tbody class="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                        <!-- Table rows will be inserted here by JavaScript -->
                        <tr>
                            <td colspan="6" class="text-center py-8 text-gray-500 dark:text-gray-400">
                                沒有可用的字卡。
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Manage decks section -->
        <div id="manageDeckSection" class="space-y-6 hidden">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold">所有卡組</h2>
            </div>

            <!-- Search and sort bar for decks -->
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <div class="relative flex-1">
                    <div class="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                        <svg class="h-5 w-5 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <input type="text" id="manageDeckSearchInput" placeholder="搜尋卡組..." class="bg-white dark:bg-gray-800 pl-10 pr-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary w-full text-base">
                </div>

                <div class="sm:w-1/3 flex items-center">
                    <label for="manageDeckSortSelect" class="mr-2 text-sm whitespace-nowrap">排序：</label>
                    <select id="manageDeckSortSelect" class="flex-1 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-700 rounded-lg px-2 py-2 text-sm">
                        <option value="name">名稱</option>
                        <option value="cards">字卡數量</option>
                        <option value="date-new">最新建立</option>
                        <option value="date-old">最舊建立</option>
                    </select>
                </div>
            </div>

            <div class="flex items-center justify-between mb-4">
                <div class="flex items-center">
                    <input type="checkbox" id="selectAllDecks" class="mr-2 h-4 w-4">
                    <label for="selectAllDecks" class="text-sm">全選</label>
                </div>
                <div class="flex items-center space-x-3">
                    <button id="addDeckInManageBtn" class="bg-primary hover:bg-opacity-80 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                        </svg>
                        新增卡組
                    </button>
                    <button id="mergeBatchDecksBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm hidden">
                        合併 (<span id="mergeSelectedDeckCount">0</span>)
                    </button>
                    <button id="deleteBatchDecksBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm hidden">
                        刪除選中 (<span id="selectedDeckCount">0</span>)
                    </button>
                    <button id="deleteAllDecksBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded-lg transition-colors text-sm">
                        刪除全部
                    </button>
                </div>
            </div>

            <div id="allDecksContainer" class="space-y-4">
                <!-- Decks will be added here dynamically -->
                <div class="text-center py-8 text-gray-500 dark:text-gray-400">
                    沒有可用的卡組。請先建立卡組。
                </div>
            </div>
        </div>

        <!-- Data Management Section -->
        <div id="dataManagementSection" class="space-y-10 hidden">
            <h2 class="text-2xl font-bold">數據管理</h2>

            <!-- Import Section -->
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow border border-gray-300 dark:border-gray-700">
                <h3 class="text-xl font-semibold mb-4 border-b border-gray-200 dark:border-gray-600 pb-3">匯入數據</h3>
                <p class="text-gray-600 dark:text-gray-400 mb-6 text-sm">從外部檔案將字卡和卡組匯入到本程式中。</p>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Import from Excel -->
                    <button id="importExcelBtn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-3 rounded-lg flex items-center justify-center transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M6 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V7.414A2 2 0 0015.414 6L12 2.586A2 2 0 0010.586 2H6zm5 6a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V8z" clip-rule="evenodd" />
                        </svg>
                        從 Excel 導入
                    </button>
                    <!-- Import from Google Sheets -->
                    <button id="importGSheetsBtn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 py-3 rounded-lg flex items-center justify-center transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M19 3H5C3.9 3 3 3.9 3 5v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V5h14v14z"/>
                            <path d="M7 7h2v10H7zm4 0h2v10h-2zm4 0h2v10h-2z"/>
                        </svg>
                        從 Google Sheets 導入
                    </button>
                    <!-- Import from JSON -->
                    <label for="importDataInput" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-3 rounded-lg flex items-center justify-center transition-colors cursor-pointer">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0l-4 4m4-4v12" />
                        </svg>
                        匯入備份 (.json)
                        <input id="importDataInput" type="file" accept=".json" class="hidden">
                    </label>
                </div>
            </div>

            <!-- Export Section -->
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow border border-gray-300 dark:border-gray-700">
                <h3 class="text-xl font-semibold mb-4 border-b border-gray-200 dark:border-gray-600 pb-3">匯出數據</h3>
                <p class="text-gray-600 dark:text-gray-400 mb-6 text-sm">將本程式中的資料匯出成檔案，用於備份或在其他裝置上使用。</p>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                    <!-- Export to Excel -->
                    <button id="exportExcelBtn" class="bg-green-600 hover:bg-green-700 text-white px-4 py-3 rounded-lg flex items-center justify-center transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        導出為 Excel
                    </button>
                    <!-- Export to JSON -->
                    <button id="exportDataBtn" class="bg-primary hover:bg-opacity-80 text-white px-4 py-3 rounded-lg flex items-center justify-center transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                        </svg>
                        匯出備份 (.json)
                    </button>
                </div>
            </div>
            <!-- Local Storage Management -->
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow border border-yellow-500/50 dark:border-yellow-400/50">
                <h3 class="text-xl font-semibold mb-4 border-b border-gray-200 dark:border-gray-600 pb-3 text-yellow-600 dark:text-yellow-300">本地儲存管理</h3>
                <p class="text-gray-600 dark:text-gray-400 mb-6 text-sm">
                    您的資料會自動儲存在此瀏覽器中。您也可以手動執行以下操作。
                    <br>
                    <span id="lastSavedTimestamp" class="text-xs mt-2 block">最後儲存時間：尚未儲存</span>
                </p>
                <div class="flex flex-wrap gap-4">
                    <!-- Force Save Button -->
                    <button id="forceSaveBtn" class="bg-yellow-500 hover:bg-yellow-600 text-white px-4 py-3 rounded-lg flex items-center justify-center transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 2a8 8 0 100 16 8 8 0 000-16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" />
                        </svg>
                        立即儲存
                    </button>
                    <!-- Clear Local Storage Button -->
                    <button id="clearLocalStorageBtn" class="bg-red-600 hover:bg-red-700 text-white px-4 py-3 rounded-lg flex items-center justify-center transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                        清除此瀏覽器的所有存檔
                    </button>
                </div>
            </div>
        </div>

        <!-- Card edit modal -->
                <div id="cardEditModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50 overflow-y-auto py-10">
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4 my-auto max-h-[85vh] overflow-y-auto">
                        <h2 class="text-xl font-semibold mb-4 sticky top-0 bg-white dark:bg-gray-800 py-2 z-10 border-b border-gray-200 dark:border-gray-700">編輯字卡</h2>
                        <div class="space-y-4 overflow-y-auto">
                            <div>
                                <label for="editCardFrontInput" class="block text-sm font-medium mb-1">正面（問題）</label>
                                <div class="editor-with-button">
                                    <!-- Quill編輯器將替換這個div -->
                                    <div id="editFrontEditor"></div>
                                    <!-- 移除了正面的 "更改圖片" 按鈕和拖放區域 -->
                                    <input type="file" id="editCardFrontImage" accept="image/*" class="hidden" />
                                </div>
                            </div>

                            <div id="editFrontImageContainer">
                                <div id="editFrontImagePreview" class="mb-2 hidden">
                                    <div class="flex items-center">
                                        <img id="editFrontPreviewImg" class="max-h-40 max-w-full rounded border border-gray-300 dark:border-gray-700" />
                                        <button type="button" id="removeEditFrontImage" class="ml-2 text-red-500 hover:text-red-700 text-sm">
                                            移除圖片
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div>
                                <label for="editCardBackInput" class="block text-sm font-medium mb-1">背面（答案）</label>
                                <div class="editor-with-button">
                                    <!-- Quill編輯器將替換這個div -->
                                    <div id="editBackEditor"></div>
                                    <!-- 移除了背面的 "更改圖片" 按鈕和拖放區域 -->
                                    <input type="file" id="editCardBackImage" accept="image/*" class="hidden" />
                                </div>
                            </div>

                            <div id="editBackImageContainer">
                                <div id="editBackImagePreview" class="mb-2 hidden">
                                    <div class="flex items-center">
                                        <img id="editBackPreviewImg" class="max-h-40 max-w-full rounded border border-gray-300 dark:border-gray-700" />
                                        <button type="button" id="removeEditBackImage" class="ml-2 text-red-500 hover:text-red-700 text-sm">
                                            移除圖片
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div>
                                <label class="block text-sm font-medium mb-1">所屬卡組</label>
                                <div class="max-h-60 overflow-y-auto space-y-2 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                                    <div id="editCardDecksList">
                                        <!-- Deck checkboxes will be added here dynamically -->
                                    </div>
                                </div>
                            </div>

                            <div class="flex justify-end space-x-3 pt-4">
                                <button id="closeCardEditBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                                    取消
                                </button>
                                <button id="saveCardEditBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                                    儲存
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

        <!-- Deck edit modal -->
        <div id="deckEditModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50 overflow-hidden">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4 overflow-hidden flex flex-col">
                <h2 class="text-xl font-semibold mb-4 flex-shrink-0">編輯卡組</h2>
                <div class="space-y-4 overflow-y-auto flex-grow">
                    <!-- 卡組信息部分 -->
                    <div>
                        <label for="editDeckNameInput" class="block text-sm font-medium mb-1">卡組名稱</label>
                        <input type="text" id="editDeckNameInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" />
                    </div>
                    <div>
                        <label for="editDeckDescriptionInput" class="block text-sm font-medium mb-1">描述</label>
                        <textarea id="editDeckDescriptionInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" rows="2"></textarea>
                    </div>
                    <!-- 卡組卡片部分 -->
                    <div class="border-t border-gray-300 dark:border-gray-700 pt-4 flex-shrink-0">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="font-medium">卡組中的字卡</h3>
                            <div class="relative">
                                <input type="text" id="searchDeckCards" placeholder="搜尋字卡..." class="px-3 py-1 border border-gray-300 dark:border-gray-700 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                                <svg class="absolute right-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                                </svg>
                            </div>
                        </div>
                        <div id="deckCardsList" class="overflow-y-auto space-y-2">
                            <!-- Cards will be added here dynamically -->
                        </div>
                    </div>
                    <!-- 可用卡片部分 -->
                    <div class="border-t border-gray-300 dark:border-gray-700 pt-4 flex-shrink-0">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="font-medium">添加字卡</h3>
                            <div class="relative">
                                <input type="text" id="searchAvailableCards" placeholder="搜尋字卡..." class="px-3 py-1 border border-gray-300 dark:border-gray-700 rounded-lg text-sm focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                                <svg class="absolute right-2 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M8 4a4 4 0 100 8 4 4 0 000-8zM2 8a6 6 0 1110.89 3.476l4.817 4.817a1 1 0 01-1.414 1.414l-4.816-4.816A6 6 0 012 8z" clip-rule="evenodd" />
                                </svg>
                            </div>
                        </div>
                        <div id="availableCardsList" class="overflow-y-auto space-y-2">
                            <!-- Available cards will be added here dynamically -->
                        </div>
                    </div>
                </div>
                <div class="flex justify-end space-x-3 pt-4 mt-4 border-t border-gray-300 dark:border-gray-700 flex-shrink-0">
                    <button id="closeDeckEditBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                        取消
                    </button>
                    <button id="saveDeckEditBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                        儲存
                    </button>
                </div>
            </div>
        </div>
        <!-- 合併卡組對話框 -->
        <div id="mergeDeckModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">合併卡組</h2>
                <div class="space-y-4">
                    <div>
                        <p class="mb-4">您選擇了 <span id="mergeCount" class="font-medium"></span> 個卡組進行合併</p>
                        <div class="mb-4">
                            <label class="block text-sm font-medium mb-1">選擇合併方式</label>
                            <div class="space-y-2">
                                <label class="flex items-center">
                                    <input type="radio" name="mergeOption" value="new" checked class="mr-2">
                                    <span>建立新卡組</span>
                                </label>
                                <label class="flex items-center">
                                    <input type="radio" name="mergeOption" value="replace" class="mr-2">
                                    <span>替換原有卡組（只保留第一個選中的卡組）</span>
                                </label>
                            </div>
                        </div>
                        <div id="mergeNewDeckSection">
                            <label for="mergedDeckNameInput" class="block text-sm font-medium mb-1">合併後的卡組名稱</label>
                            <input type="text" id="mergedDeckNameInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" />
                        </div>
                    </div>
                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="closeMergeDeckBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="saveMergeDeckBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            合併
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <!-- New deck modal -->
        <div id="newDeckModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">新增卡組</h2>
                <div class="space-y-4">
                    <div>
                        <label for="newDeckNameInput" class="block text-sm font-medium mb-1">卡組名稱</label>
                        <input type="text" id="newDeckNameInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" />
                    </div>
                    <div>
                        <label for="newDeckDescriptionInput" class="block text-sm font-medium mb-1">描述 (選填)</label>
                        <textarea id="newDeckDescriptionInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" rows="2"></textarea>
                    </div>
                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="closeNewDeckBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="saveNewDeckBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            建立
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Enhanced Export Modal (with deck selection) -->
        <div id="exportModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">匯出數據</h2>
                <div class="space-y-4">
                    <div>
                        <label for="exportFilenameInput" class="block text-sm font-medium mb-1">檔案名稱</label>
                        <input type="text" id="exportFilenameInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" value="flashcards_data" />
                    </div>

                    <!-- Deck selection section -->
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="block text-sm font-medium">選擇要匯出的卡組</label>
                            <div class="flex space-x-2">
                                <button id="selectAllExportDecksBtn" class="text-xs text-primary hover:underline">全選</button>
                                <button id="deselectAllExportDecksBtn" class="text-xs text-primary hover:underline">取消全選</button>
                            </div>
                        </div>
                        <div id="exportDecksList" class="max-h-60 overflow-y-auto space-y-2 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <!-- Deck checkboxes will be added here dynamically -->
                            <div class="text-center py-4 text-gray-500 dark:text-gray-400">
                                沒有可用的卡組。
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="cancelExportBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="confirmExportBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            匯出
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Import Preview Modal -->
        <div id="importPreviewModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-xl w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">匯入預覽</h2>
                <div class="space-y-4">
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="block text-sm font-medium">選擇要匯入的卡組</label>
                            <div class="flex space-x-2">
                                <button id="selectAllImportDecksBtn" class="text-xs text-primary hover:underline">全選</button>
                                <button id="deselectAllImportDecksBtn" class="text-xs text-primary hover:underline">取消全選</button>
                            </div>
                        </div>
                        <div id="importDecksList" class="max-h-60 overflow-y-auto space-y-2 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <!-- Import decks will be added here dynamically -->
                        </div>
                    </div>

                    <!-- Conflict resolution options -->
                    <div>
                        <label class="block text-sm font-medium mb-2">衝突處理方式</label>
                        <div class="space-y-2">
                            <label class="flex items-center">
                                <input type="radio" name="conflictResolution" value="overwrite" checked class="mr-2">
                                <span>覆蓋 - 用匯入的卡組替換現有同名卡組</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="conflictResolution" value="rename" class="mr-2">
                                <span>重命名 - 為匯入的卡組添加數字後綴</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="conflictResolution" value="merge" class="mr-2">
                                <span>合併 - 將匯入的字卡合併到現有卡組</span>
                            </label>
                            <label class="flex items-center">
                                <input type="radio" name="conflictResolution" value="skip" class="mr-2">
                                <span>跳過 - 不匯入衝突的卡組</span>
                            </label>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="cancelImportBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="confirmImportBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            匯入
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Excel導入對話框 -->
        <div id="importExcelModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50 overflow-y-auto py-10">
          <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-3xl w-full mx-4 my-auto">
                <h2 class="text-xl font-semibold mb-4">從Excel導入字卡</h2>

                <div id="excelImportSteps" class="overflow-y-auto">
                    <!-- 步驟1: 選擇文件 -->
                    <div id="excelStep1" class="space-y-4">
                        <div class="border-2 border-dashed border-gray-300 dark:border-gray-700 p-6 rounded-lg text-center">
                            <div class="mb-4">
                                <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-12 w-12 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                                </svg>
                            </div>
                            <p class="mb-4 text-gray-600 dark:text-gray-400">選擇Excel檔案（.xls或.xlsx）</p>
                            <p class="mb-4 text-sm text-gray-500 dark:text-gray-500">Excel第一列應為表頭，第二列開始為字卡數據。<br>至少需要兩列：第一列為正面內容，第二列為背面內容。<br>多個工作表將被識別為不同卡組。</p>
                            <div>
                                <label for="excelFileInput" class="bg-primary hover:bg-opacity-80 text-white px-4 py-2 rounded-lg cursor-pointer">
                                    選擇檔案
                                    <input type="file" id="excelFileInput" accept=".xls,.xlsx" class="hidden" />
                                </label>
                            </div>
                            <div id="excelFileName" class="mt-4 text-sm text-gray-500 dark:text-gray-500 hidden"></div>
                        </div>

                        <div class="mt-4 flex justify-between">
                            <button id="downloadExcelTemplateBtn" class="text-primary hover:underline text-sm">
                                下載Excel範本
                            </button>
                            <div>
                                <button id="closeImportExcelBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg mr-2">
                                    取消
                                </button>
                                <button id="nextToPreviewBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg" disabled>
                                    下一步
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 步驟2: 預覽和設置 -->
                    <div id="excelStep2" class="space-y-4 hidden">
                        <div class="mb-4 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <h3 class="font-medium mb-2">工作表</h3>
                            <div id="sheetTabsContainer" class="mb-2 flex flex-wrap">
                                <!-- 工作表選項卡將在這裡動態添加 -->
                            </div>
                        </div>

                        <div class="border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <h3 class="font-medium mb-2">預覽數據</h3>
                            <div class="overflow-x-auto">
                                <table class="min-w-full divide-y divide-gray-300 dark:divide-gray-700">
                                    <thead id="excelPreviewHead" class="bg-gray-100 dark:bg-gray-800">
                                        <!-- Excel表頭數據會動態添加到這裡 -->
                                    </thead>
                                    <tbody id="excelPreviewBody" class="divide-y divide-gray-200 dark:divide-gray-800">
                                        <!-- Excel預覽數據會動態添加到這裡 -->
                                    </tbody>
                                </table>
                            </div>
                            <p id="excelRowCount" class="text-sm text-gray-500 dark:text-gray-500 mt-2"></p>
                        </div>

                        <div class="border border-gray-300 dark:border-gray-700 rounded-lg p-4">
                            <h3 class="font-medium mb-2">設置欄位映射</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div>
                                    <label class="block text-sm font-medium mb-1">正面 (問題)</label>
                                    <select id="frontColumnSelect" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                                        <!-- 欄位選項會動態添加到這裡 -->
                                    </select>
                                </div>
                                <div>
                                    <label class="block text-sm font-medium mb-1">背面 (答案)</label>
                                    <select id="backColumnSelect" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                                        <!-- 欄位選項會動態添加到這裡 -->
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="border border-gray-300 dark:border-gray-700 rounded-lg p-4">
                            <h3 class="font-medium mb-2">設置工作表映射</h3>
                            <div id="sheetMappingContainer" class="space-y-4">
                                <!-- 工作表映射選項將在這裡動態添加 -->
                            </div>
                        </div>

                        <div class="mt-4 flex justify-between">
                            <button id="backToFileBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                                上一步
                            </button>
                            <button id="importExcelDataBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                                匯入數據
                            </button>
                        </div>
                    </div>

                    <!-- 步驟3: 匯入結果 -->
                    <div id="excelStep3" class="space-y-4 hidden">
                        <div id="importResults" class="border border-gray-300 dark:border-gray-700 rounded-lg p-4">
                            <!-- 匯入結果會動態添加到這裡 -->
                        </div>

                        <div class="mt-4 flex justify-between">
                            <button id="importNewFileBtn" class="px-4 py-2 bg-gray-500 hover:bg-gray-600 text-white font-semibold rounded-lg transition-colors">
                                導入新檔案
                            </button>
                            <button id="finishImportBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white font-semibold rounded-lg transition-colors">
                                完成
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 導出Excel對話框 -->
        <div id="exportExcelModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">導出Excel</h2>
                <div class="space-y-4">
                    <div>
                        <label for="exportExcelFilenameInput" class="block text-sm font-medium mb-1">檔案名稱</label>
                        <input type="text" id="exportExcelFilenameInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" value="flashcards" />
                    </div>

                    <!-- Deck selection section -->
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label class="block text-sm font-medium">選擇要導出的卡組</label>
                            <div class="flex space-x-2">
                                <button id="selectAllExportExcelDecksBtn" class="text-xs text-primary hover:underline">全選</button>
                                <button id="deselectAllExportExcelDecksBtn" class="text-xs text-primary hover:underline">取消全選</button>
                            </div>
                        </div>
                        <div id="exportExcelDecksList" class="max-h-60 overflow-y-auto space-y-2 border border-gray-300 dark:border-gray-700 rounded-lg p-2">
                            <!-- Deck checkboxes will be added here dynamically -->
                            <div class="text-center py-4 text-gray-500 dark:text-gray-400">
                                沒有可用的卡組。
                            </div>
                        </div>
                    </div>

                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="cancelExportExcelBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="confirmExportExcelBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            導出
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Google Sheets 導入衝突解決對話框 -->
                <div id="gSheetsConflictModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-[51] overflow-y-auto py-10">
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-2xl w-full mx-4 my-auto">
                        <h2 class="text-xl font-semibold mb-4">Google Sheets 導入 - 名稱衝突</h2>
                        <p class="text-sm text-gray-600 dark:text-gray-400 mb-4">
                            以下從 Google Sheets 讀取到的工作表名稱，與您現有的卡組名稱重複。請為每個衝突選擇處理方式：
                        </p>
                        <div id="gSheetsConflictList" class="space-y-4 max-h-[60vh] overflow-y-auto pr-2 mb-4">
                            <!-- 衝突列表將在此處動態生成 -->
                            <!-- 範例條目:
                            <div class="p-3 border rounded-md">
                                <h3 class="font-medium">工作表: "重複的名稱"</h3>
                                <p class="text-sm text-gray-500">與現有卡組 "重複的名稱" (ID: xxx) 衝突。</p>
                                <div class="mt-2 space-y-1">
                                    <label class="flex items-center"><input type="radio" name="conflict-sheetName" value="overwrite" class="mr-2"> 覆蓋現有卡組</label>
                                    <label class="flex items-center"><input type="radio" name="conflict-sheetName" value="rename" checked class="mr-2"> 自動重命名 (例如: 重複的名稱 (1))</label>
                                    <label class="flex items-center"><input type="radio" name="conflict-sheetName" value="merge" class="mr-2"> 合併到現有卡組</label>
                                    <label class="flex items-center"><input type="radio" name="conflict-sheetName" value="skip" class="mr-2"> 跳過此工作表</label>
                                </div>
                            </div>
                            -->
                        </div>
                        <div class="flex justify-end space-x-3 pt-4 border-t border-gray-200 dark:border-gray-700">
                            <button id="cancelGSheetsConflictBtn" type="button" class="modal-btn px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                                取消導入
                            </button>
                            <button id="confirmGSheetsConflictBtn" type="button" class="modal-btn px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                                套用選擇並繼續
                            </button>
                        </div>
                    </div>
                </div>

        <!-- 自定義確認對話框 -->
        <div id="customConfirmModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full mx-4">
                <h3 class="text-lg font-medium mb-4" id="confirmModalTitle">確認操作</h3>
                <p id="confirmModalMessage" class="mb-6">您確定要執行此操作嗎？</p>
                <div class="flex justify-end space-x-3">
                    <button id="confirmModalCancelBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                        取消
                    </button>
                    <button id="confirmModalConfirmBtn" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg">
                        確認
                    </button>
                </div>
            </div>
        </div>

        <!-- Google Sheets 導入對話框 -->
        <div id="importGSheetsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50 overflow-y-auto py-10">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-3xl w-full mx-4 my-auto">
                <h2 class="text-xl font-semibold mb-4">從 Google Sheets 導入字卡</h2>
                <!-- 添加 API Key 狀態和清除按鈕 -->
                <div class="flex justify-between items-center mb-2 text-sm bg-gray-100 dark:bg-gray-700 p-2 rounded">
                    <div>
                        <span class="font-medium">API Key 狀態:</span>
                        <span id="apiKeyStatus" class="ml-2">
                            <span class="text-green-600 dark:text-green-400" id="apiKeyPresent">已設定</span>
                            <span class="text-yellow-600 dark:text-yellow-400 hidden" id="apiKeyMissing">未設定 (無法同步粗體、底線、對齊、隔行等設置)</span>
                        </span>
                    </div>
                    <div class="flex space-x-2">
                        <button id="apiSettingsBtn" type="button" class="text-blue-500 hover:text-blue-700 text-xs bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">
                            設置 API Key
                        </button>
                        <button id="clearApiKeyBtn" type="button" class="text-red-500 hover:text-red-700 text-xs bg-gray-200 dark:bg-gray-600 px-2 py-1 rounded">
                            清除 API Key
                        </button>
                    </div>
                </div>

                <div id="gSheetsImportSteps" class="overflow-y-auto">
                    <!-- 步驟1: 輸入 Google Sheets URL -->
                    <div id="gSheetsStep1" class="space-y-4">
                        <p class="mb-4 text-gray-600 dark:text-gray-400">請輸入已共享的 Google Sheets URL</p>
                        <p class="text-sm text-gray-500 dark:text-gray-500 mb-4">
                            注意：Google Sheets 必須設置為「任何人都可以查看」，並請確保第一列為標題行
                        </p>
                        <div class="space-y-2">
                            <label for="gSheetsUrlInput" class="block text-sm font-medium">Google Sheets URL</label>
                            <input type="text" id="gSheetsUrlInput" placeholder="例如：https://docs.google.com/spreadsheets/d/..."
                                   class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                        </div>

                        <div class="flex items-center mt-4">
                            <input type="checkbox" id="enableSyncGSheets" class="mr-2">
                            <label for="enableSyncGSheets" class="text-sm">
                                保持同步（當 Google Sheets 更新時自動更新字卡）
                            </label>
                        </div>

                        <div class="mt-6 flex justify-between">
                            <div>
                                <a href="https://support.google.com/docs/answer/183965" target="_blank" class="text-primary hover:underline text-sm">
                                    如何共享 Google Sheets?
                                </a>
                            </div>
                            <div>
                                <button id="closeGSheetsModalBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg mr-2">
                                    取消
                                </button>
                                <button id="loadGSheetsBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                                    載入
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- 步驟2: 預覽和設置 (類似 Excel 導入) -->
                    <div id="gSheetsStep2" class="space-y-4 hidden">
                        <!-- 與 Excel 預覽部分類似的結構 -->
                        <div id="formatStatusIndicator" class="mb-4 p-2 bg-gray-100 dark:bg-gray-700 rounded-lg text-sm">
                            <span id="formatStatus" class="font-medium">格式狀態：</span>
                            <span id="formatStatusValue">載入中...</span>
                        </div>
                    </div>

                    <!-- 步驟3: 導入結果 -->
                    <div id="gSheetsStep3" class="space-y-4 hidden">
                        <!-- 與 Excel 結果部分類似的結構 -->
                    </div>
                </div>
            </div>
        </div>
        <!-- 在文件底部，其他對話框之後添加這個 -->
        <div id="apiSettingsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
            <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                <h2 class="text-xl font-semibold mb-4">API設置</h2>
                <div class="space-y-4">
                    <div>
                        <label for="googleApiKeyInput" class="block text-sm font-medium mb-1">Google API密鑰</label>
                        <input type="password" id="googleApiKeyInput" class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 text-base" />
                        <div class="flex items-center mt-1">
                            <input type="checkbox" id="showApiKey" class="mr-2">
                            <label for="showApiKey" class="text-sm">顯示密鑰</label>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">API密鑰用於訪問Google Sheets API，提供格式化數據。密鑰會安全地存儲在您的瀏覽器中。</p>
                    </div>
                    <div class="bg-blue-50 dark:bg-blue-900/30 p-3 rounded-lg text-sm">
                        <h3 class="font-medium text-blue-700 dark:text-blue-400">如何獲取Google API密鑰</h3>
                        <ol class="list-decimal list-inside mt-2 space-y-1 text-blue-600 dark:text-blue-300">
                            <li>訪問 <a href="https://console.cloud.google.com/" target="_blank" class="underline">Google Cloud Console</a></li>
                            <li>創建一個新項目</li>
                            <li>啟用 Google Sheets API</li>
                            <li>創建API密鑰 (憑證 → 創建憑證 → API密鑰)</li>
                            <li>複製API密鑰並粘貼到上面的輸入框</li>
                        </ol>
                    </div>
                    <div class="flex justify-end space-x-3 pt-4">
                        <button id="closeApiSettingsBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-700 hover:bg-gray-400 dark:hover:bg-gray-600 rounded-lg">
                            取消
                        </button>
                        <button id="saveApiSettingsBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                            保存
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Check for dark mode preference
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Quill editors
        let frontQuill = null;
        let backQuill = null;
        let editFrontQuill = null;
        let editBackQuill = null;

        // Initialize app state
        let currentCardIndex = 0;
        let cardsToReview = [];
        let currentDeck = null;
        let currentMode = null;
        let drillReviewedCount = 0; // Count of reviewed cards in drill mode
        let drillTimers = []; // Store timers for drill mode
        let reviewCycleCount = 0; // Count cycles of review
        let sidesFlipped = false; // Track if card sides are flipped during review

        // In-memory storage for cards and decks
        let cardsData = [];
        let decksData = [];

        // Selected cards for batch operations
        let selectedCardIds = new Set();

        // Selected deck IDs for creating cards
        let selectedDeckIds = [];

        // Selected deck IDs for batch operations
        let selectedDeckIds2 = new Set();

        // Selected deck IDs for export
        let selectedExportDeckIds = [];

        // Selected deck IDs for Excel export
        let selectedExportExcelDeckIds = [];

        // Import data temporary storage
        let importDataCache = null;
        let selectedImportDeckIds = [];

        // Excel導入功能變量
        let excelData = null;
        let excelColumns = [];
        let excelFileName = '';
        let editingFolderId = null;

        // Excel 多工作表導入變量
        let excelSheets = {}; // 保存所有工作表的數據
        let activeSheetName = ''; // 當前活動的工作表名稱
        let sheetMappings = {}; // 工作表到卡組的映射
        let sheetOptions = {}; // 每個工作表的列映射選項

        // Sorting preferences
        let deckSortPreference = 'name';
        let manageDeckSortPreference = 'name';

        // Image upload related variables
        let frontImageData = null;
        let backImageData = null;
        let editFrontImageData = null;
        let editBackImageData = null;

        // For editing
        let editingCardId = null;
        let editingDeckId = null;

        // For storage reminder
        let reminderShown = false;

        // Global variables for sorting in manage cards table
        let cardSortKey = 'frontText'; // Default sort key
        let cardSortOrder = 'asc';     // Default sort order ('asc' or 'desc')

        // Google Sheets 導入衝突解決方案
        let gSheetsConflictResolutions = {};


        // DOM Elements - Sections
        const reviewSection = document.getElementById('reviewSection');
        const createCardSection = document.getElementById('createCardSection');
        const manageCardSection = document.getElementById('manageCardSection');
        const manageDeckSection = document.getElementById('manageDeckSection');

        // DOM Elements - Navigation
        const reviewBtn = document.getElementById('reviewBtn');
        const createCardBtn = document.getElementById('createCardBtn');
        const manageCardBtn = document.getElementById('manageCardBtn');
        const manageDeckBtn = document.getElementById('manageDeckBtn');
        const createFirstDeckLink = document.getElementById('createFirstDeckLink');

        // DOM Elements - Storage Reminder
        const storageReminder = document.getElementById('storageReminder');
        const exportReminderBtn = document.getElementById('exportReminderBtn');
        const dismissReminderBtn = document.getElementById('dismissReminderBtn');

        // DOM Elements - Import/Export
        const exportDataBtn = document.getElementById('exportDataBtn');
        const importDataInput = document.getElementById('importDataInput');
        const exportModal = document.getElementById('exportModal');
        const exportFilenameInput = document.getElementById('exportFilenameInput');
        const cancelExportBtn = document.getElementById('cancelExportBtn');
        const confirmExportBtn = document.getElementById('confirmExportBtn');
        const exportDecksList = document.getElementById('exportDecksList');
        const selectAllExportDecksBtn = document.getElementById('selectAllExportDecksBtn');
        const deselectAllExportDecksBtn = document.getElementById('deselectAllExportDecksBtn');

        // DOM Elements - Export Excel
        const exportExcelBtn = document.getElementById('exportExcelBtn');
        const exportExcelModal = document.getElementById('exportExcelModal');
        const exportExcelFilenameInput = document.getElementById('exportExcelFilenameInput');
        const exportExcelDecksList = document.getElementById('exportExcelDecksList');
        const selectAllExportExcelDecksBtn = document.getElementById('selectAllExportExcelDecksBtn');
        const deselectAllExportExcelDecksBtn = document.getElementById('deselectAllExportExcelDecksBtn');
        const cancelExportExcelBtn = document.getElementById('cancelExportExcelBtn');
        const confirmExportExcelBtn = document.getElementById('confirmExportExcelBtn');

        // DOM Elements - Import Preview
        const importPreviewModal = document.getElementById('importPreviewModal');
        const importDecksList = document.getElementById('importDecksList');
        const selectAllImportDecksBtn = document.getElementById('selectAllImportDecksBtn');
        const deselectAllImportDecksBtn = document.getElementById('deselectAllImportDecksBtn');
        const cancelImportBtn = document.getElementById('cancelImportBtn');
        const confirmImportBtn = document.getElementById('confirmImportBtn');

        // DOM Elements - Sorting
        const deckSortSelect = document.getElementById('deckSortSelect');
        const manageDeckSortSelect = document.getElementById('manageDeckSortSelect');

        // DOM Elements - Search
        const deckSearchInput = document.getElementById('deckSearchInput');
        const cardSearchInput = document.getElementById('cardSearchInput');
        const manageDeckSearchInput = document.getElementById('manageDeckSearchInput');

        // DOM Elements - Create Card Deck Selection
        const noDeckWarning = document.getElementById('noDeckWarning');
        const createNewDeckBtn = document.getElementById('createNewDeckBtn');
        const deckSelectionForCard = document.getElementById('deckSelectionForCard');
        const selectedDecks = document.getElementById('selectedDecks');
        const selectedDecksPlaceholder = document.getElementById('selectedDecksPlaceholder');
        const toggleDeckDropdown = document.getElementById('toggleDeckDropdown');
        const deckOptions = document.getElementById('deckOptions');

        // DOM Elements - Review
        const deckSelection = document.getElementById('deckSelection');
        const modeSelection = document.getElementById('modeSelection');
        const reviewInterface = document.getElementById('reviewInterface');
        const currentDeckName = document.getElementById('currentDeckName');
        const currentModeName = document.getElementById('currentModeName');
        const flipSidesBtn = document.getElementById('flipSidesBtn');
        const exitReviewBtn = document.getElementById('exitReviewBtn');
        const reviewCard = document.getElementById('reviewCard');
        const reviewCompleteMessage = document.getElementById('reviewCompleteMessage');
        const restartDeckBtn = document.getElementById('restartDeckBtn');
        const backToDeckSelectionBtn = document.getElementById('backToDeckSelectionBtn');
        const deckList = document.getElementById('deckList');

        // DOM Elements - Card elements
        const cardFront = document.getElementById('cardFront');
        const cardBack = document.getElementById('cardBack');
        const frontText = document.getElementById('frontText');
        const backText = document.getElementById('backText');
        const frontImage = document.getElementById('frontImage');
        const backImage = document.getElementById('backImage');
        const flipBtn = document.getElementById('flipBtn');
        const ratingButtons = document.getElementById('ratingButtons');

        // DOM Elements - Create Card
        const cardForm = document.getElementById('cardForm');
        const frontEditor = document.getElementById('frontEditor');
        const backEditor = document.getElementById('backEditor');
        const cardFrontImageInput = document.getElementById('cardFrontImage');
        const cardBackImageInput = document.getElementById('cardBackImage');
        const frontImageBtn = document.getElementById('frontImageBtn');
        const backImageBtn = document.getElementById('backImageBtn');
        const frontImageName = document.getElementById('frontImageName');
        const backImageName = document.getElementById('backImageName');
        const frontImagePreview = document.getElementById('frontImagePreview');
        const backImagePreview = document.getElementById('backImagePreview');
        const frontPreviewImg = document.getElementById('frontPreviewImg');
        const backPreviewImg = document.getElementById('backPreviewImg');
        const removeFrontImage = document.getElementById('removeFrontImage');
        const removeBackImage = document.getElementById('removeBackImage');

        // DOM Elements - Manage Cards
        const allCardsContainer = document.getElementById('allCardsContainer');
        const selectAllCards = document.getElementById('selectAllCards');
        const selectedCardCount = document.getElementById('selectedCardCount');
        const deleteBatchCardsBtn = document.getElementById('deleteBatchCardsBtn');
        const deleteAllCardsBtn = document.getElementById('deleteAllCardsBtn');
        const deckFilterSelect = document.getElementById('deckFilterSelect');

        // DOM Elements - Manage Decks
        const allDecksContainer = document.getElementById('allDecksContainer');
        const deleteAllDecksBtn = document.getElementById('deleteAllDecksBtn');
        const addDeckInManageBtn = document.getElementById('addDeckInManageBtn');
        const selectAllDecks = document.getElementById('selectAllDecks');
        const selectedDeckCount = document.getElementById('selectedDeckCount');
        const deleteBatchDecksBtn = document.getElementById('deleteBatchDecksBtn');

        // DOM Elements - Card Edit Modal
        const cardEditModal = document.getElementById('cardEditModal');
        const editFrontEditor = document.getElementById('editFrontEditor');
        const editBackEditor = document.getElementById('editBackEditor');
        const editCardFrontImage = document.getElementById('editCardFrontImage');
        const editCardBackImage = document.getElementById('editCardBackImage');
        const editFrontImagePreview = document.getElementById('editFrontImagePreview');
        const editBackImagePreview = document.getElementById('editBackImagePreview');
        const editFrontPreviewImg = document.getElementById('editFrontPreviewImg');
        const editBackPreviewImg = document.getElementById('editBackPreviewImg');
        const removeEditFrontImage = document.getElementById('removeEditFrontImage');
        const removeEditBackImage = document.getElementById('removeEditBackImage');
        const editCardDecksList = document.getElementById('editCardDecksList');
        const closeCardEditBtn = document.getElementById('closeCardEditBtn');
        const saveCardEditBtn = document.getElementById('saveCardEditBtn');

        // DOM Elements - Deck Edit Modal
        const deckEditModal = document.getElementById('deckEditModal');
        const editDeckNameInput = document.getElementById('editDeckNameInput');
        const editDeckDescriptionInput = document.getElementById('editDeckDescriptionInput');
        const deckCardsList = document.getElementById('deckCardsList');
        const availableCardsList = document.getElementById('availableCardsList');
        const closeDeckEditBtn = document.getElementById('closeDeckEditBtn');
        const saveDeckEditBtn = document.getElementById('saveDeckEditBtn');

        // DOM Elements - New Deck Modal
        const newDeckModal = document.getElementById('newDeckModal');
        const newDeckNameInput = document.getElementById('newDeckNameInput');
        const newDeckDescriptionInput = document.getElementById('newDeckDescriptionInput');
        const closeNewDeckBtn = document.getElementById('closeNewDeckBtn');
        const saveNewDeckBtn = document.getElementById('saveNewDeckBtn');

        // DOM Elements - Merge Decks
        const mergeBatchDecksBtn = document.getElementById('mergeBatchDecksBtn');
        const mergeSelectedDeckCount = document.getElementById('mergeSelectedDeckCount');
        const mergeDeckModal = document.getElementById('mergeDeckModal');
        const mergedDeckNameInput = document.getElementById('mergedDeckNameInput');
        const mergeCount = document.getElementById('mergeCount');
        const closeMergeDeckBtn = document.getElementById('closeMergeDeckBtn');
        const saveMergeDeckBtn = document.getElementById('saveMergeDeckBtn');

        // DOM Elements - Excel Import
        const importExcelBtn = document.getElementById('importExcelBtn');
        const importExcelModal = document.getElementById('importExcelModal');
        const closeImportExcelBtn = document.getElementById('closeImportExcelBtn');
        const excelFileInput = document.getElementById('excelFileInput');
        const excelFileNameDisplay = document.getElementById('excelFileName');
        const nextToPreviewBtn = document.getElementById('nextToPreviewBtn');
        const downloadExcelTemplateBtn = document.getElementById('downloadExcelTemplateBtn');

        // Excel Import Multi-Sheet Elements
        const sheetTabsContainer = document.getElementById('sheetTabsContainer');
        const sheetMappingContainer = document.getElementById('sheetMappingContainer');

        const excelStep1 = document.getElementById('excelStep1');
        const excelStep2 = document.getElementById('excelStep2');
        const excelStep3 = document.getElementById('excelStep3');
        const backToFileBtn = document.getElementById('backToFileBtn');
        const importExcelDataBtn = document.getElementById('importExcelDataBtn');
        const finishImportBtn = document.getElementById('finishImportBtn');

        const excelPreviewHead = document.getElementById('excelPreviewHead');
        const excelPreviewBody = document.getElementById('excelPreviewBody');
        const excelRowCount = document.getElementById('excelRowCount');
        const frontColumnSelect = document.getElementById('frontColumnSelect');
        const backColumnSelect = document.getElementById('backColumnSelect');
        const targetExistingDeck = document.getElementById('targetExistingDeck');
        const existingDeckSelector = document.getElementById('existingDeckSelector');
        const newDeckInputs = document.getElementById('newDeckInputs');
        const newDeckName = document.getElementById('newDeckName');
        const newDeckDescription = document.getElementById('newDeckDescription');
        const importResults = document.getElementById('importResults');

        // Google Sheets 相關函數 - 移至全局作用域

        // 初始化 Google Sheets 導入功能
        function initGSheetsImport() {
            // 獲取元素
            const importGSheetsBtn = document.getElementById('importGSheetsBtn');
            const importGSheetsModal = document.getElementById('importGSheetsModal');
            const closeGSheetsModalBtn = document.getElementById('closeGSheetsModalBtn');
            const loadGSheetsBtn = document.getElementById('loadGSheetsBtn');
            const gSheetsUrlInput = document.getElementById('gSheetsUrlInput');

            // 綁定事件
            importGSheetsBtn.addEventListener('click', openGSheetsImportModal);
            closeGSheetsModalBtn.addEventListener('click', closeGSheetsImportModal);
            loadGSheetsBtn.addEventListener('click', loadGSheetsData);

            // 添加清除 API Key 按鈕功能
            const clearApiKeyBtn = document.getElementById('clearApiKeyBtn');
            const apiKeyPresent = document.getElementById('apiKeyPresent');
            const apiKeyMissing = document.getElementById('apiKeyMissing');

            // 顯示 API Key 狀態
            function updateApiKeyStatus() {
                if (GOOGLE_API_KEY) {
                    apiKeyPresent.classList.remove('hidden');
                    apiKeyMissing.classList.add('hidden');
                } else {
                    apiKeyPresent.classList.add('hidden');
                    apiKeyMissing.classList.remove('hidden');
                }
            }

            // 初始更新狀態
            updateApiKeyStatus();

            // 清除按鈕處理函數
            clearApiKeyBtn.addEventListener('click', function() {
                // 清除本地存儲中的 API Key
                localStorage.removeItem('google_api_key');

                // 清除內存中的 API Key
                GOOGLE_API_KEY = '';

                // 更新狀態顯示
                updateApiKeyStatus();

                // 顯示通知
                showNotification('Google API Key 已清除');
            });

            // 點擊對話框外部關閉
            importGSheetsModal.addEventListener('click', function(e) {
                if (e.target === importGSheetsModal) {
                    closeGSheetsImportModal();
                }
            });

            // 顯示 API 密鑰狀態
            if (GOOGLE_API_KEY) {
                console.log('Google API 密鑰已配置，將支持格式同步');
            } else {
                console.log('未配置 Google API 密鑰，將使用純文本方式同步');

                // 可選：添加一個提示鏈接
                const apiKeyLink = document.createElement('div');
                apiKeyLink.className = 'mt-2 text-xs text-primary hover:underline cursor-pointer';
                apiKeyLink.textContent = '如何獲取 Google API 密鑰以支持格式同步？';
                apiKeyLink.addEventListener('click', () => {
                    window.open('https://developers.google.com/sheets/api/guides/authorizing#APIKey', '_blank');
                });

                // 將鏈接添加到導入對話框
                const gSheetsStep1 = document.getElementById('gSheetsStep1');
                if (gSheetsStep1) {
                    const linkContainer = gSheetsStep1.querySelector('div.mt-6 div:first-child');
                    if (linkContainer) {
                        linkContainer.appendChild(apiKeyLink);
                    }
                }
            }
        }

        // Base64圖片檢測和處理函數
        function isBase64Image(str) {
          if (typeof str !== 'string') return false;
          // 檢查是否符合base64圖片格式前綴
          if (str.startsWith('data:image/')) {
            return true;
          }

          // 檢查是否是沒有前綴的base64編碼
          try {
            // base64字符串通常有特定的模式和長度
            const base64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
            // 要求base64字符串至少有一定長度才被視為圖片
            return str.length > 100 && base64Regex.test(str);
          } catch (e) {
            return false;
          }
        }

        // 確保base64字符串有正確的數據頭
        function ensureBase64Prefix(base64Str) {
          if (base64Str.startsWith('data:image/')) {
            return base64Str;
          }

          // 嘗試檢測圖片類型(簡單處理為JPEG)
          return `data:image/jpeg;base64,${base64Str}`;
        }

        // 處理導入的內容，檢測並處理base64圖片
        function processImportedContent(content) {
          if (!content) return { text: '', image: null };

          if (typeof content !== 'string') {
            content = content.toString();
          }

          if (isBase64Image(content)) {
            return {
              text: '',
              image: ensureBase64Prefix(content)
            };
          }

          return {
            text: content,
            image: null
          };
          saveDataToLocalStorage();
        }

        function initApiSettings() {
            const apiSettingsBtn = document.getElementById('apiSettingsBtn');
            const apiSettingsModal = document.getElementById('apiSettingsModal');
            const closeApiSettingsBtn = document.getElementById('closeApiSettingsBtn');
            const saveApiSettingsBtn = document.getElementById('saveApiSettingsBtn');
            var googleApiKeyInput = document.getElementById('googleApiKeyInput');
            const showApiKey = document.getElementById('showApiKey');

            // 添加這個函數用於更新API密鑰狀態顯示
            function updateApiKeyStatus() {
                const apiKeyPresent = document.getElementById('apiKeyPresent');
                const apiKeyMissing = document.getElementById('apiKeyMissing');

                if (GOOGLE_API_KEY) {
                    apiKeyPresent.classList.remove('hidden');
                    apiKeyMissing.classList.add('hidden');
                    apiKeyPresent.textContent = '已設定';
                } else {
                    apiKeyPresent.classList.add('hidden');
                    apiKeyMissing.classList.remove('hidden');
                }
            }

            // 檢查設置按鈕是否存在（不影響其他功能）
            if (!apiSettingsBtn) {
                console.warn('找不到 apiSettingsBtn 元素，跳過設置按鈕綁定');
                // 繼續執行，而不是返回
            } else {
              // 設置按鈕點擊事件
              apiSettingsBtn.addEventListener('click', () => {
                  // 載入當前API密鑰到輸入框
                  googleApiKeyInput.value = GOOGLE_API_KEY || '';

                  // 更新初始狀態顯示
                  updateApiKeyStatus(); // 這裡使用上面定義的函數

                  apiSettingsModal.classList.remove('hidden');
              });
            }

            // 檢查設置按鈕是否存在（不影響其他功能）
            if (!apiSettingsBtn) {
                console.warn('找不到 apiSettingsBtn 元素，跳過設置按鈕綁定');
                // 繼續執行，而不是返回
            } else {
              // 設置按鈕點擊事件
              apiSettingsBtn.addEventListener('click', () => {
                  // 載入當前API密鑰到輸入框
                  googleApiKeyInput.value = GOOGLE_API_KEY || '';

                  // 更新初始狀態顯示
                  const apiKeyPresent = document.getElementById('apiKeyPresent');
                  const apiKeyMissing = document.getElementById('apiKeyMissing');

                  if (GOOGLE_API_KEY) {
                      apiKeyPresent.classList.remove('hidden');
                      apiKeyMissing.classList.add('hidden');
                      apiKeyPresent.textContent = '已設定';
                  } else {
                      apiKeyPresent.classList.add('hidden');
                      apiKeyMissing.classList.remove('hidden');
                  }

                  apiSettingsModal.classList.remove('hidden');
              });
            }

            // 確保元素存在後再添加事件監聽器
            let tempGoogleApiKeyInput = document.getElementById('googleApiKeyInput');
            if (tempGoogleApiKeyInput) {
                tempGoogleApiKeyInput.addEventListener('input', function() {
                    // 獲取當前輸入的值
                    const currentInputValue = this.value.trim();

                    // 獲取狀態顯示元素
                    const apiKeyPresent = document.getElementById('apiKeyPresent');
                    const apiKeyMissing = document.getElementById('apiKeyMissing');

                    if (apiKeyPresent && apiKeyMissing) {
                        // 根據輸入值更新顯示
                        if (currentInputValue) {
                            apiKeyPresent.classList.remove('hidden');
                            apiKeyMissing.classList.add('hidden');
                            // 添加"未保存"提示
                            apiKeyPresent.textContent = '已輸入 (尚未保存)';
                        } else {
                            apiKeyPresent.classList.add('hidden');
                            apiKeyMissing.classList.remove('hidden');
                        }
                    }
                });
            }

            // 檢查必要的元素
            if (!apiSettingsModal || !closeApiSettingsBtn || !saveApiSettingsBtn || !googleApiKeyInput) {
                console.error('API設置模態框缺少必要元素，無法完成初始化');
                return;
            }

            // 關閉按鈕點擊事件
            closeApiSettingsBtn.addEventListener('click', () => {
                apiSettingsModal.classList.add('hidden');
            });

            // 保存按鈕點擊事件
            saveApiSettingsBtn.addEventListener('click', () => {
                const newApiKey = googleApiKeyInput.value.trim();

                // 保存API密鑰
                GOOGLE_API_KEY = newApiKey;
                localStorage.setItem('google_api_key', newApiKey);

                // 更新狀態顯示
                updateApiKeyStatus(); // 這裡使用上面定義的函數

                // 顯示確認
                showNotification('API設置已保存');

                // 關閉對話框
                apiSettingsModal.classList.add('hidden');

                // 返回到Google Sheets URL輸入畫面
                showGSheetsStep(1);
            });

            // 顯示/隱藏密鑰切換
            if (showApiKey) {
                showApiKey.addEventListener('change', () => {
                    googleApiKeyInput.type = showApiKey.checked ? 'text' : 'password';
                });
            }

            // 點擊對話框外部關閉
            apiSettingsModal.addEventListener('click', (e) => {
                if (e.target === apiSettingsModal) {
                    apiSettingsModal.classList.add('hidden');
                }
            });
        }

        // 打開 Google Sheets 導入對話框
        function openGSheetsImportModal() {
            const importGSheetsModal = document.getElementById('importGSheetsModal');
            importGSheetsModal.classList.remove('hidden');

            // 重置表單
            document.getElementById('gSheetsUrlInput').value = '';
            document.getElementById('enableSyncGSheets').checked = false;

            // 顯示第一步
            showGSheetsStep(1);
        }

        // 關閉 Google Sheets 導入對話框
        function closeGSheetsImportModal() {
            const importGSheetsModal = document.getElementById('importGSheetsModal');
            importGSheetsModal.classList.add('hidden');
        }

        // 顯示指定的 Google Sheets 導入步驟
        function showGSheetsStep(step) {
            document.getElementById('gSheetsStep1').classList.add('hidden');
            document.getElementById('gSheetsStep2').classList.add('hidden');
            document.getElementById('gSheetsStep3').classList.add('hidden');

            document.getElementById(`gSheetsStep${step}`).classList.remove('hidden');
        }

        // 從 Google Sheets 載入數據
                function loadGSheetsData() {
                    // 檢查是否設置了API密鑰
                    if (!GOOGLE_API_KEY) {
                        // 提示用戶設置API密鑰
                        showNotification('請先設置Google API密鑰');

                        // 自動打開API設置對話框
                        const apiSettingsModal = document.getElementById('apiSettingsModal');
                        if (apiSettingsModal) {
                            apiSettingsModal.classList.remove('hidden');

                            // 聚焦到API密鑰輸入框
                            var googleApiKeyInput = document.getElementById('googleApiKeyInput');
                            if (googleApiKeyInput) {
                                googleApiKeyInput.focus();
                            }
                        }

                        return;
                    }
                                const gSheetsUrl = document.getElementById('gSheetsUrlInput').value.trim();
                    const enableSync = document.getElementById('enableSyncGSheets').checked;

                    if (!gSheetsUrl) {
                        showNotification('請輸入 Google Sheets URL');
                        return;
                    }

                    // 驗證 URL 格式
                    if (!isValidGSheetsUrl(gSheetsUrl)) {
                        showNotification('請輸入有效的 Google Sheets URL');
                        return;
                    }

                    var googleApiKeyInput = document.getElementById('googleApiKeyInput');
                    if (!googleApiKeyInput) {
                        console.warn('找不到 googleApiKeyInput 元素');
                        return; // 如果元素不存在，退出函數
                    }

                    // 添加輸入事件監聽器，即時更新狀態顯示
                    googleApiKeyInput.addEventListener('input', function() {
                        // 獲取當前輸入的值
                        const currentInputValue = this.value.trim();

                        // 獲取狀態顯示元素
                        const apiKeyPresent = document.getElementById('apiKeyPresent');
                        const apiKeyMissing = document.getElementById('apiKeyMissing');

                        // 根據輸入值更新顯示
                        if (currentInputValue) {
                            apiKeyPresent.classList.remove('hidden');
                            apiKeyMissing.classList.add('hidden');
                            apiKeyPresent.textContent = '已輸入';
                        } else {
                            apiKeyPresent.classList.add('hidden');
                            apiKeyMissing.classList.remove('hidden');
                        }
                    });

                    // 保存按鈕點擊事件 - 修改保存後的顯示
                    saveApiSettingsBtn.addEventListener('click', () => {
                        const newApiKey = googleApiKeyInput.value.trim();

                        // 保存API密鑰
                        GOOGLE_API_KEY = newApiKey;
                        localStorage.setItem('google_api_key', newApiKey);

                        // 更新狀態顯示 - 確保更新為最終狀態
                        const apiKeyPresent = document.getElementById('apiKeyPresent');
                        if (newApiKey) {
                            apiKeyPresent.textContent = '已設定'; // 更改為最終顯示文字
                        }

                        // 顯示確認
                        showNotification('API設置已保存');

                        // 關閉對話框
                        apiSettingsModal.classList.add('hidden');

                        // 返回到Google Sheets URL輸入畫面
                        showGSheetsStep(1);
                    });

                    // 顯示載入中狀態
                    const loadBtn = document.getElementById('loadGSheetsBtn');
                    const originalText = loadBtn.textContent;
                    loadBtn.disabled = true;
                    loadBtn.innerHTML = '<span class="inline-block animate-spin mr-2">⟳</span> 載入中...';

                    // 從 URL 獲取 spreadsheetId
                    const spreadsheetId = extractSpreadsheetId(gSheetsUrl);

                    // 先嘗試使用 Google API（帶格式），如果失敗則回退到 CSV（無格式）
                    if (GOOGLE_API_KEY) {
                        console.log('使用 Google API 載入格式化數據');
                        loadFormattedGSheetsData(spreadsheetId, gSheetsUrl, enableSync)
                            .then(() => {

                              // 添加自動導入功能
                              setTimeout(() => {
                                // 【關鍵修改】直接導入，不再詢問，並在完成後刷新UI
                                // 處理每個工作表
                                let totalImportCount = 0;

                                Object.keys(excelSheets).forEach(sheetName => {
                                    if (!excelSheets[sheetName]) return;

                                    // 為每個工作表創建新卡組，使用工作表名稱
                                    const newDeck = {
                                        id: Date.now() + Math.floor(Math.random() * 1000),
                                        name: `${sheetName}`,
                                        description: ``,
                                        cardIds: [],
                                        createdAt: Date.now()
                                    };

                                    // 添加卡組
                                    decksData.push(newDeck);

                                    // 處理數據（從第1行開始，跳過標題行）
                                    const sheetData = excelSheets[sheetName].data;
                                    let cardImportCount = 0;

                                    // 獲取此工作表的列配置
                                    const frontCol = sheetOptions[sheetName]?.frontColumn || 0;
                                    const backCol = sheetOptions[sheetName]?.backColumn || 1;

                                    for (let i = 1; i < sheetData.length; i++) {
                                        const row = sheetData[i];
                                        if (!row || !row.length) continue;

                                        // 使用正確的列索引作為正反面
                                        const frontContent = row[frontCol];
                                        const backContent = row[backCol];

                                        // 處理內容，支持格式化和純文本
                                        let frontText, backText;

                                        if (excelSheets[sheetName].hasFormatting) {
                                            // 處理格式化內容
                                            frontText = typeof frontContent === 'object' && frontContent.delta
                                                ? convertDeltaToHTML(frontContent.delta)
                                                : (frontContent ? frontContent.toString() : '');

                                            backText = typeof backContent === 'object' && backContent.delta
                                                ? convertDeltaToHTML(backContent.delta)
                                                : (backContent ? backContent.toString() : '');
                                        } else {
                                            // 處理純文本
                                            frontText = frontContent ? processRawTextForCard(frontContent.toString()) : '';
                                            backText = backContent ? processRawTextForCard(backContent.toString()) : '';
                                        }

                                        // 跳過空行
                                        if (!frontText && !backText) continue;

                                        // 創建新卡片
                                        const getSheetHash = (str) => {
                                            let hash = 0;
                                            for (let i = 0; i < str.length; i++) {
                                                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                                                hash |= 0;
                                            }
                                            return Math.abs(hash);
                                        };
                                        const sheetHash = getSheetHash(sheetName) * 1000;
                                        const newCardId = Date.now() + i + sheetHash + Math.floor(Math.random() * 1000);
                                        const newCard = {
                                            id: newCardId,
                                            frontText: frontText,
                                            backText: backText,
                                            nextReview: Date.now(),
                                            repetitions: 0,
                                            easeFactor: 2.0,
                                            interval: 1.0
                                        };

                                        cardsData.push(newCard);
                                        newDeck.cardIds.push(newCardId);
                                        cardImportCount++;
                                    }
                                    totalImportCount += cardImportCount;
                                });

                                // 導入完成後，調用統一的刷新函數
                                refreshAllViews();

                                // 關閉導入對話框，讓用戶看到更新後的頁面
                                closeGSheetsImportModal();

                              }, 200); // 短暫延遲確保UI反應

                                // 恢復按鈕狀態
                                loadBtn.disabled = false;
                                loadBtn.textContent = originalText;

                            })
                            .catch(error => {
                                console.error('Google Sheets API 錯誤:', error);
                                if (error.message && (
                                    error.message.includes('API key') ||
                                    error.message.includes('invalid key') ||
                                    error.message.includes('unauthorized')
                                )) {
                                    showNotification('Google API密鑰無效，請重新設置');
                                    const apiSettingsModal = document.getElementById('apiSettingsModal');
                                    if (apiSettingsModal) {
                                        apiSettingsModal.classList.remove('hidden');
                                    }
                                } else {
                                    showNotification(`載入失敗: ${error.message}`);
                                }

                                // 恢復按鈕狀態
                                loadBtn.disabled = false;
                                loadBtn.textContent = originalText;
                            });

                    } else {
                        // 使用 CSV 方式（無格式）
                        loadGSheetsDataWithCSV(spreadsheetId, gSheetsUrl, enableSync, loadBtn, originalText);
                    }
                    saveDataToLocalStorage();
                }

        // 使用 CSV 方式載入 Google Sheets 數據（無格式）
        function loadGSheetsDataWithCSV(spreadsheetId, gSheetsUrl, enableSync, loadBtn, originalText) {
          // 处理正面内容，检测 base64 图片
          const processedFront = processImportedContent(frontCell);
          const frontText = processedFront.text;
          const frontImage = processedFront.image;

          // 处理背面内容，检测 base64 图片
          const processedBack = processImportedContent(backCell);
          const backText = processedBack.text;
          const backImage = processedBack.image;

          // 创建新卡片时设置图片内容
          const newCard = {
              id: newCardId,
              frontText: frontText,
              frontImage: frontImage,
              backText: backText,
              backImage: backImage,
              nextReview: Date.now(),
              repetitions: 0,
              easeFactor: 2.0,
              interval: 1.0
          };
            // 構建直接導出 CSV 的 URL
            const exportUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv`;
            console.log('嘗試直接從 URL 載入數據:', exportUrl);

            return new Promise((resolve, reject) => {
                // 首先嘗試直接使用fetch獲取CSV
                fetch(exportUrl, {
                    method: 'GET',
                    credentials: 'omit',  // 避免cookie問題
                    mode: 'cors',         // 嘗試跨域請求
                    cache: 'no-cache'     // 避免緩存問題
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`無法直接訪問Google Sheets，狀態碼: ${response.status}`);
                    }
                    return response.text();
                })
                .then(csvData => {
                    // 處理CSV數據
                    const parsedData = parseCSV(csvData);

                    // 保存 Google Sheets 數據
                    const sheetName = 'GoogleSheet';
                    excelSheets = {};
                    excelSheets[sheetName] = {
                        data: parsedData,
                        columns: parsedData[0] || [],
                        hasFormatting: false
                    };

                    // 設置默認卡組映射
                    sheetMappings = {};
                    sheetMappings[sheetName] = {
                        deckOption: 'new',
                        deckId: '',
                        newDeckName: 'Google Sheets 導入',
                        newDeckDescription: '從 Google Sheets 導入的字卡'
                    };

                    // 設置默認列選擇
                    sheetOptions = {};
                    sheetOptions[sheetName] = {
                        frontColumn: 0,
                        backColumn: 1
                    };

                    // 設置活動工作表
                    activeSheetName = sheetName;

                    // 如果啟用同步，保存 URL 和 sync 標記到元數據
                    if (enableSync) {
                        window.gSheetsSyncData = {
                            url: gSheetsUrl,
                            spreadsheetId: spreadsheetId,
                            lastSync: Date.now(),
                            syncEnabled: true,
                            useFormatting: false
                        };

                        setupGSheetsSync();
                    }

                    // 恢復按鈕狀態
                    if (loadBtn) {
                        loadBtn.disabled = false;
                        loadBtn.textContent = originalText || '載入';
                    }

                    showNotification('成功載入 Google Sheets 數據（純文本方式）');
                    resolve();
                })
                .catch(error => {
                    console.error('Google Sheets 載入錯誤:', error);

                    if (isSafari) {
                        // 為 Safari 提供手動下載的選項
                        const manualDownloadUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=xlsx`;
                        showNotification(`
                            Safari 無法自動載入 Google Sheets。請
                            <a href="${manualDownloadUrl}" target="_blank" class="text-blue-500 underline">點擊此處下載</a>
                            然後使用"導入Excel"功能上傳`, 10000);
                    } else {
                        showNotification(`載入失敗: ${error.message || '無法連接到Google Sheets'}`);
                    }

                    // 恢復按鈕狀態
                    if (loadBtn) {
                        loadBtn.disabled = false;
                        loadBtn.textContent = originalText || '載入';
                    }

                    reject(error);
                });
            });
        }

        // 從 Google Sheets URL 提取 spreadsheetId
        function extractSpreadsheetId(url) {
            if (!url) return null;

            // 嘗試多種格式匹配
            // 標準格式
            let match = url.match(/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
            if (match) return match[1];

            // 移動格式或簡短URL
            match = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
            if (match) return match[1];

            // 檢查其他可能的格式
            match = url.match(/sheets\.google\.com.*[?&]id=([a-zA-Z0-9-_]+)/i);
            if (match) return match[1];

            match = url.match(/docs\.google\.com\/spreadsheets.*[?&]key=([a-zA-Z0-9-_]+)/i);
            if (match) return match[1];

            // 直接是ID的情況
            if (/^[a-zA-Z0-9-_]+$/.test(url)) return url;

            return null;
        }

        // 驗證 Google Sheets URL
        function isValidGSheetsUrl(url) {
            return url.includes('docs.google.com/spreadsheets/d/');
        }

        // 解析 CSV 數據為二維數組
        function parseCSV(text) {
            if (!text) return [[]];

            const lines = text.split(/\r?\n/);
            const result = [];

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();
                if (!line) continue;

                const row = [];
                let inQuotes = false;
                let currentField = '';

                for (let j = 0; j < line.length; j++) {
                    const char = line[j];

                    if (char === '"') {
                        // 處理引號
                        if (inQuotes && j < line.length - 1 && line[j + 1] === '"') {
                            // 處理連續兩個引號（CSV中的轉義引號）
                            currentField += '"';
                            j++; // 跳過下一個引號
                        } else {
                            // 切換引號模式
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        // 非引號內的逗號表示字段分隔
                        row.push(currentField);
                        currentField = '';
                    } else {
                        // 普通字符
                        currentField += char;
                    }
                }

                // 添加最後一個字段
                row.push(currentField);
                result.push(row);
            }

            return result;
        }

        // 帶格式的 Google Sheets 導入（使用 Google API）
        function loadFormattedGSheetsData(spreadsheetId, gSheetsUrl, enableSync) {
            return new Promise((resolve, reject) => {



                // 檢查gapi是否正確載入
                if (typeof gapi === 'undefined') {
                    console.error('Google API 未能正確載入，嘗試使用備選方案');
                    // 降級到 CSV 方法
                    loadGSheetsDataWithCSV(spreadsheetId, gSheetsUrl, enableSync, null, null)
                        .then(resolve)
                        .catch(reject);
                    return;
                }

                // 設置超時處理
                const timeout = setTimeout(() => {
                    reject(new Error('Google API 載入超時，嘗試使用備選方案'));
                }, 10000); // 10秒超時

                try {
                    // 加載 Google API 客戶端
                    gapi.load('client', () => {
                        clearTimeout(timeout); // 清除超時計時器

                        gapi.client.init({
                            apiKey: GOOGLE_API_KEY,
                            discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4']
                        })
                        .then(() => {
                            // 請求 Google Sheets 數據，包含格式信息
                            return gapi.client.sheets.spreadsheets.get({
                                spreadsheetId: spreadsheetId,
                                includeGridData: true,
                                ranges: []  // 空數組表示獲取所有工作表
                            });
                        })
                        .then(response => {
                            // 創建深拷貝避免修改原始響應
                            const responseData = JSON.parse(JSON.stringify(response.result));
                            const sheets = responseData.sheets;

                            // 檢查是否有工作表
                            if (!sheets || sheets.length === 0) {
                                reject(new Error('未找到工作表數據'));
                                return;
                            }

                            // 重置 excelSheets
                            excelSheets = {};

                            // 處理所有工作表
                            sheets.forEach(sheet => {
                                const sheetName = sheet.properties.title;
                                const gridData = sheet.data[0]; // 第一個數據網格

                                if (!gridData || !gridData.rowData || gridData.rowData.length === 0) {
                                    console.warn(`工作表 "${sheetName}" 沒有數據`);
                                    return;
                                }

                                // 提取帶格式的數據
                                const rowData = gridData.rowData;
                                const formattedData = [];

                                // 處理所有行
                                rowData.forEach(row => {
                                    if (!row.values) return;

                                    const formattedRow = [];
                                    const values = row.values;

                                    // 處理每個單元格
                                    values.forEach(cell => {
                                        // 獲取單元格值和格式
                                        const value = cell.formattedValue || '';

                                        // 創建深拷貝以避免修改唯讀屬性
                                        const textFormatRunsCopyCopy = cell.textFormatRunsCopyCopy ?
                                            JSON.parse(JSON.stringify(cell.textFormatRunsCopyCopy)) : [];

                                        const effectiveFormatCopyCopy = cell.effectiveFormatCopyCopy ?
                                            JSON.parse(JSON.stringify(cell.effectiveFormatCopyCopy)) : {};

                                        // 安全地創建帶格式的單元格對象
                                        const formattedCell = {
                                            value: value,
                                            textContent: value,
                                            format: {
                                                bold: effectiveFormatCopyCopy.textFormat?.bold || false,
                                                italic: effectiveFormatCopyCopy.textFormat?.italic || false,
                                                underline: effectiveFormatCopyCopy.textFormat?.underline || false,
                                                strikethrough: effectiveFormatCopyCopy.textFormat?.strikethrough || false,
                                                fontSize: effectiveFormatCopyCopy.textFormat?.fontSize || 10,
                                                foregroundColor: effectiveFormatCopyCopy.textFormat?.foregroundColor ?
                                                    {...effectiveFormatCopyCopy.textFormat.foregroundColor} : null,
                                                backgroundColor: effectiveFormatCopyCopy.backgroundColor ?
                                                    {...effectiveFormatCopyCopy.backgroundColor} : null
                                            },
                                            formatRuns: textFormatRunsCopyCopy,
                                            delta: convertGSheetsCellToQuillDelta(
                                                value,
                                                textFormatRunsCopyCopy,
                                                effectiveFormatCopyCopy
                                            )
                                        };

                                        formattedRow.push(formattedCell);
                                    });

                                    formattedData.push(formattedRow);
                                });

                                // 保存帶格式的工作表數據
                                excelSheets[sheetName] = {
                                    data: formattedData,
                                    columns: formattedData[0].map(cell => cell.value),
                                    hasFormatting: true
                                };

                                // 設置默認卡組映射
                                if (!sheetMappings[sheetName]) {
                                    sheetMappings[sheetName] = {
                                        deckOption: 'new',
                                        deckId: '',
                                        newDeckName: sheetName,
                                        newDeckDescription: '從 Google Sheets 導入的字卡'
                                    };
                                }

                                // 設置默認列選擇
                                if (!sheetOptions[sheetName]) {
                                    sheetOptions[sheetName] = {
                                        frontColumn: 0,
                                        backColumn: 1
                                    };
                                }
                            });

                            // 設置第一個工作表為活動工作表
                            activeSheetName = Object.keys(excelSheets)[0];

                            resolve();
                        })

                        .catch(error => {
                            console.error('Google Sheets API 錯誤:', error);
                            console.error('在Safari上使用Google API失敗，嘗試備選方案');
                            // 如果API調用失敗，轉向備選方案
                            loadGSheetsDataWithCSV(spreadsheetId, gSheetsUrl, enableSync, null, null)
                                .then(resolve)
                                .catch(reject);
                        });
                    });
                } catch (error) {
                    clearTimeout(timeout);
                    console.error('初始化Google API發生錯誤', error);
                    // 異常情況下也使用備選方案
                    loadGSheetsDataWithCSV(spreadsheetId, gSheetsUrl, enableSync, null, null)
                        .then(resolve)
                        .catch(reject);
                }
            });
        }

        // 與 Google Sheets 同步數據
        function syncWithGoogleSheets() {
            if (!window.gSheetsSyncData) return;

            const { spreadsheetId, useFormatting } = window.gSheetsSyncData;

            // 顯示同步中狀態
            const syncIndicator = document.getElementById('gSheetsSyncIndicator');
            if (syncIndicator) {
                syncIndicator.classList.add('animate-pulse');
                const syncNowBtn = document.getElementById('syncNowBtn');
                if (syncNowBtn) {
                    syncNowBtn.disabled = true;
                    syncNowBtn.textContent = '同步中...';
                }
            }

            // 根據是否使用格式化選擇同步方式
            if (useFormatting && GOOGLE_API_KEY) {
                // 使用 Google API 獲取帶格式的數據
                loadFormattedGSheetsData(spreadsheetId, window.gSheetsSyncData.url, true)
                    .then(() => {
                        // 更新字卡數據
                        updateCardsFromGSheets();

                        // 更新同步時間
                        window.gSheetsSyncData.lastSync = Date.now();

                        // 恢復同步指示器狀態
                        restoreSyncIndicator(syncIndicator);

                        showNotification('已成功與 Google Sheets 同步（含格式）');
                    })
                    .catch(error => {
                        console.error('Google Sheets API 同步錯誤:', error);
                        showNotification('格式同步失敗，嘗試純文本同步');

                        // 回退到 CSV 同步
                        syncWithGoogleSheetsCSV(spreadsheetId, syncIndicator);
                    });
            } else {
                // 使用 CSV 獲取純文本數據
                syncWithGoogleSheetsCSV(spreadsheetId, syncIndicator);
            }
        }

        // 使用 CSV 方式與 Google Sheets 同步（無格式）
        function syncWithGoogleSheetsCSV(spreadsheetId, syncIndicator) {
            const exportUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv`;

            fetch(exportUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('同步失敗，無法訪問 Google Sheets');
                    }
                    return response.text();
                })
                .then(csvData => {
                    // 解析 CSV 數據
                    const parsedData = parseCSV(csvData);

                    // 保存 Google Sheets 數據
                    const sheetName = 'GoogleSheet';
                    excelSheets[sheetName] = {
                        data: parsedData,
                        columns: parsedData[0],
                        hasFormatting: false
                    };

                    // 更新字卡數據
                    updateCardsFromGSheets();

                    // 更新同步時間
                    if (window.gSheetsSyncData) {
                        window.gSheetsSyncData.lastSync = Date.now();
                    }

                    if (value && typeof value === 'string') {
                        // 保留換行符，不要去除
                        const preservedValue = value;
                        // 繼續處理 preservedValue...
                    }

                    // 恢復同步指示器狀態
                    restoreSyncIndicator(syncIndicator);

                    showNotification('已成功與 Google Sheets 同步（純文本）');
                })
                .catch(error => {
                    console.error('Google Sheets 同步錯誤:', error);
                    showNotification(error.message || 'Google Sheets 同步失敗');

                    // 恢復同步指示器狀態
                    restoreSyncIndicator(syncIndicator);
                });
        }

        // 恢復同步指示器狀態
        function restoreSyncIndicator(syncIndicator) {
            if (syncIndicator) {
                syncIndicator.classList.remove('animate-pulse');
                const syncNowBtn = document.getElementById('syncNowBtn');
                if (syncNowBtn) {
                    syncNowBtn.disabled = false;
                    syncNowBtn.textContent = '立即同步';
                }
            }
        }

        function convertGSheetsCellToQuillDelta(value, textFormatRuns, effectiveFormat) {
            // 如果沒有文本,返回空 Delta
            if (!value) {
                return { ops: [] };
            }

            const format = {};

            // 從 effectiveFormat 提取全局格式
            if (effectiveFormat) {
                // 原有的格式處理(粗體、斜體等)
                if (effectiveFormat.textFormat) {
                    if (effectiveFormat.textFormat.bold) format.bold = true;
                    if (effectiveFormat.textFormat.italic) format.italic = true;
                    if (effectiveFormat.textFormat.underline) format.underline = true;
                    if (effectiveFormat.textFormat.strikethrough) format.strike = true;

                    // 處理前景色 - 增強顏色處理邏輯
                    if (effectiveFormat.textFormat.foregroundColor) {
                        const color = effectiveFormat.textFormat.foregroundColor;
                        if (color.red !== undefined && color.green !== undefined && color.blue !== undefined) {
                            // 使用更精確的RGB值
                            const r = Math.round(color.red * 255);
                            const g = Math.round(color.green * 255);
                            const b = Math.round(color.blue * 255);

                            // 檢查是否為默認黑色
                            const isDefaultBlack = (r === 0 && g === 0 && b === 0);
                            if (!isDefaultBlack) {
                                format.color = `rgb(${r}, ${g}, ${b})`;
                                // 保存原始顏色值以備在暗模式下使用
                                format.originalColor = [r, g, b];
                            }
                        }
                    }

                    // 處理背景色
                    if (effectiveFormat.backgroundColor) {
                        const bgColor = effectiveFormat.backgroundColor;
                        // 檢查是否不是默認白色
                        const isDefaultWhite = (bgColor.red === 1 && bgColor.green === 1 && bgColor.blue === 1);
                        if (!isDefaultWhite) {
                            const r = Math.round(bgColor.red * 255);
                            const g = Math.round(bgColor.green * 255);
                            const b = Math.round(bgColor.blue * 255);
                            format.background = `rgb(${r}, ${g}, ${b})`;
                        }
                    }
                }

                // 處理對齊方式 - 重要部分,確保對齊格式被保留
                if (effectiveFormat.horizontalAlignment) {
                    const alignment = effectiveFormat.horizontalAlignment.toLowerCase();
                    if (alignment === 'center' || alignment === 'right' || alignment === 'justify') {
                        format.align = alignment;
                    }
                }
            }

            // 如果沒有格式運行,使用整體格式
            if (!textFormatRuns || textFormatRuns.length === 0) {
                // 創建帶格式的 Delta
                return {
                    ops: [
                        {
                            insert: value,
                            attributes: Object.keys(format).length > 0 ? format : undefined
                        }
                    ]
                };
            }

            // 如果有格式運行,處理每一段
            const ops = [];
            let lastIndex = 0;

            // 按順序處理每個格式段
            textFormatRuns.forEach(run => {
                const startIndex = run.startIndex || 0;

                // 添加前一段文本(如果有)
                if (startIndex > lastIndex) {
                    const text = value.substring(lastIndex, startIndex);
                    if (text) {
                        ops.push({
                            insert: text,
                            attributes: Object.keys(format).length > 0 ? {...format} : undefined
                        });
                    }
                }

                // 獲取此格式段的結束索引
                const nextRun = textFormatRuns.find(r => r.startIndex > startIndex);
                const endIndex = nextRun ? nextRun.startIndex : value.length;

                // 提取文本
                const text = value.substring(startIndex, endIndex);

                // 提取格式 - 增強顏色處理
                const segmentFormat = {...format}; // 從全局格式繼承
                if (run.format) {
                    if (run.format.bold) segmentFormat.bold = true;
                    if (run.format.italic) segmentFormat.italic = true;
                    if (run.format.underline) segmentFormat.underline = true;
                    if (run.format.strikethrough) segmentFormat.strike = true;

                    // 處理前景色 - 加強顏色轉換
                    if (run.format.foregroundColor) {
                        const color = run.format.foregroundColor;
                        if (color.red !== undefined && color.green !== undefined && color.blue !== undefined) {
                            const r = Math.round(color.red * 255);
                            const g = Math.round(color.green * 255);
                            const b = Math.round(color.blue * 255);

                            // 檢查顏色是否為默認黑色
                            const isDefaultBlack = r === 0 && g === 0 && b === 0;
                            if (!isDefaultBlack) {
                                segmentFormat.color = `rgb(${r}, ${g}, ${b})`;
                                // 保存原始顏色值
                                segmentFormat.originalColor = [r, g, b];
                            }
                        }
                    }

                    // 處理背景色
                    if (run.format.backgroundColor) {
                        const bgColor = run.format.backgroundColor;
                        const isDefaultWhite = (bgColor.red === 1 && bgColor.green === 1 && bgColor.blue === 1);
                        if (!isDefaultWhite) {
                            const r = Math.round(bgColor.red * 255);
                            const g = Math.round(bgColor.green * 255);
                            const b = Math.round(bgColor.blue * 255);
                            segmentFormat.background = `rgb(${r}, ${g}, ${b})`;
                        }
                    }
                }

                // 添加帶格式的文本
                ops.push({
                    insert: text,
                    attributes: Object.keys(segmentFormat).length > 0 ? segmentFormat : undefined
                });

                // 更新處理索引
                lastIndex = endIndex;
            });

            // 添加剩餘的文本(如果有)
            if (lastIndex < value.length) {
                const remainingText = value.substring(lastIndex);
                ops.push({
                    insert: remainingText,
                    attributes: Object.keys(format).length > 0 ? {...format} : undefined
                });
            }

            // 如果是最後一個操作並且有換行，確保換行也有格式
            if (ops.length > 0 && typeof ops[ops.length-1].insert === 'string' &&
                ops[ops.length-1].insert.endsWith('\n')) {
                // 確保最後一個換行也帶有格式
                const lastOp = ops[ops.length-1];
                if (lastOp.insert === '\n') {
                    lastOp.attributes = format;
                } else if (lastOp.insert.endsWith('\n')) {
                    // 拆分最後的文本和換行
                    const text = lastOp.insert.slice(0, -1);
                    const attributes = lastOp.attributes || {};

                    // 修改最後一個操作為不含換行的文本
                    lastOp.insert = text;

                    // 添加一個新的操作為換行
                    ops.push({
                        insert: '\n',
                        attributes: format
                    });
                }
            }

            return { ops: ops };
        }

        // 根據 Google Sheets 數據更新字卡
        function updateCardsFromGSheets() {
            if (!activeSheetName || !excelSheets[activeSheetName]) return;

            const sheetData = excelSheets[activeSheetName].data;
            const hasFormatting = excelSheets[activeSheetName].hasFormatting;
            const options = sheetOptions[activeSheetName];
            const mapping = sheetMappings[activeSheetName];

            // 確認選擇了正確的列
            if (!options || options.frontColumn === undefined || options.backColumn === undefined) {
                console.error('列選擇無效');
                return;
            }

            // 獲取目標卡組
            let targetDeckId;

            if (mapping.deckOption === 'existing') {
                targetDeckId = parseInt(mapping.deckId);
            } else {
                // 查找之前創建的卡組
                const existingDeck = decksData.find(d => d.name === mapping.newDeckName);
                if (existingDeck) {
                    targetDeckId = existingDeck.id;
                } else {
                    // 如果沒有找到卡組,創建一個新卡組
                    const newDeck = {
                        id: Date.now(),
                        name: mapping.newDeckName,
                        description: mapping.newDeckDescription || '',
                        cardIds: [],
                        createdAt: Date.now()
                    };

                    decksData.push(newDeck);
                    targetDeckId = newDeck.id;
                }
            }

            // 獲取目標卡組
            const targetDeck = decksData.find(d => d.id === targetDeckId);
            if (!targetDeck) {
                console.error('找不到目標卡組');
                return;
            }

            // 臨時存儲卡片 ID 與行索引的映射
            const cardRowMap = new Map();

            // 處理每一行數據(跳過標題行)
            for (let i = 1; i < sheetData.length; i++) {
                const row = sheetData[i];

                // 獲取正面和背面內容
                const frontCell = row[options.frontColumn];
                const backCell = row[options.backColumn];

                // 跳過空行
                if (!frontCell && !backCell) continue;

                // 準備卡片內容
                let frontText, backText;

                if (hasFormatting) {
                    // 處理帶格式的內容
                    frontText = convertDeltaToHTML(frontCell?.delta || { ops: [] });
                    backText = convertDeltaToHTML(backCell?.delta || { ops: [] });
                } else {
                    // 處理純文本內容
                    frontText = frontCell || '';
                    backText = backCell || '';
                }

                // 生成一個用於識別這行的唯一鍵
                const rowKey = `${frontText}_${backText}`;

                // 查找是否已存在相同內容的卡片
                let existingCard = null;
                for (const cardId of targetDeck.cardIds) {
                    const card = cardsData.find(c => c.id === cardId);
                    if (card) {
                        const cardKey = `${card.frontText}_${card.backText}`;
                        if (cardKey === rowKey) {
                            existingCard = card;
                            break;
                        }
                    }
                }

                if (existingCard) {
                    // 更新現有卡片
                    existingCard.frontText = frontText;
                    existingCard.backText = backText;
                    cardRowMap.set(existingCard.id, i);
                } else {
                    // 創建新卡片
                    const newCardId = Date.now() + i + Math.floor(Math.random() * 1000);
                    const newCard = {
                        id: newCardId,
                        frontText: frontText,
                        backText: backText,
                        nextReview: Date.now(),
                        repetitions: 0,
                        easeFactor: 2.0,
                        interval: 1.0
                    };

                    cardsData.push(newCard);
                    targetDeck.cardIds.push(newCardId);
                    cardRowMap.set(newCardId, i);
                }
            }

            // 可選:移除不再存在於表格中的卡片
            targetDeck.cardIds = targetDeck.cardIds.filter(cardId => {
                return cardRowMap.has(cardId);
            });

            // 刷新相關 UI
            loadDeckList();
            if (!manageCardSection.classList.contains('hidden')) {
                loadAllCards();
            }

            // 提醒用戶保存數據
            showStorageReminder();
        }

        // 將 Quill Delta 轉換為 HTML
        // 修改 convertDeltaToHTML 函數以正確處理換行
        // 修改 convertDeltaToHTML 函數以適應暗模式
        function convertDeltaToHTML(delta) {
            if (!delta || !delta.ops || delta.ops.length === 0) {
                return '';
            }

            // 檢測當前頁面模式
            const isDarkMode = document.documentElement.classList.contains('dark');

            // 創建臨時 div 元素
            const tempDiv = document.createElement('div');

            // 追蹤當前的段落和格式
            let currentP = document.createElement('p');
            tempDiv.appendChild(currentP);
            let blockAttributes = {};

            // 處理每個操作
            delta.ops.forEach(op => {
                if (!op.insert) return;

                // 檢查是否有區塊級屬性（如對齊方式）
                if (op.attributes && (op.attributes.align || op.attributes.header || op.attributes.list)) {
                    blockAttributes = {
                        align: op.attributes.align,
                        header: op.attributes.header,
                        list: op.attributes.list
                    };
                }

                // 處理文本換行
                if (typeof op.insert === 'string' && op.insert.includes('\n')) {
                    // 將文本按換行符分割
                    const lines = op.insert.split('\n');

                    for (let i = 0; i < lines.length; i++) {
                        // 如果不是第一行，創建新段落
                        if (i > 0) {
                            // 結束上一個段落
                            applyBlockAttributes(currentP, blockAttributes);

                            // 創建新段落
                            currentP = document.createElement('p');
                            tempDiv.appendChild(currentP);
                        }

                        if (lines[i]) {
                            const span = document.createElement('span');
                            span.textContent = lines[i];

                            // 應用格式並顧及暗模式適配
                            applyFormattingWithColorEnhancement(span, op.attributes, isDarkMode);

                            currentP.appendChild(span);
                        }
                    }
                } else {
                    // 處理普通文本或其他內容（如圖片）
                    if (typeof op.insert === 'string') {
                        const span = document.createElement('span');
                        span.textContent = op.insert;

                        // 應用格式
                        applyFormattingWithColorEnhancement(span, op.attributes, isDarkMode);

                        currentP.appendChild(span);
                    } else if (op.insert.image) {
                        // 處理圖片
                        const img = document.createElement('img');
                        img.src = op.insert.image;
                        img.style.maxWidth = '100%';

                        // 應用圖片格式
                        if (op.attributes) {
                            if (op.attributes.width) img.style.width = op.attributes.width + 'px';
                            if (op.attributes.height) img.style.height = op.attributes.height + 'px';
                            if (op.attributes.align) {
                                if (op.attributes.align === 'center') {
                                    img.style.display = 'block';
                                    img.style.marginLeft = 'auto';
                                    img.style.marginRight = 'auto';
                                } else if (op.attributes.align === 'right') {
                                    img.style.display = 'block';
                                    img.style.marginLeft = 'auto';
                                }
                            }
                        }

                        currentP.appendChild(img);
                    }
                }
            });

            // 確保最後一個段落也應用了區塊屬性
            applyBlockAttributes(currentP, blockAttributes);

            return tempDiv.innerHTML;
        }

        // 應用區塊級屬性（如對齊）到段落
        function applyBlockAttributes(element, attributes) {
            if (!attributes) return;

            if (attributes.align) {
                element.style.textAlign = attributes.align;
                element.classList.add(`ql-align-${attributes.align}`);
            }

            if (attributes.header) {
                // 將p元素替換為對應的標題元素
                const header = document.createElement(`h${attributes.header}`);
                while (element.firstChild) {
                    header.appendChild(element.firstChild);
                }
                for (let attr of element.getAttributeNames()) {
                    header.setAttribute(attr, element.getAttribute(attr));
                }
                if (element.parentNode) {
                    element.parentNode.replaceChild(header, element);
                }
            }

            if (attributes.list) {
                // 處理列表格式
                element.classList.add(`ql-list-${attributes.list}`);
            }
        }

        // 增強的格式應用函數,特別注重顏色處理和對齊方式
        function applyFormattingWithColorEnhancement(element, attributes, isDarkMode) {
            if (!attributes) return;

            // 基本格式
            if (attributes.bold) element.style.fontWeight = 'bold';
            if (attributes.italic) element.style.fontStyle = 'italic';
            if (attributes.underline) element.style.textDecoration = 'underline';
            if (attributes.strike) element.style.textDecoration = 'line-through';
            if (attributes.script === 'super') element.style.verticalAlign = 'super';
            if (attributes.script === 'sub') element.style.verticalAlign = 'sub';

            // 字體大小處理
            if (attributes.size) {
                switch(attributes.size) {
                    case 'small':
                        element.style.fontSize = '0.75em';
                        element.classList.add('ql-size-small');
                        break;
                    case 'large':
                        element.style.fontSize = '1.5em';
                        element.classList.add('ql-size-large');
                        break;
                    case 'huge':
                        element.style.fontSize = '2em';
                        element.classList.add('ql-size-huge');
                        break;
                }
            }

            // 前景色處理 - 優化暗模式下的顏色顯示
            if (attributes.color) {
                // 直接使用color屬性
                element.style.color = attributes.color;

                // 對特定顏色在暗模式下進行調整
                if (isDarkMode) {
                    // 可能需要根據暗模式調整某些顏色的亮度/對比度
                    // 例如:在暗模式下加亮深色文字
                    const colorMatch = attributes.color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (colorMatch) {
                        const r = parseInt(colorMatch[1]);
                        const g = parseInt(colorMatch[2]);
                        const b = parseInt(colorMatch[3]);

                        // 計算顏色亮度 (0-255)
                        const brightness = (r * 299 + g * 587 + b * 114) / 1000;

                        // 如果顏色太暗,在暗模式下提亮
                        if (brightness < 128) {
                            // 提亮顏色,但保持色調
                            element.style.color = `rgb(${Math.min(r + 100, 255)}, ${Math.min(g + 100, 255)}, ${Math.min(b + 100, 255)})`;
                            // 添加文字陰影增加可讀性
                            element.style.textShadow = '0 0 2px rgba(0,0,0,0.5)';
                        }
                    }
                }
            }

            // 背景色處理
            if (attributes.background) {
                // 檢查是否為白色或接近白色的背景
                if (attributes.background === 'rgb(255, 255, 255)' ||
                    attributes.background.match(/rgb\(2[0-9][0-9], 2[0-9][0-9], 2[0-9][0-9]\)/)) {

                    if (isDarkMode) {
                        // 在暗模式下將白色背景改為半透明
                        element.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                        // 確保文字可見
                        if (!attributes.color) {
                            element.style.color = '#fff';
                        }
                    } else {
                        element.style.backgroundColor = attributes.background;
                    }
                } else {
                    // 其他背景色直接應用,可能還需按暗模式調整
                    element.style.backgroundColor = attributes.background;

                    // 在暗模式下,可能需要調整背景色的透明度
                    if (isDarkMode) {
                        const match = attributes.background.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                        if (match) {
                            // 使背景色半透明以配合暗模式
                            element.style.backgroundColor = `rgba(${match[1]}, ${match[2]}, ${match[3]}, 0.7)`;
                        }
                    }
                }
            }

            // 添加CSS類以便進一步通過CSS自定義樣式
            if (attributes.color) element.classList.add('has-text-color');
            if (attributes.background) element.classList.add('has-background');
        }

        // 添加一個新的輔助函數來處理暗模式適應的格式應用
        function applyFormattingWithDarkModeAwareness(element, attributes) {
            if (!attributes) return;

            if (attributes.bold) element.style.fontWeight = 'bold';
            if (attributes.italic) element.style.fontStyle = 'italic';
            if (attributes.underline) element.style.textDecoration = 'underline';
            if (attributes.strike) element.style.textDecoration = 'line-through';
            if (attributes.color) element.style.color = attributes.color;

            // 背景色處理 - 添加暗模式適應
            if (attributes.background) {
                // 檢查是否為白色或接近白色的背景
                if (attributes.background === 'rgb(255, 255, 255)' ||
                    attributes.background.match(/rgb\(2[0-9][0-9], 2[0-9][0-9], 2[0-9][0-9]\)/)) {

                    // 在暗模式下，將白色背景轉換為淺灰色
                    // 可以通過檢測頁面當前模式來確定
                    const isDarkMode = document.documentElement.classList.contains('dark');

                    if (isDarkMode) {
                        element.style.backgroundColor = 'rgba(255, 255, 255, 0.2)'; // 半透明白色在暗模式下
                        element.style.color = '#fff'; // 確保文字在暗背景下可見
                    } else {
                        element.style.backgroundColor = attributes.background;
                    }
                } else {
                    // 非白色背景直接應用
                    element.style.backgroundColor = attributes.background;
                }
            }
        }

        // 初始化Quill編輯器 - 修復輸入問題並統一工具欄
                function initQuillEditors() {
                  console.log("初始化Quill編輯器...");

                  // 確保之前的實例被清理
                  if (frontQuill) {
                    try {
                      frontQuill.off('selection-change'); // 假設有這個事件，實際可能不需要
                      // 更安全的做法是直接銷毀，但Quill 2.x RC可能沒有直接的destroy方法，或行為不同
                      // 如果Quill實例的容器被移除或清空，下次創建新實例時舊的引用會失效
                      const frontEditorContainer = document.getElementById('frontEditor');
                      if (frontEditorContainer) frontEditorContainer.innerHTML = ''; // 清空容器
                      frontQuill = null;
                    } catch (e) {
                      console.warn("清理前面編輯器時發生輕微錯誤:", e);
                    }
                  }

                  if (backQuill) {
                    try {
                      backQuill.off('selection-change');
                      const backEditorContainer = document.getElementById('backEditor');
                      if (backEditorContainer) backEditorContainer.innerHTML = '';
                      backQuill = null;
                    } catch (e) {
                      console.warn("清理背面編輯器時發生輕微錯誤:", e);
                    }
                  }

                  if (editFrontQuill) {
                    try {
                      editFrontQuill.off('selection-change');
                      const editFrontEditorContainer = document.getElementById('editFrontEditor');
                      if (editFrontEditorContainer) editFrontEditorContainer.innerHTML = '';
                      editFrontQuill = null;
                    } catch (e) {
                      console.warn("清理編輯正面編輯器時發生輕微錯誤:", e);
                    }
                  }

                  if (editBackQuill) {
                    try {
                      editBackQuill.off('selection-change');
                      const editBackEditorContainer = document.getElementById('editBackEditor');
                      if (editBackEditorContainer) editBackEditorContainer.innerHTML = '';
                      editBackQuill = null;
                    } catch (e) {
                      console.warn("清理編輯背面編輯器時發生輕微錯誤:", e);
                    }
                  }


                  // 使用延遲初始化，確保DOM已完全加載
                  setTimeout(() => {
                    try {
                      // 檢查編輯器容器是否存在
                      const frontEditorContainer = document.getElementById('frontEditor');
                      const backEditorContainer = document.getElementById('backEditor');
                      const editFrontEditorContainer = document.getElementById('editFrontEditor');
                      const editBackEditorContainer = document.getElementById('editBackEditor');


                      // 定義共用的工具欄配置
                      const standardToolbarOptions = [
                        ['bold', 'italic', 'underline', 'strike'],
                        ['blockquote'],
                        [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                        [{ 'align': ['', 'center', 'right', 'justify'] }], // Quill本身會處理空字符串為預設對齊
                        [{ 'color': [] }, { 'background': [] }],
                        [{ 'size': ['small', false, 'large', 'huge'] }], // 'false' 代表預設字體大小
                        ['image'] // <--- 確保圖片按鈕在此
                      ];

                      // 初始化創建卡片編輯器
                      if (frontEditorContainer && backEditorContainer) {
                          frontQuill = new Quill('#frontEditor', {
                            theme: 'snow',
                            modules: {
                              toolbar: standardToolbarOptions,
                              clipboard: { matchVisual: false }
                            },
                            placeholder: '輸入卡片正面內容...'
                          });

                          backQuill = new Quill('#backEditor', {
                            theme: 'snow',
                            modules: {
                              toolbar: standardToolbarOptions,
                              clipboard: { matchVisual: false }
                            },
                            placeholder: '輸入卡片背面內容...'
                          });
                      } else {
                          console.warn("創建卡片用的編輯器容器(frontEditor/backEditor)不存在，跳過初始化");
                      }


                      // 初始化編輯模式編輯器
                      if (editFrontEditorContainer && editBackEditorContainer) {
                        console.log("正在初始化編輯模式編輯器...");
                        editFrontQuill = new Quill('#editFrontEditor', {
                          theme: 'snow',
                          modules: {
                            toolbar: standardToolbarOptions, // <-- 使用標準配置
                            clipboard: { matchVisual: false }
                          },
                          placeholder: '輸入卡片正面內容...'
                        });

                        editBackQuill = new Quill('#editBackEditor', {
                          theme: 'snow',
                          modules: {
                            toolbar: standardToolbarOptions, // <-- 使用標準配置 (確保這裡也是！)
                            clipboard: { matchVisual: false }
                          },
                          placeholder: '輸入卡片背面內容...'
                        });
                      } else {
                        console.log("編輯模式編輯器容器(editFrontEditor/editBackEditor)不存在，跳過初始化");
                      }

                      // 移除編輯器內容區域可能產生的重複工具欄 (以防萬一)
                      document.querySelectorAll('.editor-content .ql-toolbar').forEach(toolbar => {
                        if (toolbar.parentNode && toolbar.closest('.editor-content')) { // 確保是內容區域內的工具欄
                          toolbar.parentNode.removeChild(toolbar);
                        }
                      });

                      console.log("編輯器已創建，設置事件處理器...");

                      // 確保編輯器區域可點擊，能夠獲得焦點
                      document.querySelectorAll('.ql-editor').forEach(editor => {
                        editor.style.pointerEvents = 'auto';
                        editor.style.userSelect = 'text';
                      });

                      // 統一的事件處理和狀態更新函數
                      function setupEditorEvents(editorInstance, editorName) {
                        if (editorInstance && editorInstance.root) {
                          editorInstance.root.addEventListener('focus', function() {
                            console.log(`${editorName} 編輯器獲得焦點`);
                            // activeQuill = editorInstance; // 如果需要追蹤當前活動編輯器
                            // updateButtonStates(); // 如果有外部按鈕需要根據編輯器狀態更新
                          });

                          editorInstance.on('selection-change', function(range) {
                            if (range && editorInstance.hasFocus()) { // 只有當編輯器有焦點時才更新
                              // activeQuill = editorInstance;
                              // updateButtonStates();
                            }
                          });
                        }
                      }

                      setupEditorEvents(frontQuill, "前面");
                      setupEditorEvents(backQuill, "背面");
                      setupEditorEvents(editFrontQuill, "編輯正面");
                      setupEditorEvents(editBackQuill, "編輯背面");


                      // 調整Quill編輯器的深色模式 (如果需要)
                      adjustQuillForDarkMode();

                      // 初始化時設置焦點到創建卡片的正面編輯器 (如果該部分可見)
                      if (frontQuill && !createCardSection.classList.contains('hidden')) {
                        setTimeout(() => {
                          try {
                            frontQuill.focus();
                            console.log("設置焦點到創建卡片的前面編輯器");
                          } catch (error) {
                            console.error("設置焦點時出錯:", error);
                          }
                        }, 200);
                      }

                      console.log("Quill編輯器初始化完成");
                    } catch (error) {
                      console.error("初始化Quill編輯器時發生錯誤:", error);
                    }
                  }, 100); // 稍微減少延遲，看是否能改善初始化時機
                }

        // 處理圖片拖拽
        [frontQuill, backQuill, editFrontQuill, editBackQuill].forEach(editor => {
          if (!editor) return;

          const editorElement = editor.root;

          // 處理拖拽進入
          editorElement.addEventListener('dragover', function(e) {
            e.preventDefault();
            editorElement.classList.add('drag-over');
          });

          // 處理拖拽離開
          editorElement.addEventListener('dragleave', function(e) {
            e.preventDefault();
            editorElement.classList.remove('drag-over');
          });

          // 處理拖拽放下
          editorElement.addEventListener('drop', function(e) {
            e.preventDefault();
            editorElement.classList.remove('drag-over');

            // 檢查是否有文件被拖拽
            if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
              const file = e.dataTransfer.files[0];

              // 檢查是否為圖片
              if (file.type.match('image.*')) {
                const reader = new FileReader();

                reader.onload = function(event) {
                  // 獲取當前選中位置
                  const range = editor.getSelection();

                  // 在當前位置插入圖片
                  if (range) {
                    // 智能壓縮圖片
                    analyzeAndCompressImage(event.target.result).then(compressedImage => {
                      editor.insertEmbed(range.index, 'image', compressedImage);

                      // 移動光標到圖片後面
                      editor.setSelection(range.index + 1);
                    });
                  }
                };

                reader.readAsDataURL(file);
              }
            }
          });
        });

        // 添加顯示拖拽區域的CSS樣式
        const dragStyleElement = document.createElement('style');
        dragStyleElement.textContent = `
          .ql-editor.drag-over {
            border: 2px dashed #5D5CDE;
            background-color: rgba(93, 92, 222, 0.05);
          }
        `;
        document.head.appendChild(dragStyleElement);



        // 根據當前主題調整Quill編輯器
        function adjustQuillForDarkMode() {
            const isDarkMode = document.documentElement.classList.contains('dark');
            const allEditors = [frontQuill, backQuill, editFrontQuill, editBackQuill].filter(editor => editor);

            allEditors.forEach(editor => {
                if (!editor) return;

                const container = editor.container;
                const toolbar = container.previousElementSibling;

                if (isDarkMode) {
                    container.classList.add('dark-quill');
                    if (toolbar) toolbar.classList.add('dark-toolbar');
                } else {
                    container.classList.remove('dark-quill');
                    if (toolbar) toolbar.classList.remove('dark-toolbar');
                }
            });
        }

        // Smart image compression functions
        async function analyzeAndCompressImage(dataUrl) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    // 分析圖片複雜度
                    const canvas = document.createElement('canvas');
                    const smallSize = 50; // 小尺寸用於分析
                    canvas.width = smallSize;
                    canvas.height = smallSize;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, smallSize, smallSize);

                    // 分析圖片複雜度 (用簡單的邊緣檢測)
                    const imageData = ctx.getImageData(0, 0, smallSize, smallSize);
                    const data = imageData.data;
                    let complexity = 0;

                    // 計算相鄰像素差異，估算圖片複雜度
                    for (let y = 0; y < smallSize - 1; y++) {
                        for (let x = 0; x < smallSize - 1; x++) {
                            const i = (y * smallSize + x) * 4;
                            const i2 = (y * smallSize + x + 1) * 4;
                            const i3 = ((y + 1) * smallSize + x) * 4;

                            // 計算水平和垂直差異
                            const diffX = Math.abs(data[i] - data[i2]) +
                                         Math.abs(data[i+1] - data[i2+1]) +
                                         Math.abs(data[i+2] - data[i2+2]);

                            const diffY = Math.abs(data[i] - data[i3]) +
                                         Math.abs(data[i+1] - data[i3+1]) +
                                         Math.abs(data[i+2] - data[i3+2]);

                            complexity += (diffX + diffY);
                        }
                    }

                    // 標準化複雜度
                    complexity = complexity / (smallSize * smallSize * 6);

                    // 根據複雜度和尺寸調整壓縮參數
                    let quality = 0.85; // 默認較高品質
                    let maxWidth = 1000;
                    let maxHeight = 800;

                    // 根據圖片複雜度調整品質
                    // 複雜圖片(文字、細節多)保持較高品質
                    if (complexity > 30) {
                        quality = 0.88; // 更高品質
                    } else if (complexity < 10) {
                        quality = 0.80; // 較簡單圖片可以多壓縮
                    }

                    // 根據原始尺寸調整目標尺寸
                    if (img.width > 2000 || img.height > 2000) {
                        // 非常大的圖片，適度縮小
                        maxWidth = 1200;
                        maxHeight = 1000;
                    } else if (img.width < 500 && img.height < 500) {
                        // 小圖片基本不縮小
                        maxWidth = Math.max(img.width, 500);
                        maxHeight = Math.max(img.height, 500);
                    }

                    // 執行壓縮
                    compressImage(dataUrl, maxWidth, maxHeight, quality).then(result => {
                        resolve(result);
                    });
                };
                img.src = dataUrl;
            });
        }

        // 添加到脚本开头部分的函数

        // base64 图片检测和处理函数
        function isBase64Image(str) {
          if (typeof str !== 'string') return false;
          // 检查是否符合 base64 图片格式前缀
          if (str.startsWith('data:image/')) {
            return true;
          }

          // 检查是否是没有前缀的 base64 编码
          try {
            // base64 字符串通常有特定的模式和长度
            const base64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;
            // 要求 base64 字符串至少有一定长度才被视为图片
            return str.length > 100 && base64Regex.test(str);
          } catch (e) {
            return false;
          }
        }

        // 确保 base64 字符串有正确的数据头
        function ensureBase64Prefix(base64Str) {
          if (base64Str.startsWith('data:image/')) {
            return base64Str;
          }

          // 尝试检测图片类型 (简单处理为 JPEG)
          return `data:image/jpeg;base64,${base64Str}`;
        }

        // 处理导入的内容，检测并处理 base64 图片
        function processImportedContent(content) {
          if (!content) return { text: '', image: null };

          if (typeof content !== 'string') {
            content = content.toString();
          }

          if (isBase64Image(content)) {
            return {
              text: '',
              image: ensureBase64Prefix(content)
            };
          }

          return {
            text: content,
            image: null
          };
        }

        // 圖片壓縮核心功能
        async function compressImage(dataUrl, maxWidth = 1000, maxHeight = 800, quality = 0.85) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    // 計算新尺寸，保持原始比例
                    let width = img.width;
                    let height = img.height;
                    let resized = false;

                    // 只有圖片超過最大尺寸時才調整
                    if (width > maxWidth) {
                        height = Math.round((height * maxWidth) / width);
                        width = maxWidth;
                        resized = true;
                    }

                    if (height > maxHeight) {
                        width = Math.round((width * maxHeight) / height);
                        height = maxHeight;
                        resized = true;
                    }

                    // 如果圖片已經很小且沒有調整過尺寸，不進行壓縮
                    if (width < 500 && height < 500 && dataUrl.length < 100 * 1024 && !resized) {
                        resolve(dataUrl);
                        return;
                    }

                    // 創建 canvas 進行尺寸調整和壓縮
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    // 轉換為適中壓縮的 JPEG 格式
                    const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);

                    resolve(compressedDataUrl);
                };
                img.src = dataUrl;
            });
        }

        // 設置圖片壓縮功能
        function setupImageCompression() {
            // 確保元素存在再添加事件監聽器
            if (cardFrontImageInput) {
                // 前面圖片處理
                cardFrontImageInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    frontImageName.textContent = file.name;
                    frontImagePreview.classList.remove('hidden');

                    // 顯示載入中狀態
                    frontPreviewImg.src = ''; // 清空之前的圖片
                    frontPreviewImg.style.display = 'none';
                    const loadingIndicator = document.createElement('div');
                    loadingIndicator.className = 'text-center py-2';
                    loadingIndicator.textContent = '處理圖片中...';
                    frontImagePreview.appendChild(loadingIndicator);

                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            // 進行智能壓縮
                            const compressedDataUrl = await analyzeAndCompressImage(e.target.result);

                            // 更新圖片數據和預覽
                            frontImageData = compressedDataUrl;

                            // 移除載入指示器
                            if (loadingIndicator.parentNode) {
                                loadingIndicator.parentNode.removeChild(loadingIndicator);
                            }

                            // 顯示圖片預覽
                            frontPreviewImg.src = compressedDataUrl;
                            frontPreviewImg.style.display = 'block';

                        } catch (error) {
                            console.error('圖片處理錯誤:', error);
                            frontImagePreview.innerHTML = `
                                <div class="text-red-500">圖片處理失敗</div>
                            `;
                        }
                    };
                    reader.readAsDataURL(file);
                });
            }

            if (cardBackImageInput) {
                // 背面圖片處理
                cardBackImageInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    backImageName.textContent = file.name;
                    backImagePreview.classList.remove('hidden');

                    // 顯示載入中狀態
                    backPreviewImg.src = '';
                    backPreviewImg.style.display = 'none';
                    const loadingIndicator = document.createElement('div');
                    loadingIndicator.className = 'text-center py-2';
                    loadingIndicator.textContent = '處理圖片中...';
                    backImagePreview.appendChild(loadingIndicator);

                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            // 進行智能壓縮
                            const compressedDataUrl = await analyzeAndCompressImage(e.target.result);

                            // 更新圖片數據和預覽
                            backImageData = compressedDataUrl;

                            // 移除載入指示器
                            if (loadingIndicator.parentNode) {
                                loadingIndicator.parentNode.removeChild(loadingIndicator);
                            }

                            // 顯示圖片預覽
                            backPreviewImg.src = compressedDataUrl;
                            backPreviewImg.style.display = 'block';

                        } catch (error) {
                            console.error('圖片處理錯誤:', error);
                            backImagePreview.innerHTML = `
                                <div class="text-red-500">圖片處理失敗</div>
                            `;
                        }
                    };
                    reader.readAsDataURL(file);
                });
            }

            if (editCardFrontImage) {
                // 編輯正面圖片處理
                editCardFrontImage.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    editFrontImagePreview.classList.remove('hidden');

                    // 顯示載入中狀態
                    editFrontPreviewImg.src = '';
                    editFrontPreviewImg.style.display = 'none';
                    const loadingIndicator = document.createElement('div');
                    loadingIndicator.className = 'text-center py-2';
                    loadingIndicator.textContent = '處理圖片中...';
                    editFrontImagePreview.appendChild(loadingIndicator);

                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            // 進行智能壓縮
                            const compressedDataUrl = await analyzeAndCompressImage(e.target.result);

                            // 更新圖片數據和預覽
                            editFrontImageData = compressedDataUrl;

                            // 移除載入指示器
                            if (loadingIndicator.parentNode) {
                                loadingIndicator.parentNode.removeChild(loadingIndicator);
                            }

                            // 顯示圖片預覽
                            editFrontPreviewImg.src = compressedDataUrl;
                            editFrontPreviewImg.style.display = 'block';

                        } catch (error) {
                            console.error('圖片處理錯誤:', error);
                            editFrontImagePreview.innerHTML = `
                                <div class="text-red-500">圖片處理失敗</div>
                            `;
                        }
                    };
                    reader.readAsDataURL(file);
                });
            }

            if (editCardBackImage) {
                // 編輯背面圖片處理
                editCardBackImage.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    editBackImagePreview.classList.remove('hidden');

                    // 顯示載入中狀態
                    editBackPreviewImg.src = '';
                    editBackPreviewImg.style.display = 'none';
                    const loadingIndicator = document.createElement('div');
                    loadingIndicator.className = 'text-center py-2';
                    loadingIndicator.textContent = '處理圖片中...';
                    editBackImagePreview.appendChild(loadingIndicator);

                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            // 進行智能壓縮
                            const compressedDataUrl = await analyzeAndCompressImage(e.target.result);

                            // 更新圖片數據和預覽
                            editBackImageData = compressedDataUrl;

                            // 移除載入指示器
                            if (loadingIndicator.parentNode) {
                                loadingIndicator.parentNode.removeChild(loadingIndicator);
                            }

                            // 顯示圖片預覽
                            editBackPreviewImg.src = compressedDataUrl;
                            editBackPreviewImg.style.display = 'block';

                        } catch (error) {
                            console.error('圖片處理錯誤:', error);
                            editBackImagePreview.innerHTML = `
                                <div class="text-red-500">圖片處理失敗</div>
                            `;
                        }
                    };
                    reader.readAsDataURL(file);
                });
            }
        }

        // 設置拖放上傳功能
        function setupDragAndDrop() {
            // 獲取拖放區域元素
            const frontDragArea = document.getElementById('frontDragArea');
            const backDragArea = document.getElementById('backDragArea');

            if (frontDragArea && cardFrontImageInput) {
                setupDragArea(frontDragArea, cardFrontImageInput);
            }

            if (backDragArea && cardBackImageInput) {
                setupDragArea(backDragArea, cardBackImageInput);
            }

            // 同樣為編輯模式設置拖放區
            const editFrontDragArea = document.getElementById('editFrontDragArea');
            const editBackDragArea = document.getElementById('editBackDragArea');

            if (editFrontDragArea && editCardFrontImage) {
                setupDragArea(editFrontDragArea, editCardFrontImage);
            }

            if (editBackDragArea && editCardBackImage) {
                setupDragArea(editBackDragArea, editCardBackImage);
            }
        }

        function setupDragArea(dragArea, fileInput) {
            // 阻止默認拖放行為以允許自定義處理
            dragArea.addEventListener('dragenter', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragArea.querySelector('.drag-overlay').style.display = 'block';
            });

            dragArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });

            dragArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // 檢查是否真的離開了元素
                const rect = dragArea.getBoundingClientRect();
                const x = e.clientX;
                const y = e.clientY;

                if (x < rect.left || x >= rect.right || y < rect.top || y >= rect.bottom) {
                    dragArea.querySelector('.drag-overlay').style.display = 'none';
                }
            });

            dragArea.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                dragArea.querySelector('.drag-overlay').style.display = 'none';

                if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];

                    // 檢查是否為圖片
                    if (file.type.match('image.*')) {
                        // 使用現有的檔案輸入框處理圖片
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(file);
                        fileInput.files = dataTransfer.files;

                        // 觸發 change 事件以處理圖片
                        const event = new Event('change', { bubbles: true });
                        fileInput.dispatchEvent(event);
                    } else {
                        showNotification('請上傳圖片檔案');
                    }
                }
            });
        }

        // Storage reminder functions
        function showStorageReminder() {
            if (!reminderShown && (cardsData.length > 0 || decksData.length > 0)) {
                storageReminder.classList.remove('hidden');
                reminderShown = true;

                // 設置提醒按鈕事件
                exportReminderBtn.addEventListener('click', () => {
                    openExportModal();
                    storageReminder.classList.add('hidden');
                });

                dismissReminderBtn.addEventListener('click', () => {
                    storageReminder.classList.add('hidden');
                });
            }
        }

        // Show storage reminder periodically
        function setupStorageReminders() {
            // 當有資料後每 10 分鐘提醒一次
            setInterval(() => {
                if (cardsData.length > 0 || decksData.length > 0) {
                    reminderShown = false;
                    showStorageReminder();
                }
            }, 10 * 60 * 1000);

            // 當有資料變動時提醒
            const checkForReminder = () => {
                if (cardsData.length > 0 || decksData.length > 0) {
                    showStorageReminder();
                }
            };

            // 5秒後檢查是否需要顯示提醒
            setTimeout(checkForReminder, 5000);
        }

        // Card batch selection handlers
        selectAllCards.addEventListener('change', function() {
            const checkboxes = document.querySelectorAll('.card-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = this.checked;
                const cardId = parseInt(checkbox.value);
                if (this.checked) {
                    selectedCardIds.add(cardId);
                } else {
                    selectedCardIds.delete(cardId);
                }
            });
            updateBatchDeleteButton();
        });

        // Deck batch selection handlers
        selectAllDecks.addEventListener('change', function() {
            const checkboxes = document.querySelectorAll('.deck-checkbox');
            checkboxes.forEach(checkbox => {
                checkbox.checked = this.checked;
                const deckId = parseInt(checkbox.value);
                if (this.checked) {
                    selectedDeckIds2.add(deckId);
                } else {
                    selectedDeckIds2.delete(deckId);
                }
            });
            updateBatchDeleteDecksButton();
        });

        // Batch delete button
        deleteBatchCardsBtn.addEventListener('click', deleteSelectedCards);
        deleteBatchDecksBtn.addEventListener('click', deleteSelectedDecks);

        // Create new deck button
        createNewDeckBtn.addEventListener('click', openNewDeckModal);
        createFirstDeckLink.addEventListener('click', (e) => {
            e.preventDefault();
            openNewDeckModal();
        });

        // Add Deck in Manage section
        addDeckInManageBtn.addEventListener('click', openNewDeckModal);

        // New deck modal handlers
        closeNewDeckBtn.addEventListener('click', closeNewDeckModal);
        saveNewDeckBtn.addEventListener('click', saveNewDeck);

        // Import/Export Handlers
        exportDataBtn.addEventListener('click', openExportModal);
        cancelExportBtn.addEventListener('click', closeExportModal);
        confirmExportBtn.addEventListener('click', exportData);
        importDataInput.addEventListener('change', handleImportFile);

        // Export Excel Handlers
        exportExcelBtn.addEventListener('click', openExportExcelModal);
        cancelExportExcelBtn.addEventListener('click', closeExportExcelModal);
        confirmExportExcelBtn.addEventListener('click', exportExcelData);

        // Excel export deck selection handlers
        selectAllExportExcelDecksBtn.addEventListener('click', selectAllExportExcelDecks);
        deselectAllExportExcelDecksBtn.addEventListener('click', deselectAllExportExcelDecks);

        // Import preview handlers
        cancelImportBtn.addEventListener('click', closeImportPreviewModal);
        confirmImportBtn.addEventListener('click', processImport);

        // Export deck selection handlers
        selectAllExportDecksBtn.addEventListener('click', selectAllExportDecks);
        deselectAllExportDecksBtn.addEventListener('click', deselectAllExportDecks);

        // Import deck selection handlers
        selectAllImportDecksBtn.addEventListener('click', selectAllImportDecks);
        deselectAllImportDecksBtn.addEventListener('click', deselectAllImportDecks);

        // Delete All buttons with confirmation
        deleteAllCardsBtn.addEventListener('click', function() {
            customConfirm('確定要刪除所有字卡嗎？此操作無法撤銷。', '刪除所有字卡', function(confirmed) {
                if (confirmed) {
                    deleteAllCards();
                }
            });
        });

        deleteAllDecksBtn.addEventListener('click', function() {
            customConfirm('確定要刪除所有卡組嗎？此操作無法撤銷，所有字卡也將被刪除。', '刪除所有卡組', function(confirmed) {
                if (confirmed) {
                    deleteAllDecks();
                }
            });
        });

        // Function to select all export Excel decks
        function selectAllExportExcelDecks() {
            const checkboxes = exportExcelDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                selectedExportExcelDeckIds.push(parseInt(checkbox.value));
            });

            // Remove duplicates
            selectedExportExcelDeckIds = [...new Set(selectedExportExcelDeckIds)];
        }

        // Function to deselect all export Excel decks
        function deselectAllExportExcelDecks() {
            const checkboxes = exportExcelDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            selectedExportExcelDeckIds = [];
        }

        // Function to open export Excel modal
        function openExportExcelModal() {
            // Reset selected decks
            selectedExportExcelDeckIds = [];

            // Set default filename with current date
            const now = new Date();
            const dateStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}`;
            exportExcelFilenameInput.value = `flashcards_${dateStr}`;

            // Load deck selection list
            loadExportExcelDecksList();

            // Show modal
            exportExcelModal.classList.remove('hidden');

            // Add click outside to close functionality
            document.addEventListener('click', handleExportExcelModalOutsideClick);
        }

        // Function to load decks for Excel export selection
        function loadExportExcelDecksList() {
            exportExcelDecksList.innerHTML = '';

            if (decksData.length === 0) {
                exportExcelDecksList.innerHTML = '<div class="text-center py-4 text-gray-500 dark:text-gray-400">沒有可用的卡組。</div>';
                return;
            }

            // Sort decks by name for easier selection
            const sortedDecks = [...decksData].sort((a, b) => a.name.localeCompare(b.name));

            // By default, select all decks
            selectedExportExcelDeckIds = sortedDecks.map(deck => deck.id);

            sortedDecks.forEach(deck => {
                const deckItem = document.createElement('div');
                deckItem.className = 'flex items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';

                const cardCount = deck.cardIds.length;

                deckItem.innerHTML = `
                    <input type="checkbox" id="export-excel-deck-${deck.id}" value="${deck.id}" class="mr-2" checked>
                    <label for="export-excel-deck-${deck.id}" class="flex-1 flex justify-between items-center cursor-pointer">
                        <span>${deck.name}</span>
                        <span class="text-xs text-gray-500 dark:text-gray-400">${cardCount} 張字卡</span>
                    </label>
                `;

                exportExcelDecksList.appendChild(deckItem);

                // Add change event for checkbox
                const checkbox = deckItem.querySelector(`#export-excel-deck-${deck.id}`);
                checkbox.addEventListener('change', function() {
                    const deckId = parseInt(this.value);
                    if (this.checked) {
                        if (!selectedExportExcelDeckIds.includes(deckId)) {
                            selectedExportExcelDeckIds.push(deckId);
                        }
                    } else {
                        selectedExportExcelDeckIds = selectedExportExcelDeckIds.filter(id => id !== deckId);
                    }
                });
            });
        }

        // Function to close export Excel modal
        function closeExportExcelModal() {
            exportExcelModal.classList.add('hidden');
            document.removeEventListener('click', handleExportExcelModalOutsideClick);
        }

        // Handle click outside the export Excel modal to close it
        function handleExportExcelModalOutsideClick(event) {
            const modalContent = exportExcelModal.querySelector('div');
            if (exportExcelModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeExportExcelModal();
            }
        }

        // Function to export Excel data
        function exportExcelData() {
            if (selectedExportExcelDeckIds.length === 0) {
                showNotification('請至少選擇一個卡組進行導出');
                return;
            }

            const filename = exportExcelFilenameInput.value.trim() || 'flashcards';

            // Filter selected decks
            const selectedDecks = decksData.filter(deck => selectedExportExcelDeckIds.includes(deck.id));

            // Create workbook
            const wb = XLSX.utils.book_new();

            // Process each selected deck
            selectedDecks.forEach(deck => {
                // Get cards for this deck
                const deckCards = cardsData.filter(card => deck.cardIds.includes(card.id));

                // Prepare data for worksheet
                const sheetData = [
                    ['正面內容', '背面內容'] // Header row
                ];

                // Add cards data
                deckCards.forEach(card => {
                    // 從HTML內容中提取純文本
                    const frontText = stripHtml(card.frontText || '');
                    const backText = stripHtml(card.backText || '');

                    sheetData.push([frontText, backText]);
                });

                // Create worksheet and add to workbook
                const ws = XLSX.utils.aoa_to_sheet(sheetData);

                // 確保工作表名稱合法 (Excel工作表名稱最多31個字符，且不能包含某些特殊字符)
                let sheetName = deck.name;
                if (sheetName.length > 31) sheetName = sheetName.substring(0, 28) + '...';
                sheetName = sheetName.replace(/[\[\]\*\/\\\?:]/g, '_'); // 替換不允許的字符

                XLSX.utils.book_append_sheet(wb, ws, sheetName);
            });

            // Add timestamp to filename to make it unique
            const filenameSuffix = new Date().toISOString().replace(/[-:.]/g, '').substring(0, 14);
            const fullFilename = `${filename}_${filenameSuffix}.xlsx`;

            // Generate and download Excel file
            XLSX.writeFile(wb, fullFilename);

            closeExportExcelModal();
            showNotification(`成功導出 ${selectedDecks.length} 個卡組至Excel檔案`);
        }

        // Function to delete all cards
        function deleteAllCards() {
            // If a deck filter is active, only delete cards from that deck
            const selectedDeckId = deckFilterSelect.value;

            if (selectedDeckId !== 'all') {
                const deckId = parseInt(selectedDeckId);
                const deck = decksData.find(d => d.id === deckId);

                if (deck) {
                    // Remove cards from the deck
                    const deckCards = [...deck.cardIds];
                    deck.cardIds = [];

                    // If cards are only in this deck, remove them from cardsData
                    deckCards.forEach(cardId => {
                        // Check if card exists in other decks
                        const existsInOtherDecks = decksData.some(d => d.id !== deckId && d.cardIds.includes(cardId));

                        if (!existsInOtherDecks) {
                            cardsData = cardsData.filter(card => card.id !== cardId);
                        }
                    });
                }
            } else {
                // Delete all cards globally
                cardsData = [];
                // Also remove all cards from all decks
                decksData.forEach(deck => {
                    deck.cardIds = [];
                });
            }

            // Clear selection
            selectedCardIds.clear();
            updateBatchDeleteButton();

            // Refresh UI
            loadAllCards();
            showNotification('已刪除所有字卡');

            // Show storage reminder
            showStorageReminder();
        }

        // Function to delete all decks
        function deleteAllDecks() {
            decksData = [];
            cardsData = [];

            // Clear selection
            selectedDeckIds2.clear();
            updateBatchDeleteDecksButton();

            // Refresh UI
            loadAllDecks();
            loadDeckList();
            showNotification('已刪除所有卡組');

            // Show storage reminder
            showStorageReminder();
        }

        // Function to select all export decks
        function selectAllExportDecks() {
            const checkboxes = exportDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                selectedExportDeckIds.push(parseInt(checkbox.value));
            });

            // Remove duplicates
            selectedExportDeckIds = [...new Set(selectedExportDeckIds)];
        }

        // Function to deselect all export decks
        function deselectAllExportDecks() {
            const checkboxes = exportDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            selectedExportDeckIds = [];
        }

        // Function to select all import decks
        function selectAllImportDecks() {
            const checkboxes = importDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
                selectedImportDeckIds.push(checkbox.value);
            });

            // Remove duplicates
            selectedImportDeckIds = [...new Set(selectedImportDeckIds)];
        }

        // Function to deselect all import decks
        function deselectAllImportDecks() {
            const checkboxes = importDecksList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            selectedImportDeckIds = [];
        }

        // Function to open export modal
        function openExportModal() {
            // Reset selected decks
            selectedExportDeckIds = [];

            // Set default filename with current date
            const now = new Date();
            const dateStr = `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}`;
            exportFilenameInput.value = `flashcards_${dateStr}`;

            // Load deck selection list
            loadExportDecksList();

            // Show modal
            exportModal.classList.remove('hidden');

            // Add click outside to close functionality
            document.addEventListener('click', handleExportModalOutsideClick);
        }

        // Function to load decks for export selection
        function loadExportDecksList() {
            exportDecksList.innerHTML = '';

            if (decksData.length === 0) {
                exportDecksList.innerHTML = '<div class="text-center py-4 text-gray-500 dark:text-gray-400">沒有可用的卡組。</div>';
                return;
            }

            // Sort decks by name for easier selection
            const sortedDecks = [...decksData].sort((a, b) => a.name.localeCompare(b.name));

            // By default, select all decks
            selectedExportDeckIds = sortedDecks.map(deck => deck.id);

            sortedDecks.forEach(deck => {
                const deckItem = document.createElement('div');
                deckItem.className = 'flex items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';

                const cardCount = deck.cardIds.length;

                deckItem.innerHTML = `
                    <input type="checkbox" id="export-deck-${deck.id}" value="${deck.id}" class="mr-2" checked>
                    <label for="export-deck-${deck.id}" class="flex-1 flex justify-between items-center cursor-pointer">
                        <span>${deck.name}</span>
                        <span class="text-xs text-gray-500 dark:text-gray-400">${cardCount} 張字卡</span>
                    </label>
                `;

                exportDecksList.appendChild(deckItem);

                // Add change event for checkbox
                const checkbox = deckItem.querySelector(`#export-deck-${deck.id}`);
                checkbox.addEventListener('change', function() {
                    const deckId = parseInt(this.value);
                    if (this.checked) {
                        if (!selectedExportDeckIds.includes(deckId)) {
                            selectedExportDeckIds.push(deckId);
                        }
                    } else {
                        selectedExportDeckIds = selectedExportDeckIds.filter(id => id !== deckId);
                    }
                });
            });
        }

        // Function to close export modal
        function closeExportModal() {
            exportModal.classList.add('hidden');
            document.removeEventListener('click', handleExportModalOutsideClick);
        }

        // Function to handle import file
        function handleImportFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const data = JSON.parse(event.target.result);

                    // Store data temporarily
                    importDataCache = data;

                    // Open import preview modal
                    openImportPreviewModal(data);
                } catch (error) {
                    showNotification('匯入失敗：無效的 JSON 格式');
                    console.error('Import error:', error);
                }

                // Reset the file input
                e.target.value = '';
            };
            reader.readAsText(file);
        }

        // Function to open import preview modal
        function openImportPreviewModal(data) {
            // Reset selected decks
            selectedImportDeckIds = [];

            // Check data format
            if (!data.decksData) {
                showNotification('匯入失敗：無效的數據格式');
                return;
            }

            // Load import deck list
            loadImportPreviewList(data);

            // Show modal
            importPreviewModal.classList.remove('hidden');

            // Add click outside to close functionality
            document.addEventListener('click', handleImportModalOutsideClick);
        }

        // Function to load import preview list
        function loadImportPreviewList(data) {
            importDecksList.innerHTML = '';

            if (!data.decksData || data.decksData.length === 0) {
                importDecksList.innerHTML = '<div class="text-center py-4 text-gray-500 dark:text-gray-400">檔案中沒有卡組。</div>';
                return;
            }

            // By default, select all decks
            selectedImportDeckIds = data.decksData.map(deck => deck.id.toString());

            data.decksData.forEach(deck => {
                // Check if this deck conflicts with existing decks
                const conflict = decksData.some(existingDeck => existingDeck.name === deck.name);

                // Get cards related to this deck
                const deckCards = data.cardsData.filter(card => deck.cardIds.includes(card.id));

                const deckItem = document.createElement('div');
                deckItem.className = `flex items-start p-2 bg-gray-100 dark:bg-gray-700 rounded ${conflict ? 'border-l-4 border-yellow-500' : ''}`;

                deckItem.innerHTML = `
                    <input type="checkbox" id="import-deck-${deck.id}" value="${deck.id}" class="mr-2 mt-1" checked>
                    <div class="flex-1">
                        <label for="import-deck-${deck.id}" class="flex justify-between items-center cursor-pointer">
                            <span class="font-medium">${deck.name}</span>
                            <span class="text-xs text-gray-500 dark:text-gray-400">${deckCards.length} 張字卡</span>
                        </label>
                        ${deck.description ? `<p class="text-xs text-gray-600 dark:text-gray-400 mt-1">${deck.description}</p>` : ''}
                        ${conflict ? `<p class="text-xs text-yellow-600 dark:text-yellow-400 mt-1">注意：與現有卡組名稱衝突</p>` : ''}
                    </div>
                `;

                importDecksList.appendChild(deckItem);

                // Add change event for checkbox
                const checkbox = deckItem.querySelector(`#import-deck-${deck.id}`);
                checkbox.addEventListener('change', function() {
                    const deckId = this.value;
                    if (this.checked) {
                        if (!selectedImportDeckIds.includes(deckId)) {
                            selectedImportDeckIds.push(deckId);
                        }
                    } else {
                        selectedImportDeckIds = selectedImportDeckIds.filter(id => id !== deckId);
                    }
                });
            });
        }

        // Function to close import preview modal
        function closeImportPreviewModal() {
            importPreviewModal.classList.add('hidden');
            document.removeEventListener('click', handleImportModalOutsideClick);

            // Clear temp import data
            importDataCache = null;
            selectedImportDeckIds = [];
        }

        // Function to process import based on selection
        function processImport() {
            if (!importDataCache || selectedImportDeckIds.length === 0) {
                closeImportPreviewModal();
                return;
            }

            // Get conflict resolution strategy
            const conflictResolution = document.querySelector('input[name="conflictResolution"]:checked').value;

            // Filter selected decks from import data
            const selectedDecks = importDataCache.decksData.filter(deck =>
                selectedImportDeckIds.includes(deck.id.toString())
            );

            // Process each selected deck
            selectedDecks.forEach(importDeck => {
                // Check for name conflict
                const conflictDeckIndex = decksData.findIndex(deck => deck.name === importDeck.name);

                if (conflictDeckIndex !== -1) {
                    // Handle conflict according to selected strategy
                    switch (conflictResolution) {
                        case 'overwrite':
                            // Keep the deck ID but update all other properties
                            const existingDeckId = decksData[conflictDeckIndex].id;
                            importDeck.id = existingDeckId; // preserve original ID
                            decksData[conflictDeckIndex] = importDeck;
                            break;

                        case 'rename':
                            // Add a number suffix to make the name unique
                            let counter = 1;
                            let newName = `${importDeck.name} (${counter})`;

                            while (decksData.some(deck => deck.name === newName)) {
                                counter++;
                                newName = `${importDeck.name} (${counter})`;
                            }

                            importDeck.name = newName;
                            decksData.push(importDeck);
                            break;

                        case 'merge':
                            // Merge cards from import deck to existing deck
                            const existingDeck = decksData[conflictDeckIndex];

                            // Add cards from import deck
                            importDeck.cardIds.forEach(cardId => {
                                if (!existingDeck.cardIds.includes(cardId)) {
                                    existingDeck.cardIds.push(cardId);
                                }
                            });
                            break;

                        case 'skip':
                            // Skip this deck entirely
                            return;
                    }
                } else {
                    // No conflict, simply add the deck
                    decksData.push(importDeck);
                }

                // Import cards related to this deck
                if (importDataCache.cardsData) {
                    const deckCards = importDataCache.cardsData.filter(card =>
                        importDeck.cardIds.includes(card.id)
                    );

                    deckCards.forEach(importCard => {
                        // Check if card already exists (by ID)
                        const existingCardIndex = cardsData.findIndex(card => card.id === importCard.id);

                        if (existingCardIndex !== -1) {
                            // Update existing card if conflict resolution is 'overwrite' or 'merge'
                            if (conflictResolution === 'overwrite' || conflictResolution === 'merge') {
                                cardsData[existingCardIndex] = importCard;
                            }
                        } else {
                            // Add new card
                            cardsData.push(importCard);
                        }
                    });
                }
            });

            // 關閉模態框並刷新UI
            closeImportPreviewModal();

            // 無論當前在哪個頁面，都預先更新複習頁面的卡組列表
            loadDeckList();

            // 根據當前頁面刷新UI其他部分
            if (!reviewSection.classList.contains('hidden')) {
                // 如果當前在複習頁面，確保卡組列表可見
                showReviewStage('deckSelection');
            } else if (!manageDeckSection.classList.contains('hidden')) {
                loadAllDecks();
            } else if (!manageCardSection.classList.contains('hidden')) {
                loadDeckFilterOptions();
                loadAllCards();
            }

            showNotification('數據匯入成功！');

            // 清除緩存的導入數據
            importDataCache = null;
        }

        // Function to open new deck modal
        function openNewDeckModal() {
            // Reset fields
            newDeckNameInput.value = '';
            newDeckDescriptionInput.value = '';

            // Show modal
            newDeckModal.classList.remove('hidden');

            // Focus on name input
            setTimeout(() => {
                newDeckNameInput.focus();
            }, 100);

            // Add click outside to close functionality
            document.addEventListener('click', handleNewDeckModalOutsideClick);
        }

        // Function to close new deck modal
        function closeNewDeckModal() {
            newDeckModal.classList.add('hidden');
            document.removeEventListener('click', handleNewDeckModalOutsideClick);
        }

        // Function to save new deck from modal
        // 修改saveNewDeck函數
        function saveNewDeck() {
            const name = newDeckNameInput.value.trim();
            const description = newDeckDescriptionInput.value.trim();

            if (name) {
                const newDeck = {
                    id: Date.now(),
                    name: name,
                    description: description || '',
                    cardIds: [],
                    createdAt: Date.now()
                };

                decksData.push(newDeck);

                // 更新部分：處理在建立字卡頁面建立卡組的情況
                if (!createCardSection.classList.contains('hidden')) {
                    // 當前在建立字卡頁面
                    selectedDeckIds = [newDeck.id]; // 只選擇新建立的卡組

                    // 隱藏警告提示
                    noDeckWarning.classList.add('hidden');

                    // 顯示字卡製作表單和卡組選擇區
                    deckSelectionForCard.classList.remove('hidden');
                    cardForm.classList.remove('hidden');

                    // 更新選定的卡組顯示
                    updateSelectedDecksDisplay();

                    // 初始化搜索功能
                    initSearchableDeckSelector();

                    // 聚焦到字卡正面輸入框，方便用戶直接開始輸入
                    setTimeout(() => {
                        if (frontQuill) {
                            frontQuill.focus();
                        }
                    }, 100);
                }

                closeNewDeckModal();
                showNotification('卡組建立成功');

                // 刷新相關部分
                loadDeckFilterOptions();
                loadDeckList();
                loadAllDecks();

                // 【關鍵新增】
                saveDataToLocalStorage();

                // 顯示存儲提醒
                showStorageReminder();
            } else {
                showNotification('請至少輸入卡組名稱');
            }
        }

        // Handle click outside the new deck modal to close it
        function handleNewDeckModalOutsideClick(event) {
            const modalContent = newDeckModal.querySelector('div');
            if (newDeckModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeNewDeckModal();
            }
        }

        // Handle click outside the export modal to close it
        function handleExportModalOutsideClick(event) {
            const modalContent = exportModal.querySelector('div');
            if (exportModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeExportModal();
            }
        }

        // Handle click outside the import modal to close it
        function handleImportModalOutsideClick(event) {
            const modalContent = importPreviewModal.querySelector('div');
            if (importPreviewModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeImportPreviewModal();
            }
        }

        // Update batch delete button visibility and count
        function updateBatchDeleteButton() {
            selectedCardCount.textContent = selectedCardIds.size;
            if (selectedCardIds.size > 0) {
                deleteBatchCardsBtn.classList.remove('hidden');
            } else {
                deleteBatchCardsBtn.classList.add('hidden');
            }
        }

        // Update batch merge button visibility and count
        function updateBatchMergeButton() {
            mergeSelectedDeckCount.textContent = selectedDeckIds2.size;
            if (selectedDeckIds2.size >= 2) {
                mergeBatchDecksBtn.classList.remove('hidden');
            } else {
                mergeBatchDecksBtn.classList.add('hidden');
            }
        }

        // Update batch delete decks button visibility and count
        function updateBatchDeleteDecksButton() {
            selectedDeckCount.textContent = selectedDeckIds2.size;
            if (selectedDeckIds2.size > 0) {
                deleteBatchDecksBtn.classList.remove('hidden');
            } else {
                deleteBatchDecksBtn.classList.add('hidden');
            }

            // 同時更新合併按鈕
            updateBatchMergeButton();
        }

        // Function to open merge deck modal
        function openMergeDeckModal() {
            if (selectedDeckIds2.size < 2) {
                showNotification('請至少選擇兩個卡組進行合併');
                return;
            }

            mergeCount.textContent = selectedDeckIds2.size;

            // 設置默認的合併後卡組名稱
            const selectedDecks = [];
            selectedDeckIds2.forEach(id => {
                const deck = decksData.find(d => d.id === id);
                if (deck) selectedDecks.push(deck);
            });

            if (selectedDecks.length >= 2) {
                mergedDeckNameInput.value = `${selectedDecks[0].name}+${selectedDecks[1].name}` +
                    (selectedDecks.length > 2 ? `+其他${selectedDecks.length-2}個` : '');
            }

            // 顯示對話框
            mergeDeckModal.classList.remove('hidden');

            // 添加點擊外部關閉功能
            document.addEventListener('click', handleMergeDeckOutsideClick);
        }

        // Function to close merge deck modal
        function closeMergeDeckModal() {
            mergeDeckModal.classList.add('hidden');
            document.removeEventListener('click', handleMergeDeckOutsideClick);
        }

        // Handle click outside the merge deck modal to close it
        function handleMergeDeckOutsideClick(event) {
            const modalContent = mergeDeckModal.querySelector('div');
            if (mergeDeckModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeMergeDeckModal();
            }
        }

        // Function to merge selected decks
        function mergeSelectedDecks() {
            const mergeOption = document.querySelector('input[name="mergeOption"]:checked').value;
            const newDeckName = mergedDeckNameInput.value.trim();

            if (!newDeckName) {
                showNotification('請輸入合併後的卡組名稱');
                return;
            }

            // 收集所有要合併的卡組
            const decksToMerge = [];
            const allCardIds = new Set();

            selectedDeckIds2.forEach(id => {
                const deck = decksData.find(d => d.id === id);
                if (deck) {
                    decksToMerge.push(deck);
                    // 收集所有字卡ID
                    deck.cardIds.forEach(cardId => allCardIds.add(cardId));
                }
            });

            if (mergeOption === 'new') {
                // 創建新的卡組
                const newDeck = {
                    id: Date.now(),
                    name: newDeckName,
                    description: `由 ${decksToMerge.map(d => d.name).join('、')} 合併而成`,
                    cardIds: [...allCardIds],
                    createdAt: Date.now()
                };

                decksData.push(newDeck);
                showNotification(`已創建合併卡組: ${newDeckName}`);
            } else if (mergeOption === 'replace') {
                // 替換第一個卡組
                if (decksToMerge.length > 0) {
                    const targetDeck = decksToMerge[0];
                    targetDeck.name = newDeckName;
                    targetDeck.description = `由 ${decksToMerge.map(d => d.name).join('、')} 合併而成`;
                    targetDeck.cardIds = [...allCardIds];

                    // 刪除其他被合併的卡組
                    for (let i = 1; i < decksToMerge.length; i++) {
                        decksData = decksData.filter(d => d.id !== decksToMerge[i].id);
                    }

                    showNotification(`已合併卡組至: ${newDeckName}`);
                }
            }

            // 清除選擇
            selectedDeckIds2.clear();
            updateBatchDeleteDecksButton();

            // 關閉對話框並刷新UI
            closeMergeDeckModal();
            loadAllDecks();
            loadDeckList();

            // 顯示存儲提醒
            showStorageReminder();

            saveDataToLocalStorage();
        }

        // Delete selected cards
        function deleteSelectedCards() {
            if (selectedCardIds.size === 0) return;

            // Remove selected cards from cardsData
            cardsData = cardsData.filter(card => !selectedCardIds.has(card.id));

            // Remove selected cards from all decks
            decksData.forEach(deck => {
                deck.cardIds = deck.cardIds.filter(id => !selectedCardIds.has(id));
            });

            // Clear selection
            selectedCardIds.clear();
            updateBatchDeleteButton();

            // Update UI
            loadAllCards();
            showNotification(`已刪除所選字卡`);

            // Show storage reminder as data has changed
            showStorageReminder();

            saveDataToLocalStorage();
        }

        // Delete selected decks
        function deleteSelectedDecks() {
            if (selectedDeckIds2.size === 0) return;

            customConfirm(`確定要刪除選中的 ${selectedDeckIds2.size} 個卡組嗎？`, '刪除卡組', function(confirmed) {
                if (confirmed) {
                    // Get all card IDs from selected decks
                    const cardsToDelete = new Set();
                    selectedDeckIds2.forEach(deckId => {
                        const deck = decksData.find(d => d.id === deckId);
                        if (deck) {
                            // Check if cards are used in other decks
                            deck.cardIds.forEach(cardId => {
                                // Only mark for deletion if not in other unselected decks
                                const isInOtherDecks = decksData.some(d =>
                                    !selectedDeckIds2.has(d.id) && d.cardIds.includes(cardId)
                                );
                                if (!isInOtherDecks) {
                                    cardsToDelete.add(cardId);
                                }
                            });
                        }
                    });

                    // Remove selected decks
                    decksData = decksData.filter(deck => !selectedDeckIds2.has(deck.id));

                    // Remove cards that were only in the deleted decks
                    cardsData = cardsData.filter(card => !cardsToDelete.has(card.id));

                    // Clear selection
                    selectedDeckIds2.clear();
                    updateBatchDeleteDecksButton();

                    // Update UI
                    loadAllDecks();
                    loadDeckList();
                    showNotification('已刪除選中的卡組');

                    // Show storage reminder
                    showStorageReminder();

                    saveDataToLocalStorage();
                }
            });
        }

        // Function to export data
        function exportData() {
            if (selectedExportDeckIds.length === 0) {
                showNotification('請至少選擇一個卡組進行匯出');
                return;
            }

            const filename = exportFilenameInput.value.trim() || 'flashcards_data';

            // Filter selected decks
            const selectedDecks = decksData.filter(deck => selectedExportDeckIds.includes(deck.id));

            // Get all card IDs from selected decks
            const allCardIds = new Set();
            selectedDecks.forEach(deck => {
                deck.cardIds.forEach(cardId => allCardIds.add(cardId));
            });

            // Filter cards related to selected decks
            const selectedCards = cardsData.filter(card => allCardIds.has(card.id));

            // Create the data object to export
            const exportData = {
                version: "1.1",
                type: selectedDecks.length === 1 ? "single_deck" : "multi_deck",
                exportDate: new Date().toISOString(),
                decksData: selectedDecks,
                cardsData: selectedCards
            };

            // Add deck count to filename if multiple decks
            let adjustedFilename = filename;
            if (selectedDecks.length > 1) {
                adjustedFilename = `${filename}_${selectedDecks.length}decks`;
            } else if (selectedDecks.length === 1) {
                adjustedFilename = `${filename}_${selectedDecks[0].name.replace(/[^\w\s]/gi, '_')}`;
            }

            // Convert to JSON string
            const jsonString = JSON.stringify(exportData, null, 2);

            // Create a blob and download link
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            // Create a temporary link element and trigger download
            const a = document.createElement('a');
            a.href = url;
            a.download = `${adjustedFilename}.json`;
            document.body.appendChild(a);
            a.click();

            // Clean up
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);

            closeExportModal();
            showNotification(`已匯出 ${selectedDecks.length} 個卡組`);
        }

        // Add sort change event listeners
        deckSortSelect.addEventListener('change', (e) => {
            deckSortPreference = e.target.value;
            loadDeckList();
        });

        manageDeckSortSelect.addEventListener('change', (e) => {
            manageDeckSortPreference = e.target.value;
            loadAllDecks();
        });

        // Merge Decks button
        mergeBatchDecksBtn.addEventListener('click', openMergeDeckModal);
        closeMergeDeckBtn.addEventListener('click', closeMergeDeckModal);
        saveMergeDeckBtn.addEventListener('click', mergeSelectedDecks);

        // Add search input event listeners
        deckSearchInput.addEventListener('input', () => {
            loadDeckList();
        });

        cardSearchInput.addEventListener('input', () => {
            loadAllCards();
        });

        manageDeckSearchInput.addEventListener('input', () => {
            loadAllDecks();
        });

        // Navigation handlers
        reviewBtn.addEventListener('click', () => showSection('review'));
        createCardBtn.addEventListener('click', () => showSection('createCard'));
        manageCardBtn.addEventListener('click', () => showSection('manageCard'));
        manageDeckBtn.addEventListener('click', () => showSection('manageDeck'));

        // Flip sides button handler
        flipSidesBtn.addEventListener('click', () => {
            sidesFlipped = !sidesFlipped;
            showCurrentCard();
        });

        // Remove edit front image
        removeEditFrontImage.addEventListener('click', () => {
            editFrontImageData = null;
            editCardFrontImage.value = '';
            editFrontImagePreview.classList.add('hidden');
        });

        // Remove edit back image
        removeEditBackImage.addEventListener('click', () => {
            editBackImageData = null;
            editCardBackImage.value = '';
            editBackImagePreview.classList.add('hidden');
        });

        // Toggle deck dropdown for create card
        // 讓整個選擇區都可以點擊
        const selectedDecksBar = document.querySelector('.multiselect-dropdown .flex.items-center.border');
        if (selectedDecksBar) {
            selectedDecksBar.addEventListener('click', (e) => {
                // 如果點擊的是搜索框本身，不要觸發下拉菜單切換
                if (e.target.id === 'deckSearchForCard') {
                    return;
                }

                // 阻止事件冒泡，防止觸發外部點擊事件
                e.stopPropagation();

                deckOptions.classList.toggle('hidden');

                // 加載卡組選項
                if (!deckOptions.classList.contains('hidden')) {
                    loadDeckOptionsForCard();
                }
            });
        }

        // 添加點擊其他地方時關閉下拉菜單
        document.addEventListener('click', (e) => {
            // 檢查點擊是否在下拉菜單外
            if (!deckOptions.contains(e.target) && !selectedDecksBar.contains(e.target)) {
                deckOptions.classList.add('hidden');
            }
        });

        // 防止點擊選項時關閉菜單
        deckOptions.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // 为卡組选择添加搜索功能
        function initSearchableDeckSelector() {
            // 獲取相關元素
            const selectedDecksContainer = document.getElementById('selectedDecks');
            const selectedDecksPlaceholder = document.getElementById('selectedDecksPlaceholder');

            // 清除所有已存在的搜尋框，防止重複
            const existingSearch = document.getElementById('deckSearchForCard');
            if (existingSearch) {
                existingSearch.remove();
            }

            // 創建搜索輸入框
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.id = 'deckSearchForCard';
            searchInput.placeholder = '搜尋卡組...';
            searchInput.className = 'flex-1 bg-transparent border-none focus:outline-none focus:ring-0 text-base';

            // 確保只替換佔位符而不是整個容器內容
            if (selectedDecksPlaceholder && selectedDecksPlaceholder.parentNode) {
                selectedDecksPlaceholder.parentNode.replaceChild(searchInput, selectedDecksPlaceholder);
            } else if (selectedDecksContainer) {
                // 如果找不到佔位符，但容器存在，先清空再添加
                selectedDecksContainer.innerHTML = '';
                selectedDecksContainer.appendChild(searchInput);
            }

            // 点击整个选择区域时打开下拉菜单
            const selectArea = document.querySelector('.multiselect-dropdown .flex.items-center.border');
            selectArea.addEventListener('click', function(e) {
                // 阻止事件冒泡
                e.stopPropagation();

                // 显示选项菜单
                deckOptions.classList.remove('hidden');

                // 加载选项
                loadDeckOptionsForCard(searchInput.value.trim());

                // 聚焦搜索框
                searchInput.focus();
            });

            // 点击其他区域关闭下拉菜单
            document.addEventListener('click', function(e) {
                if (!deckOptions.contains(e.target) && !selectArea.contains(e.target)) {
                    deckOptions.classList.add('hidden');
                }
            });

            // 设置搜索框事件 - 自動彈出菜單的重點部分
            searchInput.addEventListener('focus', function(e) {
                // 獲得焦點時自動彈出菜單
                e.stopPropagation();
                deckOptions.classList.remove('hidden');
                loadDeckOptionsForCard(this.value.trim());
            });

            searchInput.addEventListener('input', function(e) {
                e.stopPropagation();
                // 確保菜單是開啟的
                deckOptions.classList.remove('hidden');
                loadDeckOptionsForCard(this.value.trim());
            });

            searchInput.addEventListener('click', function(e) {
                // 阻止事件冒泡，防止触发选择区域的点击事件
                e.stopPropagation();
                // 確保點擊時也自動彈出菜單
                deckOptions.classList.remove('hidden');
                loadDeckOptionsForCard(this.value.trim());
            });

            searchInput.addEventListener('keydown', function(e) {
                // ESC键关闭下拉菜单
                if (e.key === 'Escape') {
                    deckOptions.classList.add('hidden');
                }
            });

            // 阻止下拉选项区域的点击事件冒泡
            deckOptions.addEventListener('click', function(e) {
                e.stopPropagation();
            });

            console.log("已初始化可搜索的卡組選擇器");
        }

        // Show section handler
        function showSection(section) {
            // Reset active tab styling
            reviewBtn.classList.remove('border-primary');
            createCardBtn.classList.remove('border-primary');
            manageCardBtn.classList.remove('border-primary');
            manageDeckBtn.classList.remove('border-primary');

            reviewBtn.classList.add('border-transparent');
            createCardBtn.classList.add('border-transparent');
            manageCardBtn.classList.add('border-transparent');
            manageDeckBtn.classList.add('border-transparent');

            // Hide all sections
            reviewSection.classList.add('hidden');
            createCardSection.classList.add('hidden');
            manageCardSection.classList.add('hidden');
            manageDeckSection.classList.add('hidden');

            // Clear all timers when switching sections
            clearAllDrillTimers();

            if (section === 'review') {
                reviewBtn.classList.remove('border-transparent');
                reviewBtn.classList.add('border-primary');
                reviewSection.classList.remove('hidden');
                showReviewStage('deckSelection');
                loadDeckList();
            } else if (section === 'createCard') {
                createCardBtn.classList.remove('border-transparent');
                createCardBtn.classList.add('border-primary');
                createCardSection.classList.remove('hidden');

                // Check if there are decks available
                if (decksData.length === 0) {
                    noDeckWarning.classList.remove('hidden');
                    deckSelectionForCard.classList.add('hidden');
                    cardForm.classList.add('hidden');

                    // 初始化警告中的連結
                    initCreateCardWarningLink();
                } else {
                    noDeckWarning.classList.add('hidden');
                    deckSelectionForCard.classList.remove('hidden');
                    cardForm.classList.remove('hidden');

                    // Update selected decks display (no reset)
                    updateSelectedDecksDisplay();

                    initSearchableDeckSelector();
                }
            } else if (section === 'manageCard') {
                manageCardBtn.classList.remove('border-transparent');
                manageCardBtn.classList.add('border-primary');
                manageCardSection.classList.remove('hidden');
                loadDeckFilterOptions();
                loadAllCards();

                // Reset batch selection
                selectedCardIds.clear();
                updateBatchDeleteButton();
            } else if (section === 'manageDeck') {
                manageDeckBtn.classList.remove('border-transparent');
                manageDeckBtn.classList.add('border-primary');
                manageDeckSection.classList.remove('hidden');
                loadAllDecks();

                // Reset batch selection for decks
                selectedDeckIds2.clear();
                updateBatchDeleteDecksButton();
            }
        }

        // Load deck options for card creation
        function loadDeckOptionsForCard(keyword = '') {
            deckOptions.innerHTML = '';

            // 過濾卡組
            let filteredDecks = decksData;
            if (keyword) {
                keyword = keyword.toLowerCase();
                filteredDecks = decksData.filter(deck =>
                    deck.name.toLowerCase().includes(keyword) ||
                    (deck.description && deck.description.toLowerCase().includes(keyword))
                );
            }

            // 按名稱排序
            filteredDecks.sort((a, b) => a.name.localeCompare(b.name));

            if (filteredDecks.length === 0) {
                const noResultItem = document.createElement('div');
                noResultItem.className = 'p-2 text-gray-500 dark:text-gray-400 text-center';
                noResultItem.textContent = '沒有匹配的卡組';
                deckOptions.appendChild(noResultItem);
                return;
            }

            filteredDecks.forEach(deck => {
                const option = document.createElement('div');
                option.className = `multiselect-option p-2 ${selectedDeckIds.includes(deck.id) ? 'selected' : ''}`;
                option.setAttribute('data-deck-id', deck.id);

                // 顯示卡組名稱和數量
                option.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span>${deck.name}</span>
                        <span class="text-xs text-gray-500 dark:text-gray-400">${deck.cardIds.length} 張</span>
                    </div>
                    ${deck.description ? `<div class="text-xs text-gray-500 dark:text-gray-500">${deck.description}</div>` : ''}
                `;

                option.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const deckId = parseInt(option.getAttribute('data-deck-id'));
                    toggleDeckSelection(deckId);
                    option.classList.toggle('selected');
                    updateSelectedDecksDisplay(); // 使用您原有的更新顯示函數
                });

                deckOptions.appendChild(option);
            });
        }

        // Toggle deck selection for card creation
        function toggleDeckSelection(deckId) {
            const index = selectedDeckIds.indexOf(deckId);
            if (index === -1) {
                selectedDeckIds.push(deckId);
            } else {
                selectedDeckIds.splice(index, 1);
            }

            updateSelectedDecksDisplay();
        }

        // Update selected decks display
        function updateSelectedDecksDisplay() {
            if (selectedDeckIds.length === 0) {
                // 清空容器，但保留可能存在的搜索框
                const searchInput = document.getElementById('deckSearchForCard');
                selectedDecks.innerHTML = '';

                // 如果搜索框不存在，則創建一個新的
                if (!searchInput) {
                    const newSearchInput = document.createElement('input');
                    newSearchInput.type = 'text';
                    newSearchInput.id = 'deckSearchForCard';
                    newSearchInput.placeholder = '搜尋卡組...';
                    newSearchInput.className = 'flex-1 bg-transparent border-none focus:outline-none focus:ring-0 text-base';
                    selectedDecks.appendChild(newSearchInput);

                    // 設置搜索框事件...
                } else {
                    // 如果搜索框存在但不在容器中，則將其添加回容器
                    if (!selectedDecks.contains(searchInput)) {
                        selectedDecks.appendChild(searchInput);
                    }
                }
                return;
            }

            // 保存現有的搜索框（如果有的話）
            const searchInput = document.getElementById('deckSearchForCard');

            // 清空容器
            selectedDecks.innerHTML = '';

            // 如果存在搜索框，先將其添加回去
            if (searchInput) {
                selectedDecks.appendChild(searchInput);
            }

            selectedDecks.innerHTML = '';



            selectedDeckIds.forEach(deckId => {
                const deck = decksData.find(d => d.id === deckId);
                if (!deck) return;

                const tag = document.createElement('span');
                tag.className = 'bg-primary bg-opacity-10 text-primary text-sm px-2 py-1 rounded-full flex items-center';
                tag.innerHTML = `
                    ${deck.name}
                    <button type="button" class="ml-1 focus:outline-none" data-deck-id="${deckId}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;

                // Add removal button event
                tag.querySelector('button').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const deckId = parseInt(e.currentTarget.getAttribute('data-deck-id'));
                    toggleDeckSelection(deckId);

                    // Also update the dropdown options
                    const option = deckOptions.querySelector(`[data-deck-id="${deckId}"]`);
                    if (option) {
                        option.classList.remove('selected');
                    }
                });

                selectedDecks.appendChild(tag);
            });

            // 重新設置搜索框的事件處理
            const searchInputAfter = document.getElementById('deckSearchForCard');
            if (searchInputAfter) {
                searchInputAfter.addEventListener('focus', function(e) {
                    e.stopPropagation();
                    deckOptions.classList.remove('hidden');
                    loadDeckOptionsForCard(this.value.trim());
                });

                searchInputAfter.addEventListener('input', function(e) {
                    e.stopPropagation();
                    deckOptions.classList.remove('hidden');
                    loadDeckOptionsForCard(this.value.trim());
                });

                searchInputAfter.addEventListener('click', function(e) {
                    e.stopPropagation();
                    deckOptions.classList.remove('hidden');
                    loadDeckOptionsForCard(this.value.trim());
                });

                searchInputAfter.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape') {
                        deckOptions.classList.add('hidden');
                    }
                });
            }
        }

        // Load deck filter options
        function loadDeckFilterOptions() {
            // Clear all options except "All"
            while (deckFilterSelect.options.length > 1) {
                deckFilterSelect.remove(1);
            }

            // Add deck options
            decksData.forEach(deck => {
                const option = document.createElement('option');
                option.value = deck.id;
                option.textContent = deck.name;
                deckFilterSelect.appendChild(option);
            });

            // 添加卡組下拉選單變更事件
            deckFilterSelect.addEventListener('change', function() {
                // 當卡組選擇變更時重新載入字卡
                loadAllCards();
            });

        }

        // Show different review stages
        // 在showReviewStage函數中添加視口適應代碼
        function showReviewStage(stage) {
            deckSelection.classList.add('hidden');
            modeSelection.classList.add('hidden');
            reviewInterface.classList.add('hidden');
            reviewCompleteMessage.classList.add('hidden');

            if (stage === 'deckSelection') {
                deckSelection.classList.remove('hidden');

                // 重設視窗滾動位置
                window.scrollTo(0, 0);

                // 將deckList容器設為自適應高度
                deckList.style.maxHeight = 'calc(100vh - 280px)';
                deckList.style.overflowY = 'auto';

            } else if (stage === 'modeSelection') {
                modeSelection.classList.remove('hidden');
                window.scrollTo(0, 0);

            } else if (stage === 'reviewInterface') {
                reviewInterface.classList.remove('hidden');
                window.scrollTo(0, 0);

                // 設置複習界面為彈性布局，自適應螢幕高度
                reviewInterface.classList.add('flex', 'flex-col', 'h-[calc(100vh-170px)]');

                // 調整卡片容器高度
                const availableHeight = window.innerHeight - 220; // 扣除頁頭和其他元素高度
                cardContainer.style.height = `${Math.max(300, availableHeight * 0.6)}px`;

                // 確保評分按鈕在視圖內
                const buttonsContainer = document.getElementById('ratingButtons').parentElement;
                buttonsContainer.classList.add('mt-auto', 'pb-4');

            } else if (stage === 'reviewComplete') {
                reviewCompleteMessage.classList.remove('hidden');
                window.scrollTo(0, 0);
            }
                // 調整表單布局和高度
                cardForm.classList.add('flex', 'flex-col');

                // 調整textarea高度，使其更自適應
                const textareaHeight = window.innerHeight < 700 ? '60px' : '100px';
                document.querySelectorAll('#cardForm textarea').forEach(textarea => {
                    textarea.style.height = textareaHeight;
                });

                // 使預覽圖片更緊湊
                const previewHeight = window.innerHeight < 700 ? '80px' : '150px';
                document.querySelectorAll('#frontPreviewImg, #backPreviewImg').forEach(img => {
                    img.style.maxHeight = previewHeight;
                });

                // 如果是窄屏設備，進一步優化布局
                if (window.innerWidth < 640) {
                    document.querySelectorAll('.input-group').forEach(group => {
                        group.classList.add('flex-col');
                    });
                    document.querySelectorAll('.input-group button').forEach(button => {
                        button.classList.add('mt-2', 'w-full');
                    });
                }

        }

        // Sort decks based on preference
        function sortDecks(decks, preference) {
            const sortedDecks = [...decks];

            switch (preference) {
                case 'name':
                    sortedDecks.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'cards':
                    sortedDecks.sort((a, b) => b.cardIds.length - a.cardIds.length);
                    break;
                case 'date-new':
                    sortedDecks.sort((a, b) => b.createdAt - a.createdAt);
                    break;
                case 'date-old':
                    sortedDecks.sort((a, b) => a.createdAt - b.createdAt);
                    break;
                default:
                    sortedDecks.sort((a, b) => a.name.localeCompare(b.name));
            }

            return sortedDecks;
        }

        // Filter decks by search text
        function filterDecksBySearch(decks, searchText) {
            if (!searchText) return decks;

            const lowerSearchText = searchText.toLowerCase();
            return decks.filter(deck =>
                deck.name.toLowerCase().includes(lowerSearchText) ||
                (deck.description && deck.description.toLowerCase().includes(lowerSearchText))
            );
        }

        // Load deck list for selection
        function loadDeckList() {
            deckList.innerHTML = '';

            if (decksData.length === 0) {
                deckList.innerHTML = `
                    <div class="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">
                        沒有可用的卡組。
                        <a href="#" id="createFirstDeckLink" class="text-primary hover:underline">建立第一個卡組</a>
                    </div>
                `;
                document.getElementById('createFirstDeckLink').addEventListener('click', (e) => {
                    e.preventDefault();
                    openNewDeckModal();
                });
                return;
            }

            // Apply search filter
            const searchText = deckSearchInput.value.trim();
            let filteredDecks = filterDecksBySearch(decksData, searchText);

            // Apply sorting
            const sortedDecks = sortDecks(filteredDecks, deckSortPreference);

            if (sortedDecks.length === 0) {
                deckList.innerHTML = '<div class="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">沒有符合搜尋條件的卡組</div>';
                return;
            }

            sortedDecks.forEach(deck => {
                const cardCount = deck.cardIds.length;
                const deckElement = document.createElement('div');
                deckElement.className = 'bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-300 dark:border-gray-700 cursor-pointer hover:border-primary dark:hover:border-primary';
                deckElement.setAttribute('data-deck-id', deck.id);

                deckElement.innerHTML = `
                    <h3 class="font-medium text-lg mb-1">${deck.name}</h3>
                    <p class="text-gray-600 dark:text-gray-400 text-sm mb-2">${deck.description || '無描述'}</p>
                    <p class="text-xs text-gray-500 dark:text-gray-500">包含 ${cardCount} 張字卡</p>
                `;

                deckElement.addEventListener('click', () => selectDeck(deck.id));
                deckList.appendChild(deckElement);
            });
        }

        // Select a deck for review
        function selectDeck(deckId) {
            const deck = decksData.find(d => d.id === deckId);
            if (!deck) return;

            // 檢查卡組是否為空
            if (deck.cardIds.length === 0) {
                // 自動轉跳到建立字卡頁面
                showSection('createCard');

                // 選中該卡組
                selectedDeckIds = [deckId];

                // 更新選中卡組的顯示
                updateSelectedDecksDisplay();

                // 顯示一個提示，告知用戶已自動轉跳
                showNotification(`已選擇"${deck.name}"卡組。請添加字卡。`);
                return;
            }

            currentDeck = deck;
            showReviewStage('modeSelection');

            // Add mode selection event listeners
            document.querySelectorAll('[data-mode]').forEach(modeElement => {
                modeElement.addEventListener('click', () => {
                    const mode = modeElement.getAttribute('data-mode');
                    selectMode(mode);
                });
            });
        }

        // Select review mode
        function selectMode(mode) {
            currentMode = mode;

            // Reset sides flipped status
            sidesFlipped = false;

            initializeReview();
        }

        // Shuffle an array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // Initialize review session
        function initializeReview() {
            // Reset drill mode counters
            drillReviewedCount = 0;
            reviewCycleCount = 0;

            // Load cards for current deck
            cardsToReview = [];

            // Get all cards from the deck
            const deckCards = [];
            currentDeck.cardIds.forEach(cardId => {
                const card = cardsData.find(c => c.id === cardId);
                if (card) {
                    deckCards.push({...card});
                }
            });

            // Shuffle cards for this review session
            cardsToReview = shuffleArray(deckCards);

            // Update UI
            currentDeckName.textContent = currentDeck.name;
            currentModeName.textContent = currentMode === 'daily' ? '日常模式' : '操練模式';

            // Start review
            currentCardIndex = 0;
            showReviewStage('reviewInterface');

            if (cardsToReview.length > 0) {
                showCurrentCard();
            } else {
                showReviewStage('reviewComplete');
            }

            // Add exit review button handler
            exitReviewBtn.addEventListener('click', () => {
                clearAllDrillTimers();
                showReviewStage('deckSelection');
            });

            // Add restart and choose deck button handlers
            restartDeckBtn.addEventListener('click', () => initializeReview());
            backToDeckSelectionBtn.addEventListener('click', () => showReviewStage('deckSelection'));
        }

        // 創建一個帶有縮放和拖動功能的圖片容器
        function createZoomableImage(imageUrl) {

          // 創建容器
          const container = document.createElement('div');
          container.className = "relative flex justify-center items-center w-full overflow-hidden mt-4"; // 增加頂部間距

            // 創建圖片包裝器用於拖動
            const imageWrapper = document.createElement('div');
            imageWrapper.className = "transform-gpu";

            // 創建圖片
            const img = document.createElement('img');
            img.src = imageUrl;
            img.className = "max-h-70 md:max-h-[28rem] max-w-full object-contain rounded cursor-move";

            // 保存變換狀態
            const transform = {
                scale: 1,
                translateX: 0,
                translateY: 0
            };

            // 拖動狀態
            let isDragging = false;
            let lastX = 0;
            let lastY = 0;

            // 更新圖片變換
            function updateTransform() {
                imageWrapper.style.transform = `translate(${transform.translateX}px, ${transform.translateY}px) scale(${transform.scale})`;
            }

            // 滑鼠拖動處理
            imageWrapper.addEventListener('mousedown', (e) => {
                if (transform.scale <= 1) return; // 只有放大時才能拖動

                isDragging = true;
                lastX = e.clientX;
                lastY = e.clientY;

                // 變更游標樣式
                imageWrapper.style.cursor = 'grabbing';
                e.preventDefault(); // 防止選中文字
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                // 計算移動距離
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;

                // 更新位置
                transform.translateX += deltaX;
                transform.translateY += deltaY;

                // 更新變換
                updateTransform();

                // 更新記錄的位置
                lastX = e.clientX;
                lastY = e.clientY;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    imageWrapper.style.cursor = 'move';
                }
            });

            // 觸控拖動處理
            imageWrapper.addEventListener('touchstart', (e) => {
                if (transform.scale <= 1) return; // 只有放大時才能拖動
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                }
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                if (e.touches.length === 1) {
                    // 計算移動距離
                    const deltaX = e.touches[0].clientX - lastX;
                    const deltaY = e.touches[0].clientY - lastY;

                    // 更新位置
                    transform.translateX += deltaX;
                    transform.translateY += deltaY;

                    // 更新變換
                    updateTransform();

                    // 更新記錄的位置
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                }
            }, { passive: false });

            document.addEventListener('touchend', () => {
                isDragging = false;
            });

            // 創建縮放控制按鈕
            const zoomControls = document.createElement('div');
            zoomControls.className = "absolute top-2 right-2 flex space-x-1 bg-black bg-opacity-50 rounded p-1 z-10";

            // 放大按鈕
            const zoomInBtn = document.createElement('button');
            zoomInBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg>';
            zoomInBtn.className = "focus:outline-none";
            zoomInBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止點擊事件冒泡觸發卡片翻轉

                // 放大
                transform.scale = Math.min(transform.scale + 0.2, 3);

                // 更新變換
                updateTransform();
            });

            // 縮小按鈕
            const zoomOutBtn = document.createElement('button');
            zoomOutBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18 12H6" /></svg>';
            zoomOutBtn.className = "focus:outline-none";
            zoomOutBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止點擊事件冒泡觸發卡片翻轉

                // 縮小
                transform.scale = Math.max(transform.scale - 0.2, 0.5);

                // 如果縮小到原始大小以下，重設位置
                if (transform.scale <= 1) {
                    transform.translateX = 0;
                    transform.translateY = 0;
                }

                // 更新變換
                updateTransform();
            });

            // 重置按鈕
            const resetBtn = document.createElement('button');
            resetBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" /></svg>';
            resetBtn.className = "focus:outline-none";
            resetBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // 防止點擊事件冒泡觸發卡片翻轉

                // 重設變換
                transform.scale = 1;
                transform.translateX = 0;
                transform.translateY = 0;

                // 更新變換
                updateTransform();
            });

            // 添加滾輪縮放支持
            imageWrapper.addEventListener('wheel', function(e) {
                e.preventDefault();
                e.stopPropagation();

                // 計算以滑鼠位置為中心的縮放
                const rect = imageWrapper.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // 獲取滑鼠相對於圖片的比例位置
                const imgX = mouseX - transform.translateX;
                const imgY = mouseY - transform.translateY;

                // 計算滾輪方向的縮放因子
                const delta = e.deltaY < 0 ? 0.1 : -0.1;
                const oldScale = transform.scale;
                transform.scale = Math.min(Math.max(oldScale + delta, 0.5), 3);

                // 如果縮小到原始大小以下，重設位置
                if (transform.scale <= 1) {
                    transform.translateX = 0;
                    transform.translateY = 0;
                } else {
                    // 計算縮放後的偏移量，使滑鼠位置保持在同一點上
                    const scaleRatio = transform.scale / oldScale;
                    const newImgX = imgX * scaleRatio;
                    const newImgY = imgY * scaleRatio;

                    transform.translateX += imgX - newImgX;
                    transform.translateY += imgY - newImgY;
                }

                // 更新變換
                updateTransform();
            }, { passive: false });

            // 觸控捏合縮放
            let initialDistance = 0;
            let initialScale = 1;

            imageWrapper.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();

                    // 獲取兩個觸摸點
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];

                    // 計算初始距離
                    initialDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );

                    // 保存當前縮放
                    initialScale = transform.scale;

                    // 計算捏合中心點
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;

                    // 獲取中心點相對於圖片的位置
                    const rect = imageWrapper.getBoundingClientRect();
                    lastX = centerX;
                    lastY = centerY;
                }
            }, { passive: false });

            imageWrapper.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();

                    // 獲取兩個觸摸點
                    const touch1 = e.touches[0];
                    const touch2 = e.touches[1];

                    // 計算當前距離
                    const currentDistance = Math.hypot(
                        touch1.clientX - touch2.clientX,
                        touch1.clientY - touch2.clientY
                    );

                    // 計算縮放因子
                    const scaleFactor = currentDistance / initialDistance;
                    const oldScale = transform.scale;
                    transform.scale = Math.min(Math.max(initialScale * scaleFactor, 0.5), 3);

                    // 計算捏合中心點
                    const centerX = (touch1.clientX + touch2.clientX) / 2;
                    const centerY = (touch1.clientY + touch2.clientY) / 2;

                    // 更新拖動位置（同時進行縮放和拖動）
                    if (oldScale > 1 || transform.scale > 1) {
                        const deltaX = centerX - lastX;
                        const deltaY = centerY - lastY;

                        transform.translateX += deltaX;
                        transform.translateY += deltaY;

                        lastX = centerX;
                        lastY = centerY;
                    }

                    // 如果縮小到原始大小以下，重設位置
                    if (transform.scale <= 1) {
                        transform.translateX = 0;
                        transform.translateY = 0;
                    }

                    // 更新變換
                    updateTransform();
                }
            }, { passive: false });

            // 組裝控制按鈕
            zoomControls.appendChild(zoomInBtn);
            zoomControls.appendChild(zoomOutBtn);
            zoomControls.appendChild(resetBtn);

            // 組裝容器
            imageWrapper.appendChild(img);
            container.appendChild(imageWrapper);
            container.appendChild(zoomControls);

            return container;
        }

        // 操練模式 - 根據難度重新插入字卡
        function reinsertCardBasedOnDifficulty(currentIndex, interval) {
            if (interval <= 0 || cardsToReview.length <= 1) return currentIndex;

            // 取出當前卡片
            const currentCard = cardsToReview[currentIndex];

            // 計算重新插入的位置
            let insertPosition = currentIndex + interval;

            // 如果位置超出數組範圍，則循環回到合理範圍內
            if (insertPosition >= cardsToReview.length) {
                insertPosition = insertPosition % cardsToReview.length;
            }

            // 從數組中移除當前卡片
            cardsToReview.splice(currentIndex, 1);

            // 在新位置插入卡片
            cardsToReview.splice(insertPosition, 0, currentCard);

            // 返回調整後的當前索引（因為移除了當前卡片，索引需要調整）
            return currentIndex > 0 ? currentIndex - 1 : 0;
        }

        // Restart drill mode
        function restartDrill() {
            // Start a new cycle with reshuffled cards
            reviewCycleCount++;

            // Get all cards from the deck
            const deckCards = [];
            currentDeck.cardIds.forEach(cardId => {
                const card = cardsData.find(c => c.id === cardId);
                if (card) {
                    // Reset drill-specific properties
                    const cardCopy = {...card};
                    delete cardCopy.drillInterval;
                    delete cardCopy.removed;
                    deckCards.push(cardCopy);
                }
            });

            // Shuffle cards for the new cycle
            cardsToReview = shuffleArray(deckCards);

            // Start review
            currentCardIndex = 0;
            showCurrentCard();
        }

        // Clear all drill mode timers
        function clearAllDrillTimers() {
            drillTimers.forEach(timerId => clearTimeout(timerId));
            drillTimers = [];
        }

        // Flip card handler
        flipBtn.addEventListener('click', () => {
            cardFront.classList.toggle('hidden');
            cardBack.classList.toggle('hidden');

            // If showing the answer, display rating buttons
            if (!cardBack.classList.contains('hidden')) {
                ratingButtons.classList.remove('hidden');
            } else {
                ratingButtons.classList.add('hidden');
            }
        });

        // Handle rating buttons
        document.querySelectorAll('.rating-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const rating = parseInt(e.target.dataset.rating);
                processCardRating(rating);
            });
        });

        // Process card rating based on mode
        function processCardRating(rating) {
            const card = cardsToReview[currentCardIndex];

            if (currentMode === 'daily') {
                // Daily mode - update using SM-2 algorithm
                updateCardSchedule(card, rating);
                moveToNextCard();
            } else if (currentMode === 'drill') {
                // 操練模式 - 根據難度設置間隔
                scheduleDrillCard(card, rating);

                // 增加已檢閱計數
                drillReviewedCount++;

                // 如果評級不是"簡單"(4)，則根據設置的間隔重新插入卡片
                if (rating < 4) {
                    // 根據難度重新插入卡片
                    currentCardIndex = reinsertCardBasedOnDifficulty(currentCardIndex, card.drillInterval);
                } else {
                    // 如果是"簡單"，則直接從列表中移除
                    cardsToReview.splice(currentCardIndex, 1);

                    // 調整索引（如果剛才移除的是最後一張卡片）
                    if (currentCardIndex >= cardsToReview.length && cardsToReview.length > 0) {
                        currentCardIndex = 0; // 回到第一張卡片
                    }
                }

                // 檢查是否所有卡片都已被移除
                if (cardsToReview.length === 0) {
                    // 顯示新一輪開始的提示
                    showNotification('所有卡片都已複習完畢，開始新一輪操練！');

                    // 重新載入所有卡片開始新的循環
                    restartDrill();
                } else {
                    // 顯示下一張卡片
                    currentCardIndex++;
                    if (currentCardIndex >= cardsToReview.length) {
                        currentCardIndex = 0;
                    }
                    showCurrentCard();
                }
            }
        }

        // Schedule card in drill mode
        function scheduleDrillCard(card, rating) {
            // Set interval based on difficulty rating
            switch(rating) {
                case 1: // Very difficult
                    card.drillInterval = 5; // Review after 5 cards
                    break;
                case 2: // Difficult
                    card.drillInterval = 10; // Review after 10 cards
                    break;
                case 3: // Good
                    card.drillInterval = 20; // Review after 20 cards
                    break;
                case 4: // Easy - remove card from drill session
                    card.removed = true;
                    break;
            }

            // Update card difficulty for future reference
            if (rating === 4) {
                card.difficulty = "easy";
            } else if (rating === 3) {
                card.difficulty = "medium";
            } else {
                card.difficulty = "hard";
            }

            // Update original card in cardsData with new difficulty
            const originalCard = cardsData.find(c => c.id === card.id);
            if (originalCard) {
                originalCard.difficulty = card.difficulty;
            }
        }

        // Update card schedule using SM-2 algorithm
        function updateCardSchedule(card, rating) {
            // Update card difficulty based on rating
            if (rating === 4) {
                card.difficulty = "easy";
            } else if (rating === 3) {
                card.difficulty = "medium";
            } else {
                card.difficulty = "hard";
            }

            // Update card using modified SM-2 algorithm
            if (rating < 3) {
                // If rating is 1 or 2 (difficult), reset repetitions
                card.repetitions = 0;
                card.interval = rating === 1 ? 0.25 : 0.5; // Very difficult: 0.25, Difficult: 0.5
            } else {
                // If rating is 3 or 4 (good/easy)
                card.repetitions = card.repetitions || 0;
                card.repetitions++;

                // Calculate new interval
                if (card.repetitions === 1) {
                    card.interval = 1; // 1 day
                } else if (card.repetitions === 2) {
                    card.interval = 3; // 3 days
                } else {
                    // Adjust interval based on ease factor
                    card.interval = card.interval || 1;
                    card.easeFactor = card.easeFactor || 2.0;
                    card.interval = Math.round(card.interval * card.easeFactor);
                }

                // Adjust ease factor based on performance
                if (rating === 4) { // Easy
                    card.easeFactor = (card.easeFactor || 2.0) + 0.15;
                } else if (rating === 3) { // Good
                    card.easeFactor = (card.easeFactor || 2.0) - 0.05;
                }

                // Ensure ease factor stays within reasonable bounds
                if (card.easeFactor < 1.3) card.easeFactor = 1.3;
            }

            // Calculate next review date (convert interval from days to milliseconds)
            card.nextReview = Date.now() + (card.interval * 24 * 60 * 60 * 1000);

            // Update original card in cardsData
            const cardIndex = cardsData.findIndex(c => c.id === card.id);
            if (cardIndex !== -1) {
                cardsData[cardIndex] = {...card};
            }
            saveDataToLocalStorage();
        }

        // Show current card to review
        function showCurrentCard() {
            // 重置卡片狀態
            cardFront.classList.remove('hidden');
            cardBack.classList.add('hidden');
            ratingButtons.classList.add('hidden');

            // 设置卡片布局样式
            cardFront.className = "flex flex-col w-full h-full justify-between"; // 使用justify-between分配空间
            cardBack.className = "flex flex-col w-full h-full justify-between hidden";

            // 确保文字区域有最小高度
            frontText.style.minHeight = "80px";
            backText.style.minHeight = "80px";

            // 增加文字区域的边距
            frontText.className = "mb-6 px-2";
            backText.className = "mb-6 px-2";

            // 獲取當前卡片
            const card = cardsToReview[currentCardIndex];
            if (!card) return;

            // 根據sidesFlipped決定顯示方式
            if (sidesFlipped) {
                // 正反面互換
                frontText.innerHTML = card.backText || '';
                backText.innerHTML = card.frontText || '';

                // 處理圖片顯示
                frontImage.innerHTML = '';
                backImage.innerHTML = '';

                if (card.backImage) {
                    const imgContainer = createZoomableImage(card.backImage);
                    frontImage.appendChild(imgContainer);
                }

                if (card.frontImage) {
                    const imgContainer = createZoomableImage(card.frontImage);
                    backImage.appendChild(imgContainer);
                }
            } else {
                // 正常顯示
                frontText.innerHTML = card.frontText || '';
                backText.innerHTML = card.backText || '';

                // 增加間距類
                frontText.className = "mb-6 px-2"; // 增加底部間距和左右內邊距
                backText.className = "mb-6 px-2";  // 增加底部間距和左右內邊距

                // 處理圖片顯示
                frontImage.innerHTML = '';
                backImage.innerHTML = '';

                if (card.frontImage) {
                    const imgContainer = createZoomableImage(card.frontImage);
                    frontImage.appendChild(imgContainer);
                }

                if (card.backImage) {
                    const imgContainer = createZoomableImage(card.backImage);
                    backImage.appendChild(imgContainer);
                }
            }
        }

        // Move to next card or finish review
        function moveToNextCard() {
            currentCardIndex++;

            if (currentCardIndex < cardsToReview.length) {
                showCurrentCard();
            } else {
                // 日常模式下顯示恭喜提示並自動轉跳
                if (currentMode === 'daily') {
                    // 顯示恭喜提示
                    showNotification('恭喜你！你已經複習完這個卡組的所有內容了！', 3000);

                    // 延遲一些時間後轉跳到選擇卡組頁面
                    setTimeout(() => {
                        showReviewStage('deckSelection');
                    }, 2000);
                } else {
                    // 其他模式仍然顯示完成界面
                    showReviewStage('reviewComplete');
                }
            }
        }

        // 儲存編輯器格式設定的變數
        let savedFrontFormats = {};
        let savedBackFormats = {};

        // 修改卡片建立處理函數，保存字體大小設定
        cardForm.addEventListener('submit', function(e) {
            e.preventDefault();

            const frontContent = frontQuill.root.innerHTML.trim();
            const backContent = backQuill.root.innerHTML.trim();

            if (selectedDeckIds.length === 0) {
                showNotification('請選擇至少一個卡組');
                return;
            }

            // 保存當前的格式設定（包括字體大小）
            // 為前面編輯器保存格式
            if (!frontQuill.getSelection()) {
                frontQuill.setSelection(0, 0);
            }
            savedFrontFormats = frontQuill.getFormat();

            // 為背面編輯器保存格式
            if (!backQuill.getSelection()) {
                backQuill.setSelection(0, 0);
            }
            savedBackFormats = backQuill.getFormat();

            if (frontContent !== '<p><br></p>' || frontImageData || backContent !== '<p><br></p>' || backImageData) {
                const newCardId = addNewCard(
                    frontContent !== '<p><br></p>' ? frontContent : '',
                    frontImageData,
                    backContent !== '<p><br></p>' ? backContent : '',
                    backImageData
                );

                // 添加卡片到選定的卡組
                selectedDeckIds.forEach(deckId => {
                    const deckIndex = decksData.findIndex(deck => deck.id === deckId);
                    if (deckIndex !== -1) {
                        decksData[deckIndex].cardIds.push(newCardId);
                    }
                });

                // 清空內容但保留格式設定（包括字體大小）
                clearEditorContentButKeepFormat(frontQuill, savedFrontFormats);
                clearEditorContentButKeepFormat(backQuill, savedBackFormats);

                // 重置圖片相關內容
                frontImageData = null;
                backImageData = null;
                frontImageName.textContent = '';
                backImageName.textContent = '';
                frontImagePreview.classList.add('hidden');
                backImagePreview.classList.add('hidden');

                // 聚焦到前面的編輯器以便繼續添加字卡
                setTimeout(() => {
                    frontQuill.focus();
                }, 0);

                showNotification('字卡建立成功');
                showStorageReminder();
            } else {
                showNotification('請至少添加一些內容到字卡');
            }
        });

        // 清空編輯器內容但保留格式的函數，包括字體大小
        function clearEditorContentButKeepFormat(quill, formats) {
            // 清空內容
            quill.setText('');

            // 恢復之前保存的格式
            if (formats) {
                // 選中新創建的空行
                quill.setSelection(0, 1);

                // 應用所有保存的格式
                Object.keys(formats).forEach(format => {
                    // 應用格式，包括對齊和字體大小
                    if (format === 'align' || format === 'size') {
                        quill.format(format, formats[format]);
                    }
                });

                // 清除選擇
                quill.setSelection(null);
            }
        }

        // 在切換頁面時重置所有格式
        function resetEditorFormats() {
            savedFrontFormats = {};
            savedBackFormats = {};

            if (frontQuill) {
                try {
                    // 檢查編輯器是否準備好且有內容
                    if (frontQuill.getLength() > 0) {
                        frontQuill.setSelection(0, frontQuill.getLength());
                        frontQuill.format('align', false);
                        frontQuill.format('size', false);
                        frontQuill.setSelection(null);
                    }
                } catch (e) {
                    console.log("重置前面編輯器格式失敗:", e);
                }
            }

            if (backQuill) {
                try {
                    if (backQuill.getLength() > 0) {
                        backQuill.setSelection(0, backQuill.getLength());
                        backQuill.format('align', false);
                        backQuill.format('size', false);
                        backQuill.setSelection(null);
                    }
                } catch (e) {
                    console.log("重置背面編輯器格式失敗:", e);
                }
            }
        }

        // 創建一個包裝函數，而不是直接覆蓋原始函數
        function showSectionWithReset(section) {
            // 在切換頁面前重置格式
            resetEditorFormats();

            // 調用原始函數
            showSection(section);
        }

        // 為每個按鈕設置專用的事件處理函數
        function setupNavigationButtons() {
            // 清除現有的事件綁定（如果有）
            reviewBtn.removeEventListener('click', reviewBtnHandler);
            createCardBtn.removeEventListener('click', createCardBtnHandler);
            manageCardBtn.removeEventListener('click', manageCardBtnHandler);
            manageDeckBtn.removeEventListener('click', manageDeckBtnHandler);

            // 重新添加事件監聽器
            reviewBtn.addEventListener('click', reviewBtnHandler);
            createCardBtn.addEventListener('click', createCardBtnHandler);
            manageCardBtn.addEventListener('click', manageCardBtnHandler);
            manageDeckBtn.addEventListener('click', manageDeckBtnHandler);
        }

        // 定義每個按鈕的處理函數
        function reviewBtnHandler() {
            resetEditorFormats();
            showSection('review');
        }

        function createCardBtnHandler() {
            resetEditorFormats();
            showSection('createCard');
        }

        function manageCardBtnHandler() {
            resetEditorFormats();
            showSection('manageCard');
        }

        function manageDeckBtnHandler() {
            resetEditorFormats();
            showSection('manageDeck');
        }

        // 確保字體大小在字卡顯示時正確呈現
        function fixFontSizeDisplay() {
          // 1. 首先確保CSS選擇器正確匹配字卡顯示區域
          const styleElement = document.createElement('style');
          styleElement.textContent = `
            /* 編輯器字體大小設定 */
            .ql-size-small, p.ql-size-small, .ql-size-small p {
              font-size: 0.75em !important;
            }

            .ql-size-large, p.ql-size-large, .ql-size-large p {
              font-size: 1.5em !important;
            }

            .ql-size-huge, p.ql-size-huge, .ql-size-huge p {
              font-size: 2em !important;
            }

            /* 確保字卡顯示區域的字體大小設定 */
            #cardFront .ql-size-small,
            #cardBack .ql-size-small,
            #frontText .ql-size-small,
            #backText .ql-size-small,
            #cardFront p.ql-size-small,
            #cardBack p.ql-size-small,
            #frontText p.ql-size-small,
            #backText p.ql-size-small {
              font-size: 0.75em !important;
            }

            #cardFront .ql-size-large,
            #cardBack .ql-size-large,
            #frontText .ql-size-large,
            #backText .ql-size-large,
            #cardFront p.ql-size-large,
            #cardBack p.ql-size-large,
            #frontText p.ql-size-large,
            #backText p.ql-size-large {
              font-size: 1.5em !important;
            }

            #cardFront .ql-size-huge,
            #cardBack .ql-size-huge,
            #frontText .ql-size-huge,
            #backText .ql-size-huge,
            #cardFront p.ql-size-huge,
            #cardBack p.ql-size-huge,
            #frontText p.ql-size-huge,
            #backText p.ql-size-huge {
              font-size: 2em !important;
            }
          `;
          document.head.appendChild(styleElement);

          // 2. 修改顯示卡片內容的函數，確保字體大小類被保留
          const originalShowCurrentCard = window.showCurrentCard;
          window.showCurrentCard = function() {
            originalShowCurrentCard.apply(this, arguments);

            // 確保字體大小類被正確應用
            const card = cardsToReview[currentCardIndex];
            if (!card) return;

            // 處理前面內容
            if (card.frontText) {
              // 檢查我們是否顯示前面還是背面
              const targetElement = sidesFlipped ? backText : frontText;
              fixFontSizeInHTML(targetElement);
            }

            // 處理背面內容
            if (card.backText) {
              // 檢查我們是否顯示前面還是背面
              const targetElement = sidesFlipped ? frontText : backText;
              fixFontSizeInHTML(targetElement);
            }
          };

          // 3. 添加函數來確保字體大小類被正確處理
          function fixFontSizeInHTML(element) {
            if (!element) return;

            // 尋找所有帶有字體大小類的元素
            const sizeElements = element.querySelectorAll('[class*="ql-size-"]');

            // 確保這些元素的字體大小被正確應用
            sizeElements.forEach(el => {
              // 確保字體大小類被設置為!important
              const computedStyle = window.getComputedStyle(el);
              const currentSize = computedStyle.fontSize;

              if (el.classList.contains('ql-size-small')) {
                el.style.setProperty('font-size', '0.75em', 'important');
              } else if (el.classList.contains('ql-size-large')) {
                el.style.setProperty('font-size', '1.5em', 'important');
              } else if (el.classList.contains('ql-size-huge')) {
                el.style.setProperty('font-size', '2em', 'important');
              }
            });

            // 修復特殊情況：如果字體大小類被應用到<p>標籤，而內容在其中
            const paragraphs = element.querySelectorAll('p[class*="ql-size-"]');
            paragraphs.forEach(p => {
              const sizeClass = Array.from(p.classList).find(cls => cls.startsWith('ql-size-'));
              if (sizeClass) {
                // 確保段落內的所有文本和元素都繼承字體大小
                p.style.setProperty('font-size', sizeClass === 'ql-size-small' ? '0.75em' :
                                   sizeClass === 'ql-size-large' ? '1.5em' :
                                   sizeClass === 'ql-size-huge' ? '2em' : 'inherit', 'important');
              }
            });
          }

          // 4. 修改卡片保存函數，確保字體大小設定被保存
          const originalAddNewCard = window.addNewCard;
          window.addNewCard = function(frontText, frontImage, backText, backImage) {
            // 確保HTML中的字體大小類被保存
            if (frontText) {
              frontText = ensureFontSizePresereved(frontText);
            }

            if (backText) {
              backText = ensureFontSizePresereved(backText);
            }

            return originalAddNewCard(frontText, frontImage, backText, backImage);
          };

          function ensureFontSizePresereved(html) {
            // 創建臨時元素來處理HTML
            const temp = document.createElement('div');
            temp.innerHTML = html;

            // 確保所有字體大小類都被正確設置
            const sizeElements = temp.querySelectorAll('[class*="ql-size-"]');
            sizeElements.forEach(el => {
              // 添加內聯樣式以確保字體大小被保留
              if (el.classList.contains('ql-size-small')) {
                el.style.fontSize = '0.75em';
              } else if (el.classList.contains('ql-size-large')) {
                el.style.fontSize = '1.5em';
              } else if (el.classList.contains('ql-size-huge')) {
                el.style.fontSize = '2em';
              }
            });

            return temp.innerHTML;
          }
        }

        // 在頁面加載完成後執行此函數
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', fixFontSizeDisplay);
        } else {
          fixFontSizeDisplay();
        }

        // Add new card
        function addNewCard(frontText, frontImage, backText, backImage) {
          // 創建新字卡 - 使用安全的唯一ID生成方式
          const newCardId = Date.now() + Math.floor(Math.random() * 10000);
          const newCard = {
              id: newCardId,
              frontText: frontText,
              frontImage: frontImage,
              backText: backText,
              backImage: backImage,
              nextReview: Date.now(),
              repetitions: 0,
              easeFactor: 2.0,
              interval: 1.0
          };

          cardsData.push(newCard);
          return newCardId;

          saveDataToLocalStorage();
        }

        // Load all cards for management (Excel-like table)
                function loadAllCards() {
                    const tableContainer = document.getElementById('allCardsContainer');
                    const tableBody = tableContainer.querySelector('tbody');
                    if (!tableBody) {
                        console.error("Table body not found in allCardsContainer");
                        return;
                    }
                    tableBody.innerHTML = ''; // Clear existing rows

                    // Get search and filter values
                    const searchText = cardSearchInput.value.toLowerCase();
                    const selectedDeckId = deckFilterSelect.value;

                    // Filter cards
                    let filteredCards = [...cardsData]; // Create a copy for sorting

                    // Apply search filter
                    if (searchText) {
                        filteredCards = filteredCards.filter(card =>
                            (card.frontText && stripHtml(card.frontText).toLowerCase().includes(searchText)) ||
                            (card.backText && stripHtml(card.backText).toLowerCase().includes(searchText))
                        );
                    }

                    // Apply deck filter
                    if (selectedDeckId !== 'all') {
                        const deckId = parseInt(selectedDeckId);
                        const deck = decksData.find(d => d.id === deckId);
                        if (deck) {
                            filteredCards = filteredCards.filter(card => deck.cardIds.includes(card.id));
                        }
                    }

                    // Apply sorting
                    filteredCards.sort((a, b) => {
                        let valA, valB;

                        function getSortableText(htmlContent) {
                            return stripHtml(htmlContent || '').toLowerCase(); // 轉換為小寫進行不區分大小寫的排序
                        }

                        switch (cardSortKey) {
                            case 'frontText':
                                valA = getSortableText(a.frontText);
                                valB = getSortableText(b.frontText);
                                break;
                            case 'backText':
                                valA = getSortableText(a.backText);
                                valB = getSortableText(b.backText);
                                break;
                            case 'decks':
                                // 對於多個卡組的情況，先獲取卡組名稱列表，排序後再組合成字串進行比較
                                const decksA = decksData.filter(d => d.cardIds.includes(a.id)).map(d => d.name).sort().join(', ');
                                const decksB = decksData.filter(d => d.cardIds.includes(b.id)).map(d => d.name).sort().join(', ');
                                valA = decksA.toLowerCase();
                                valB = decksB.toLowerCase();
                                break;
                            case 'difficulty':
                                // 為難度定義一個排序順序，方便比較
                                const difficultyOrder = { 'unknown': 0, 'easy': 1, 'medium': 2, 'hard': 3 }; // 'unknown' 或未評分的排最前面
                                valA = difficultyOrder[a.difficulty || 'unknown'] || 0;
                                valB = difficultyOrder[b.difficulty || 'unknown'] || 0;
                                break;
                            default:
                                valA = getSortableText(a.frontText); // 預設按正面內容排序
                                valB = getSortableText(b.frontText);
                        }

                        // 比較並返回排序結果
                        if (valA < valB) {
                            return cardSortOrder === 'asc' ? -1 : 1;
                        }
                        if (valA > valB) {
                            return cardSortOrder === 'asc' ? 1 : -1;
                        }
                        return 0; // 相等則不改變順序
                    });


                    if (filteredCards.length === 0) {
                        const tr = tableBody.insertRow();
                        const td = tr.insertCell();
                        td.colSpan = 6; // Number of columns in your table (Checkbox, Front, Back, Decks, Difficulty, Actions)
                        td.className = 'text-center py-8 text-gray-500 dark:text-gray-400';
                        td.textContent = '沒有符合條件的字卡。';
                        return;
                    }

                    selectAllCards.checked = false; // Reset global select all checkbox

                    filteredCards.forEach(card => {
                        const tr = tableBody.insertRow();
                        tr.className = 'hover:bg-gray-50 dark:hover:bg-gray-800/50 transition-colors';

                        // 1. Checkbox cell
                        const tdCheckbox = tr.insertCell();
                        tdCheckbox.className = 'py-3 px-4'; // Tailwind classes
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'card-checkbox h-4 w-4 rounded border-gray-300 dark:border-gray-600 text-primary focus:ring-primary dark:bg-gray-700 dark:focus:ring-offset-gray-800';
                        checkbox.value = card.id;
                        checkbox.checked = selectedCardIds.has(card.id);
                        checkbox.addEventListener('change', function() {
                            const cardId = parseInt(this.value);
                            if (this.checked) {
                                selectedCardIds.add(cardId);
                            } else {
                                selectedCardIds.delete(cardId);
                            }
                            updateBatchDeleteButton();
                        });
                        tdCheckbox.appendChild(checkbox);

                        // 2. Front content cell
                        const tdFront = tr.insertCell();
                        tdFront.className = 'py-3 px-4';
                        const frontPreviewDiv = document.createElement('div');
                        frontPreviewDiv.className = 'quill-content-preview-table';
                        let frontHTML = card.frontText || '<span class="text-gray-400 italic">無內容</span>';
                        if (card.frontImage) {
                            frontHTML = `<img src="${card.frontImage}" alt="正面圖片">` + frontHTML;
                        }
                        frontPreviewDiv.innerHTML = frontHTML;
                        tdFront.appendChild(frontPreviewDiv);

                        // 3. Back content cell
                        const tdBack = tr.insertCell();
                        tdBack.className = 'py-3 px-4';
                        const backPreviewDiv = document.createElement('div');
                        backPreviewDiv.className = 'quill-content-preview-table';
                        let backHTML = card.backText || '<span class="text-gray-400 italic">無內容</span>';
                        if (card.backImage) {
                            backHTML = `<img src="${card.backImage}" alt="背面圖片">` + backHTML;
                        }
                        backPreviewDiv.innerHTML = backHTML;
                        tdBack.appendChild(backPreviewDiv);

                        // 4. Decks cell
                        const tdDecks = tr.insertCell();
                        tdDecks.className = 'py-3 px-4';
                        const containingDecks = decksData.filter(deck => deck.cardIds.includes(card.id));
                        if (containingDecks.length > 0) {
                            const deckListContainer = document.createElement('div');
                            deckListContainer.className = 'flex flex-wrap gap-1';
                            containingDecks.forEach(deck => {
                                const deckBadge = document.createElement('span');
                                deckBadge.className = 'deck-badge-table bg-primary bg-opacity-10 text-primary dark:bg-primary/30 dark:text-primary-light';
                                deckBadge.textContent = deck.name;
                                deckListContainer.appendChild(deckBadge);
                            });
                            tdDecks.appendChild(deckListContainer);
                        } else {
                            tdDecks.innerHTML = '<span class="text-gray-400 italic">未分配</span>';
                        }

                        // 5. Difficulty cell
                        const tdDifficulty = tr.insertCell();
                        tdDifficulty.className = 'py-3 px-4';
                        if (card.difficulty) {
                            let difficultyLabel, difficultyClass;
                            switch (card.difficulty) {
                                case 'easy':
                                    difficultyLabel = '簡單';
                                    difficultyClass = 'bg-green-100 dark:bg-green-700 text-green-800 dark:text-green-100';
                                    break;
                                case 'medium':
                                    difficultyLabel = '中等';
                                    difficultyClass = 'bg-yellow-100 dark:bg-yellow-700 text-yellow-800 dark:text-yellow-100';
                                    break;
                                case 'hard':
                                    difficultyLabel = '困難';
                                    difficultyClass = 'bg-red-100 dark:bg-red-700 text-red-800 dark:text-red-100';
                                    break;
                                default:
                                    difficultyLabel = card.difficulty; // Should not happen with current values
                                    difficultyClass = 'bg-gray-100 dark:bg-gray-600 text-gray-800 dark:text-gray-100';
                            }
                            tdDifficulty.innerHTML = `<span class="difficulty-badge-table ${difficultyClass}">${difficultyLabel}</span>`;
                        } else {
                            tdDifficulty.innerHTML = '<span class="text-gray-400 italic">未評分</span>';
                        }

                        // 6. Actions cell
                        const tdActions = tr.insertCell();
                        tdActions.className = 'py-3 px-4';
                        const actionContainer = document.createElement('div');
                        actionContainer.className = 'flex space-x-3 items-center'; // Increased space

                        const editBtn = document.createElement('button');
                        editBtn.className = 'text-blue-500 hover:text-blue-700 dark:text-blue-400 dark:hover:text-blue-300';
                        editBtn.title = "編輯字卡";
                        editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" /></svg>`;
                        editBtn.addEventListener('click', () => openCardEditModal(card.id));

                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300';
                        deleteBtn.title = "刪除字卡";
                        deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>`;
                        deleteBtn.addEventListener('click', () => deleteCard(card.id));

                        actionContainer.appendChild(editBtn);
                        actionContainer.appendChild(deleteBtn);
                        tdActions.appendChild(actionContainer);
                    });

                    setupSortableTableHeaders(); // Call this after populating the table
                }

                // Helper function to setup sortable headers for the card table
                        function setupSortableTableHeaders() {
                            const headers = document.querySelectorAll('#manageCardSection .sortable-header');
                            headers.forEach(header => {
                                // Clone and replace to remove old listeners if any
                                const newHeader = header.cloneNode(true);
                                if (header.parentNode) { // Check if parentNode exists
                                    header.parentNode.replaceChild(newHeader, header);
                                } else {
                                    // Fallback or error handling if parentNode is null
                                    console.warn("Parent node for header not found, cannot replace:", header);
                                    // Potentially re-attach to a default parent or skip if critical
                                }


                                newHeader.addEventListener('click', () => {
                                    const sortKey = newHeader.dataset.sortKey;
                                    if (cardSortKey === sortKey) {
                                        cardSortOrder = cardSortOrder === 'asc' ? 'desc' : 'asc';
                                    } else {
                                        cardSortKey = sortKey;
                                        cardSortOrder = 'asc';
                                    }
                                    // Update header classes for visual indicator
                                    document.querySelectorAll('#manageCardSection .sortable-header').forEach(h => { // Query again for potentially replaced headers
                                        h.classList.remove('sort-asc', 'sort-desc');
                                        if (h.dataset.sortKey === cardSortKey) {
                                            h.classList.add(cardSortOrder === 'asc' ? 'sort-asc' : 'sort-desc');
                                        }
                                    });
                                    loadAllCards(); // Reload and re-render the table
                                });

                                // Set initial sort indicator if this header is the current sort key
                                if (newHeader.dataset.sortKey === cardSortKey) {
                                    newHeader.classList.add(cardSortOrder === 'asc' ? 'sort-asc' : 'sort-desc');
                                }
                            });
                        }

        // 移除HTML標籤，用於搜索
        function stripHtml(html) {
            const temporalDiv = document.createElement("div");
            temporalDiv.innerHTML = html;
            return temporalDiv.textContent || temporalDiv.innerText || "";
        }

        // Open card edit modal
        function openCardEditModal(cardId) {
            const card = cardsData.find(c => c.id === cardId);
            if (!card) return;

            editingCardId = cardId;

            // 設置Quill編輯器內容
            editFrontQuill.root.innerHTML = card.frontText || '';
            editBackQuill.root.innerHTML = card.backText || '';

            // 編輯器初始化前清理可能的重複工具列
            const editBackEditorElement = document.getElementById('editBackEditor');
            if (editBackEditorElement) {
              // 移除所有可能存在的重複工具列
              const toolbars = editBackEditorElement.parentElement.querySelectorAll('.ql-toolbar');
              if (toolbars.length > 1) {
                for (let i = 1; i < toolbars.length; i++) {
                  toolbars[i].remove();
                }
              }
            }

            // Reset image data
            editFrontImageData = card.frontImage;
            editBackImageData = card.backImage;

            // Set image previews
            if (card.frontImage) {
                editFrontPreviewImg.src = card.frontImage;
                editFrontImagePreview.classList.remove('hidden');
            } else {
                editFrontImagePreview.classList.add('hidden');
            }

            if (card.backImage) {
                editBackPreviewImg.src = card.backImage;
                editBackImagePreview.classList.remove('hidden');
            } else {
                editBackImagePreview.classList.add('hidden');
            }

            // Load deck options
            loadCardEditDeckOptions(cardId);

            // Show modal
            cardEditModal.classList.remove('hidden');

            // Setup event listeners
            closeCardEditBtn.addEventListener('click', closeCardEditModal);
            saveCardEditBtn.addEventListener('click', saveCardEdit);

            // Add click outside to close functionality
            document.addEventListener('click', handleCardEditOutsideClick);
        }

        // Load deck options for card editing
        function loadCardEditDeckOptions(cardId) {
            editCardDecksList.innerHTML = '';

            if (decksData.length === 0) {
                editCardDecksList.innerHTML = '<p class="text-gray-500 text-sm py-2">尚未建立任何卡組</p>';
                return;
            }

            decksData.forEach(deck => {
                const isInDeck = deck.cardIds.includes(cardId);

                const deckOption = document.createElement('div');
                deckOption.className = 'flex items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';
                deckOption.innerHTML = `
                    <input type="checkbox" id="deck-${deck.id}" data-deck-id="${deck.id}" class="mr-2" ${isInDeck ? 'checked' : ''}>
                    <label for="deck-${deck.id}" class="flex-1 cursor-pointer">${deck.name}</label>
                `;

                editCardDecksList.appendChild(deckOption);
            });
        }

        // Close card edit modal
        function closeCardEditModal() {
            cardEditModal.classList.add('hidden');
            document.removeEventListener('click', handleCardEditOutsideClick);
            editingCardId = null;
        }

        // Handle click outside the card edit modal to close it
        function handleCardEditOutsideClick(event) {
            const modalContent = cardEditModal.querySelector('div');
            if (cardEditModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeCardEditModal();
            }
        }

        // Save card edit
        function saveCardEdit() {
            const cardIndex = cardsData.findIndex(c => c.id === editingCardId);
            if (cardIndex === -1) return;

            const frontContent = editFrontQuill.root.innerHTML.trim();
            const backContent = editBackQuill.root.innerHTML.trim();

            if (frontContent === '<p><br></p>' && backContent === '<p><br></p>' && !editFrontImageData && !editBackImageData) {
                showNotification('字卡必須至少包含一些內容');
                return;
            }

            // Update card data
            cardsData[cardIndex].frontText = frontContent !== '<p><br></p>' ? frontContent : '';
            cardsData[cardIndex].backText = backContent !== '<p><br></p>' ? backContent : '';
            cardsData[cardIndex].frontImage = editFrontImageData;
            cardsData[cardIndex].backImage = editBackImageData;

            // Update card's deck membership
            const selectedDeckIds = Array.from(editCardDecksList.querySelectorAll('input[type="checkbox"]:checked'))
                .map(checkbox => parseInt(checkbox.getAttribute('data-deck-id')));

            // Remove card from all decks
            decksData.forEach(deck => {
                deck.cardIds = deck.cardIds.filter(id => id !== editingCardId);
            });

            // Add card to selected decks
            selectedDeckIds.forEach(deckId => {
                const deckIndex = decksData.findIndex(deck => deck.id === deckId);
                if (deckIndex !== -1) {
                    decksData[deckIndex].cardIds.push(editingCardId);
                }
            });

            closeCardEditModal();
            loadAllCards();
            showNotification('字卡已更新');

            // Show storage reminder as data has changed
            showStorageReminder();
            saveDataToLocalStorage();
        }

        // Delete a card
        function deleteCard(cardId) {
            // Remove card from cardsData
            cardsData = cardsData.filter(card => card.id !== cardId);

            // Remove card from all decks
            decksData.forEach(deck => {
                deck.cardIds = deck.cardIds.filter(id => id !== cardId);
            });

            // Remove from selection if it was selected
            selectedCardIds.delete(cardId);
            updateBatchDeleteButton();

            loadAllCards();
            showNotification('字卡已刪除');

            // Show storage reminder as data has changed
            showStorageReminder();
            saveDataToLocalStorage();
        }

        // Load all decks for management
        function loadAllDecks() {
            allDecksContainer.innerHTML = '';

            if (decksData.length === 0) {
                allDecksContainer.innerHTML = `
                    <div class="text-center py-8 text-gray-500 dark:text-gray-400">
                        沒有可用的卡組。請先建立卡組。
                    </div>
                `;
                return;
            }

            // Apply search filter
            const searchText = manageDeckSearchInput.value.trim();
            let filteredDecks = filterDecksBySearch(decksData, searchText);

            // Apply sorting
            const sortedDecks = sortDecks(filteredDecks, manageDeckSortPreference);

            if (sortedDecks.length === 0) {
                allDecksContainer.innerHTML = '<div class="text-center py-8 text-gray-500 dark:text-gray-400">沒有符合搜尋條件的卡組</div>';
                return;
            }

            // Reset select all checkbox
            selectAllDecks.checked = false;

            sortedDecks.forEach(deck => {
                const deckElement = document.createElement('div');
                deckElement.className = 'bg-white dark:bg-gray-800 p-4 rounded-lg shadow border border-gray-300 dark:border-gray-700';

                const cardCount = deck.cardIds.length;
                const createdDate = formatDate(deck.createdAt || Date.now());
                const isSelected = selectedDeckIds2.has(deck.id);

                deckElement.innerHTML = `
                    <div class="flex items-start">
                        <input type="checkbox" class="deck-checkbox mt-1 mr-3" value="${deck.id}" ${isSelected ? 'checked' : ''}>
                        <div class="flex flex-1 justify-between items-start">
                            <div class="flex-1 pr-4">
                                <h3 class="font-medium text-lg mb-1">${deck.name}</h3>
                                <p class="text-gray-600 dark:text-gray-400 text-sm mb-2">${deck.description || '無描述'}</p>
                                <div class="text-xs text-gray-500 dark:text-gray-500 flex flex-wrap gap-2">
                                    <span>包含 ${cardCount} 張字卡</span>
                                    <span>建立於: ${createdDate}</span>
                                </div>
                            </div>
                            <div class="flex space-x-2">
                                <button class="export-deck-btn text-green-500 hover:text-green-700" data-id="${deck.id}" title="匯出卡組">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                    </svg>
                                </button>
                                <button class="edit-deck-btn text-blue-500 hover:text-blue-700" data-id="${deck.id}" title="編輯卡組">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path d="M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z" />
                                    </svg>
                                </button>
                                <button class="delete-deck-btn text-red-500 hover:text-red-700" data-id="${deck.id}" title="刪除卡組">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                allDecksContainer.appendChild(deckElement);
            });

            // Add deck checkbox event listeners
            document.querySelectorAll('.deck-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    const deckId = parseInt(this.value);
                    if (this.checked) {
                        selectedDeckIds2.add(deckId);
                    } else {
                        selectedDeckIds2.delete(deckId);
                    }
                    updateBatchDeleteDecksButton();
                });
            });

            // Add export deck event listeners
            document.querySelectorAll('.export-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const deckId = parseInt(e.currentTarget.dataset.id);
                    exportSingleDeck(deckId);
                });
            });

            // Add edit deck event listeners
            document.querySelectorAll('.edit-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const deckId = parseInt(e.currentTarget.dataset.id);
                    openDeckEditModal(deckId);
                });
            });

            // Add delete deck event listeners
            document.querySelectorAll('.delete-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const deckId = parseInt(e.currentTarget.dataset.id);
                    deleteDeck(deckId);
                });
            });
        }

        // Export a single deck
        function exportSingleDeck(deckId) {
            const deck = decksData.find(deck => deck.id === deckId);
            if (!deck) {
                showNotification('找不到指定的卡組');
                return;
            }

            // Get all cards from this deck
            const deckCards = cardsData.filter(card => deck.cardIds.includes(card.id));

            const exportData = {
                version: "1.1",
                type: "single_deck",
                exportDate: new Date().toISOString(),
                decksData: [deck],
                cardsData: deckCards
            };

            // Generate filename
            const safeFileName = deck.name.replace(/[^\w\s]/gi, '_');
            const dateStr = new Date().toISOString().split('T')[0].replace(/-/g, '');
            const filename = `${safeFileName}_${dateStr}.json`;

            // Convert to JSON
            const jsonStr = JSON.stringify(exportData, null, 2);

            // Create and trigger download
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();

            // Cleanup
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);

            showNotification(`成功匯出卡組：${deck.name}`);
        }

        // Open deck edit modal
        // 修改打開卡組編輯對話框的函數
        function openDeckEditModal(deckId) {
            const deck = decksData.find(d => d.id === deckId);
            if (!deck) return;

            editingDeckId = deckId;
            editDeckNameInput.value = deck.name;
            editDeckDescriptionInput.value = deck.description || '';

            // 載入卡片
            loadDeckCards(deck, '');
            loadAvailableCards(deck, '');

            // 獲取搜尋框元素
            const searchDeckCardsInput = document.getElementById('searchDeckCards');
            const searchAvailableCardsInput = document.getElementById('searchAvailableCards');

            // 重置搜尋框
            if (searchDeckCardsInput) searchDeckCardsInput.value = '';
            if (searchAvailableCardsInput) searchAvailableCardsInput.value = '';

            // 添加搜尋事件監聽器
            if (searchDeckCardsInput) {
                searchDeckCardsInput.addEventListener('input', function() {
                    loadDeckCards(deck, this.value.trim());
                });
            }

            if (searchAvailableCardsInput) {
                searchAvailableCardsInput.addEventListener('input', function() {
                    loadAvailableCards(deck, this.value.trim());
                });
            }

            // 顯示對話框
            deckEditModal.classList.remove('hidden');

            // 設置事件監聽器
            closeDeckEditBtn.addEventListener('click', closeDeckEditModal);
            saveDeckEditBtn.addEventListener('click', saveDeckEdit);

            // 添加點擊外部關閉功能
            document.addEventListener('click', handleDeckEditOutsideClick);
        }

        // 修改卡組編輯對話框的大小和布局
        function adjustDeckEditModalHeight() {
            const deckEditModal = document.getElementById('deckEditModal');
            if (!deckEditModal) return;

            const modalContent = deckEditModal.querySelector('.bg-white.dark\\:bg-gray-800');
            if (!modalContent) return;

            // 設置最大高度為視窗高度的95%，留一些空間
            modalContent.style.maxHeight = '95vh';
            modalContent.style.height = '95vh';
            modalContent.style.display = 'flex';
            modalContent.style.flexDirection = 'column';

            // 獲取標題和按鈕區域的高度
            const header = modalContent.querySelector('h2');
            const footer = modalContent.querySelector('div.flex.justify-end');
            const headerHeight = header ? header.offsetHeight : 0;
            const footerHeight = footer ? footer.offsetHeight : 0;

            // 獲取卡片列表容器
            const deckCardsList = document.getElementById('deckCardsList');
            const availableCardsList = document.getElementById('availableCardsList');

            // 計算列表可用高度
            const listsContainerHeight = modalContent.clientHeight - headerHeight - footerHeight - 80; // 減去padding和其他元素的高度
            const listHeight = listsContainerHeight / 2 - 30; // 兩個列表平分高度，減去margin

            // 應用高度
            if (deckCardsList) {
                deckCardsList.style.maxHeight = `${listHeight}px`;
                deckCardsList.style.height = `${listHeight}px`;
            }

            if (availableCardsList) {
                availableCardsList.style.maxHeight = `${listHeight}px`;
                availableCardsList.style.height = `${listHeight}px`;
            }
        }

        // 在視窗大小變化時調整對話框高度
        window.addEventListener('resize', function() {
            adjustDeckEditModalHeight();
        });

        // 創建一個加強版函數
        function enhancedOpenDeckEditModal(deckId) {
            // 調用原始函數
            openDeckEditModal(deckId);

            // 在對話框打開後調整高度
            setTimeout(adjustDeckEditModalHeight, 0);
        }

        // 找到所有調用 openDeckEditModal 的地方，替換為 enhancedOpenDeckEditModal
        // 例如在 edit-deck-btn 按鈕的事件監聽器中：
        document.querySelectorAll('.edit-deck-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const deckId = parseInt(e.currentTarget.dataset.id);
                enhancedOpenDeckEditModal(deckId); // 改用加強版函數
            });
        });

        // Load cards in deck for editing
        // 修改卡片載入函數以支持搜尋
        function loadDeckCards(deck, searchText = '') {
            deckCardsList.innerHTML = '';

            if (deck.cardIds.length === 0) {
                deckCardsList.innerHTML = '<p class="text-gray-500 text-sm py-2">此卡組中沒有字卡</p>';
                return;
            }

            // 取得並過濾卡片
            let filteredCards = deck.cardIds
                .map(cardId => cardsData.find(c => c.id === cardId))
                .filter(card => card); // 移除未找到的卡片

            // 如果有搜尋文字，過濾卡片
            if (searchText) {
                const lowerSearchText = searchText.toLowerCase();
                filteredCards = filteredCards.filter(card =>
                    (card.frontText && stripHtml(card.frontText).toLowerCase().includes(lowerSearchText)) ||
                    (card.backText && stripHtml(card.backText).toLowerCase().includes(lowerSearchText))
                );
            }

            if (filteredCards.length === 0) {
                deckCardsList.innerHTML = '<p class="text-gray-500 text-sm py-2">沒有符合搜尋條件的字卡</p>';
                return;
            }

            filteredCards.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.className = 'flex justify-between items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';

                let frontPreview = stripHtml(card.frontText);
                if (frontPreview && frontPreview.length > 20) {
                    frontPreview = frontPreview.substring(0, 20) + '...';
                }

                // 處理背面預覽
                let backPreview = stripHtml(card.backText);
                if (backPreview && backPreview.length > 20) {
                    backPreview = backPreview.substring(0, 20) + '...';
                }

                cardElement.innerHTML = `
                    <div class="flex-1 pr-2">
                        <div class="flex flex-col">
                            <span class="text-sm font-medium">${frontPreview || '無文字'}</span>
                            <span class="text-sm text-gray-600 dark:text-gray-400">${backPreview || '無文字'}</span>
                        </div>
                    </div>
                    <button class="remove-from-deck-btn text-red-500 hover:text-red-700 text-sm" data-card-id="${card.id}">
                        移除
                    </button>
                `;

                deckCardsList.appendChild(cardElement);
            });

            // 添加移除字卡按鈕的事件監聽器
            document.querySelectorAll('.remove-from-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const cardId = parseInt(e.currentTarget.dataset.cardId);
                    removeCardFromDeck(cardId);
                });
            });
        }

        // Load available cards for deck editing
        function loadAvailableCards(deck, searchText = '') {
            availableCardsList.innerHTML = '';

            const availableCards = cardsData.filter(card => !deck.cardIds.includes(card.id));

            // 如果有搜尋文字，過濾卡片
            let filteredCards = availableCards;
            if (searchText) {
                const lowerSearchText = searchText.toLowerCase();
                filteredCards = availableCards.filter(card =>
                    (card.frontText && stripHtml(card.frontText).toLowerCase().includes(lowerSearchText)) ||
                    (card.backText && stripHtml(card.backText).toLowerCase().includes(lowerSearchText))
                );
            }

            if (filteredCards.length === 0) {
                availableCardsList.innerHTML = '<p class="text-gray-500 text-sm py-2">沒有符合搜尋條件的字卡</p>';
                return;
            }

            filteredCards.forEach(card => {
                const cardElement = document.createElement('div');
                cardElement.className = 'flex justify-between items-center p-2 bg-gray-100 dark:bg-gray-700 rounded';

                let frontPreview = stripHtml(card.frontText);
                if (frontPreview && frontPreview.length > 20) {
                    frontPreview = frontPreview.substring(0, 20) + '...';
                }

                // 處理背面預覽
                let backPreview = stripHtml(card.backText);
                if (backPreview && backPreview.length > 20) {
                    backPreview = backPreview.substring(0, 20) + '...';
                }

                // 查找所在卡組
                const containingDecks = decksData.filter(d => d.cardIds.includes(card.id));
                let decksInfo = '';
                if (containingDecks.length > 0) {
                    // 顯示具體卡組名稱
                    const deckNames = containingDecks.map(d => d.name).join(', ');
                    decksInfo = `<span class="text-xs text-gray-500 dark:text-gray-500">卡組: ${deckNames}</span>`;
                }
                cardElement.innerHTML = `
                    <div class="flex-1 pr-2">
                        <div class="flex flex-col">
                            <span class="text-sm font-medium">${frontPreview || '無文字'}</span>
                            <span class="text-sm text-gray-600 dark:text-gray-400">${backPreview || '無文字'}</span>
                            ${decksInfo}
                        </div>
                    </div>
                    <button class="add-to-deck-btn text-green-500 hover:text-green-700 text-sm" data-card-id="${card.id}">
                        添加
                    </button>
                `;

                availableCardsList.appendChild(cardElement);
            });

            // Add add card to deck event listeners
            document.querySelectorAll('.add-to-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const cardId = parseInt(e.currentTarget.dataset.cardId);
                    addCardToDeck(cardId);
                });
            });
        }

        // Remove card from deck during editing
        // 修改移除卡片函數
        function removeCardFromDeck(cardId) {
            const deckIndex = decksData.findIndex(d => d.id === editingDeckId);
            if (deckIndex === -1) return;

            // 獲取當前搜尋文字
            const searchDeckCardsInput = document.getElementById('searchDeckCards');
            const searchAvailableCardsInput = document.getElementById('searchAvailableCards');
            const deckSearchText = searchDeckCardsInput ? searchDeckCardsInput.value.trim() : '';
            const availableSearchText = searchAvailableCardsInput ? searchAvailableCardsInput.value.trim() : '';

            // 從卡組中移除卡片
            decksData[deckIndex].cardIds = decksData[deckIndex].cardIds.filter(id => id !== cardId);

            // 重新載入卡片列表，保持搜尋條件
            loadDeckCards(decksData[deckIndex], deckSearchText);
            loadAvailableCards(decksData[deckIndex], availableSearchText);
        }

        // Add card to deck during editing
        function addCardToDeck(cardId) {
            const deckIndex = decksData.findIndex(d => d.id === editingDeckId);
            if (deckIndex === -1) return;

            // Only add if not already in the deck
            if (!decksData[deckIndex].cardIds.includes(cardId)) {
                decksData[deckIndex].cardIds.push(cardId);
            }

            // Reload card lists
            loadDeckCards(decksData[deckIndex]);
            loadAvailableCards(decksData[deckIndex]);
        }

        // Close deck edit modal
        function closeDeckEditModal() {
            deckEditModal.classList.add('hidden');
            document.removeEventListener('click', handleDeckEditOutsideClick);
            editingDeckId = null;
        }

        // Handle click outside the deck edit modal to close it
        function handleDeckEditOutsideClick(event) {
            const modalContent = deckEditModal.querySelector('div');
            if (deckEditModal.contains(event.target) && !modalContent.contains(event.target)) {
                closeDeckEditModal();
            }
        }

        // Save deck edit
        function saveDeckEdit() {
            const deckIndex = decksData.findIndex(d => d.id === editingDeckId);
            if (deckIndex === -1) return;

            const name = editDeckNameInput.value.trim();
            const description = editDeckDescriptionInput.value.trim();

            if (name) {
                decksData[deckIndex].name = name;
                decksData[deckIndex].description = description;

                closeDeckEditModal();
                loadAllDecks();
                showNotification('卡組已更新');

                // Show storage reminder as data has changed
                showStorageReminder();
                saveDataToLocalStorage();
            } else {
                showNotification('卡組名稱不能為空');
            }
        }

        // 自定義確認對話框
        function customConfirm(message, title, callback) {
            const confirmModal = document.getElementById('customConfirmModal');
            const confirmModalTitle = document.getElementById('confirmModalTitle');
            const confirmModalMessage = document.getElementById('confirmModalMessage');
            const confirmModalCancelBtn = document.getElementById('confirmModalCancelBtn');
            const confirmModalConfirmBtn = document.getElementById('confirmModalConfirmBtn');

            // 設置標題和消息
            confirmModalTitle.textContent = title || '確認操作';
            confirmModalMessage.textContent = message;

            // 顯示對話框
            confirmModal.classList.remove('hidden');

            // 點擊確認按鈕
            const confirmHandler = () => {
                confirmModal.classList.add('hidden');
                confirmModalConfirmBtn.removeEventListener('click', confirmHandler);
                confirmModalCancelBtn.removeEventListener('click', cancelHandler);
                document.removeEventListener('click', outsideClickHandler);
                callback(true);
            };

            // 點擊取消按鈕
            const cancelHandler = () => {
                confirmModal.classList.add('hidden');
                confirmModalConfirmBtn.removeEventListener('click', confirmHandler);
                confirmModalCancelBtn.removeEventListener('click', cancelHandler);
                document.removeEventListener('click', outsideClickHandler);
                callback(false);
            };

            // 點擊對話框外部
            const outsideClickHandler = (event) => {
                const modalContent = confirmModal.querySelector('div');
                if (confirmModal.contains(event.target) && !modalContent.contains(event.target)) {
                    cancelHandler();
                }
            };

            // 添加事件監聽器
            confirmModalConfirmBtn.addEventListener('click', confirmHandler);
            confirmModalCancelBtn.addEventListener('click', cancelHandler);
            document.addEventListener('click', outsideClickHandler);
        }

        // Delete a deck
        function deleteDeck(deckId) {
            // 使用自定義確認對話框替代confirm
            customConfirm('確定要刪除此卡組嗎？', '刪除卡組', (confirmed) => {
                if (confirmed) {
                    decksData = decksData.filter(deck => deck.id !== deckId);
                    loadAllDecks();
                    showNotification('卡組已刪除');

                    // 顯示存儲提醒
                    showStorageReminder();
                    saveDataToLocalStorage();
                }
            });
        }

        // Helper: Format date
        function formatDate(timestamp) {
            const date = new Date(timestamp);
            return `${date.getFullYear()}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}`;
        }

        // Show notification
        function showNotification(message, duration = 2000) {
            const notification = document.createElement('div');
            notification.className = 'fixed bottom-4 right-4 bg-primary text-white px-4 py-2 rounded-lg shadow-lg transition-opacity duration-500';
            notification.textContent = message;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    if (notification.parentNode) {
                        document.body.removeChild(notification);
                    }
                }, 500);
            }, duration);
        }

        // 【新增】將數據保存到瀏覽器的 localStorage
        function saveDataToLocalStorage() {
            try {
                // 將 cardsData 和 decksData 陣列轉換為 JSON 字串並儲存
                localStorage.setItem('flashcard_cardsData', JSON.stringify(cardsData));
                localStorage.setItem('flashcard_decksData', JSON.stringify(decksData));
                console.log("數據已成功保存到 localStorage。");
            } catch (e) {
                console.error("保存數據到 localStorage 失敗:", e);
                // 如果儲存失敗（例如空間已滿），可以提示使用者
                showNotification("錯誤：無法自動保存您的數據！請嘗試手動匯出。", 5000);
            }
        }

        // 【新增】從瀏覽器的 localStorage 載入數據
        function loadDataFromLocalStorage() {
            try {
                const savedCards = localStorage.getItem('flashcard_cardsData');
                const savedDecks = localStorage.getItem('flashcard_decksData');
                const lastSaved = localStorage.getItem('flashcard_lastSaved');
                // 【新增】讀取 "關鍵概念一覽表" 的數據
                const savedExcelSheets = localStorage.getItem('flashcard_excelSheets');

                if (savedCards) {
                    cardsData = JSON.parse(savedCards);
                    console.log(`從 localStorage 載入了 ${cardsData.length} 張字卡。`);
                }

                if (savedDecks) {
                    decksData = JSON.parse(savedDecks);
                    console.log(`從 localStorage 載入了 ${decksData.length} 個卡組。`);
                }

                // 【新增】如果存在已儲存的工作表數據，則載入
                if (savedExcelSheets) {
                    excelSheets = JSON.parse(savedExcelSheets);
                    console.log(`從 localStorage 載入了 ${Object.keys(excelSheets).length} 個工作表數據。`);
                }


                // 載入後更新時間戳顯示
                if(lastSaved) {
                    updateLastSavedTimestamp(lastSaved);
                }

            } catch (e) {
                console.error("從 localStorage 讀取數據失敗:", e);
                // 如果解析失敗，重置為空，防止程式崩潰
                cardsData = [];
                decksData = [];
                excelSheets = {}; // 【新增】確保在出錯時也清空
                showNotification("錯誤：讀取本地存檔失敗，將以空白狀態啟動。", 5000);
            }
        }

        // 【新增】統一的UI刷新函數，在導入數據後調用
        function refreshAllViews() {
            console.log("Refreshing all UI components with new data...");

            // 1. 無論在哪個頁面，都先更新這些共享的數據來源
            loadDeckList(); // 更新「複習」頁面的卡組列表
            loadDeckFilterOptions(); // 更新「管理字卡」頁面的卡組過濾下拉選單

            // 2. 根據當前顯示的頁面，刷新其主要內容
            if (!keyConceptsSection.classList.contains('hidden')) {
                loadKeyConceptsView();
            } else if (!reviewSection.classList.contains('hidden')) {
                // 如果在複習頁，確保回到卡組選擇畫面
                showReviewStage('deckSelection');
            } else if (!manageDeckSection.classList.contains('hidden')) {
                loadAllDecks();
            } else if (!manageCardSection.classList.contains('hidden')) {
                loadAllCards();
            } else if (!createCardSection.classList.contains('hidden')) {
                // 如果在建立字卡頁面，導入後應顯示卡組選擇器
                if(decksData.length > 0) {
                    noDeckWarning.classList.add('hidden');
                    deckSelectionForCard.classList.remove('hidden');
                    cardForm.classList.remove('hidden');
                    updateSelectedDecksDisplay();
                    initSearchableDeckSelector();
                }
            }

            // 3. 顯示一個統一的成功提示
            showNotification('數據已成功導入並更新頁面！', 2500);

            // 【已移除】不再呼叫 showStorageReminder()
        }

        // Show welcome message for first-time users
        function showWelcomeMessage() {
            const welcomeModal = document.createElement('div');
            welcomeModal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            welcomeModal.id = 'welcomeModal';
            welcomeModal.innerHTML = `
                <div class="bg-white dark:bg-gray-800 p-6 rounded-lg shadow-lg max-w-lg w-full mx-4">
                    <h2 class="text-xl font-semibold mb-4 text-primary">歡迎使用遺忘曲線字卡程式</h2>
                    <div class="space-y-4">
                        <p>此應用程式數據儲存在瀏覽器記憶體中，<strong class="text-red-500">不會自動保存</strong>。</p>
                        <p class="font-medium">為避免數據丟失，請注意：</p>
                        <ul class="list-disc pl-5 space-y-2">
                            <li>使用右上角的「匯出數據」按鈕定期保存您的卡組和字卡</li>
                            <li>重要更改後立即匯出保存</li>
                            <li>下次使用時，通過「匯入數據」按鈕載入您保存的檔案</li>
                        </ul>
                        <div class="flex justify-end pt-4">
                            <button id="welcomeCloseBtn" class="px-4 py-2 bg-primary hover:bg-opacity-80 text-white rounded-lg">
                                我明白了
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(welcomeModal);

            document.getElementById('welcomeCloseBtn').addEventListener('click', () => {
                welcomeModal.remove();
            });
        }

        // 初始化警告中的"建立第一個卡組"連結
        function initCreateCardWarningLink() {
            const createFirstDeckLinkInWarning = document.getElementById('createFirstDeckLinkInWarning');
            if (createFirstDeckLinkInWarning) {
                createFirstDeckLinkInWarning.addEventListener('click', (e) => {
                    e.preventDefault();
                    openNewDeckModal();
                });
            }
        }

        // 輔助函數：將純文字中的換行符轉為HTML的<br>標籤
                function processRawTextForCard(rawText) {
                    if (!rawText || typeof rawText !== 'string') {
                        return '';
                    }
                    // 替換所有類型的換行符為 <br>
                    return rawText.replace(/\r\n/g, '<br>').replace(/\n/g, '<br>');
                }

        // Excel Import Functions
        // 初始化Excel導入功能
        function initExcelImport() {
            // 打開Excel導入對話框
            importExcelBtn.addEventListener('click', openExcelImportModal);

            // 關閉Excel導入對話框
            closeImportExcelBtn.addEventListener('click', closeExcelImportModal);

            // 處理Excel文件選擇
            excelFileInput.addEventListener('change', handleExcelFileSelect);

            // 下載Excel模板
            downloadExcelTemplateBtn.addEventListener('click', downloadExcelTemplate);

            // 步驟之間的切換
            nextToPreviewBtn.addEventListener('click', () => {
                showExcelStep(2);
                preparePreviewData();
            });

            // 處理"導入新檔案"按鈕點擊
            importNewFileBtn.addEventListener('click', function() {
                resetExcelImport();
                showExcelStep(1);
            });

            // 處理"完成"按鈕點擊
            finishImportBtn.addEventListener('click', function() {
                closeExcelImportModal();

                // 如果當前在複習頁面，確保視圖已更新到最新狀態
                if (!reviewSection.classList.contains('hidden')) {
                    showReviewStage('deckSelection');
                }
            });

            backToFileBtn.addEventListener('click', () => {
                showExcelStep(1);
            });

            importExcelDataBtn.addEventListener('click', importExcelData);
            finishImportBtn.addEventListener('click', function() {
                closeExcelImportModal();

                // 如果當前在複習頁面，確保視圖已更新到最新狀態
                if (!reviewSection.classList.contains('hidden')) {
                    showReviewStage('deckSelection');
                }
            });

            // 卡組選擇選項的處理
            document.querySelectorAll('input[name="deckOption"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    if (this.value === 'existing') {
                        existingDeckSelector.classList.remove('hidden');
                        newDeckInputs.classList.add('hidden');
                    } else {
                        existingDeckSelector.classList.add('hidden');
                        newDeckInputs.classList.remove('hidden');
                    }
                });
            });

            // 點擊對話框外部以關閉
            importExcelModal.addEventListener('click', function(e) {
                if (e.target === importExcelModal) {
                    closeExcelImportModal();
                }
            });
        }

        // 打開Excel導入對話框
        function openExcelImportModal() {
            resetExcelImport();
            importExcelModal.classList.remove('hidden');
            loadExistingDecks();
        }

        // 關閉Excel導入對話框
        function closeExcelImportModal() {
            importExcelModal.classList.add('hidden');
            resetExcelImport();
        }

        // 重置Excel導入數據和界面
        function resetExcelImport() {
            excelData = null;
            excelColumns = [];
            excelFileName = '';
            excelFileInput.value = '';
            excelFileNameDisplay.classList.add('hidden');
            excelFileNameDisplay.textContent = '';
            nextToPreviewBtn.disabled = true;
            showExcelStep(1);
            excelSheets = {};
            activeSheetName = '';
            sheetMappings = {};
            sheetOptions = {};
        }

        // 顯示指定的Excel匯入步驟
        function showExcelStep(step) {
            excelStep1.classList.add('hidden');
            excelStep2.classList.add('hidden');
            excelStep3.classList.add('hidden');

            if (step === 1) {
                excelStep1.classList.remove('hidden');
            } else if (step === 2) {
                excelStep2.classList.remove('hidden');
            } else if (step === 3) {
                excelStep3.classList.remove('hidden');
            }
        }

        // 處理Excel文件選擇
        function handleExcelFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            // 顯示文件名
            excelFileName = file.name;
            excelFileNameDisplay.textContent = `選擇的檔案: ${excelFileName}`;
            excelFileNameDisplay.classList.remove('hidden');

            // 讀取Excel文件
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });

                    // 檢查是否有工作表
                    if (workbook.SheetNames.length === 0) {
                        showNotification('Excel文件必須至少包含一個工作表');
                        resetExcelImport();
                        return;
                    }

                    // 處理所有工作表
                    workbook.SheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        const sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                        // 確保至少有標題行
                        if (sheetData.length < 2) {
                            console.warn(`工作表 "${sheetName}" 沒有足夠的數據，已忽略`);
                            return;
                        }

                        // 保存工作表數據
                        excelSheets[sheetName] = {
                            data: sheetData,
                            columns: sheetData[0]
                        };

                        // 設置默認卡組映射和列選擇
                        sheetMappings[sheetName] = {
                            deckOption: 'new',
                            deckId: '',
                            newDeckName: sheetName,
                            newDeckDescription: ''
                        };

                        sheetOptions[sheetName] = {
                            frontColumn: 0,
                            backColumn: 1
                        };
                    });

                    // 設置第一個工作表為活動工作表
                    activeSheetName = workbook.SheetNames[0];

                    // 啟用下一步按鈕
                    nextToPreviewBtn.disabled = false;

                } catch (error) {
                    console.error('解析Excel文件出錯:', error);
                    showNotification('解析Excel文件時出錯，請確保文件格式正確');
                    resetExcelImport();
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // 準備預覽數據 - 支持多工作表
        function preparePreviewData() {
            if (Object.keys(excelSheets).length === 0) return;

            // 更新工作表選項卡
            updateSheetTabs();

            // 顯示活動工作表的預覽數據
            showSheetPreview(activeSheetName);

            // 設置工作表映射選項
            updateSheetMappingOptions();

            // 更新格式狀態指示器
            const formatStatusValue = document.getElementById('formatStatusValue');
            if (formatStatusValue) {
                const hasFormatting = excelSheets[activeSheetName]?.hasFormatting;
                if (hasFormatting) {
                    formatStatusValue.textContent = '帶格式（粗體、斜體等將被保留）';
                    formatStatusValue.className = 'text-green-600 dark:text-green-400';
                } else {
                    formatStatusValue.textContent = '純文本（不保留格式）';
                    formatStatusValue.className = 'text-yellow-600 dark:text-yellow-400';
                }
            }
        }

        // 更新工作表選項卡
        function updateSheetTabs() {
            sheetTabsContainer.innerHTML = '';

            Object.keys(excelSheets).forEach(sheetName => {
                const tabElement = document.createElement('div');
                tabElement.className = `sheet-tab ${sheetName === activeSheetName ? 'active' : ''}`;
                tabElement.textContent = sheetName;
                tabElement.dataset.sheet = sheetName;

                tabElement.addEventListener('click', () => {
                    document.querySelectorAll('.sheet-tab').forEach(tab => tab.classList.remove('active'));
                    tabElement.classList.add('active');
                    activeSheetName = sheetName;
                    showSheetPreview(sheetName);

                    // 更新列選擇
                    updateColumnSelectors(sheetName);
                });

                sheetTabsContainer.appendChild(tabElement);
            });
        }

        // 顯示指定工作表的預覽
        function showSheetPreview(sheetName) {
            if (!excelSheets[sheetName]) return;

            const sheetData = excelSheets[sheetName].data;
            const columns = excelSheets[sheetName].columns;

            // 清空現有內容
            excelPreviewHead.innerHTML = '';
            excelPreviewBody.innerHTML = '';

            // 創建表頭
            const headerRow = document.createElement('tr');
            columns.forEach(column => {
                const th = document.createElement('th');
                th.className = 'px-3 py-2 text-left text-sm font-medium';
                th.textContent = column;
                headerRow.appendChild(th);
            });
            excelPreviewHead.appendChild(headerRow);

            // 添加最多5行預覽數據
            const previewRowCount = Math.min(sheetData.length - 1, 5);
            for (let i = 1; i <= previewRowCount; i++) {
                const row = sheetData[i];
                const tr = document.createElement('tr');
                tr.className = i % 2 === 0 ? 'bg-gray-50 dark:bg-gray-900' : '';

                row.forEach((cell, index) => {
                    const td = document.createElement('td');
                    td.className = 'px-3 py-2 text-sm';
                    td.textContent = cell != null ? cell.toString() : '';
                    if (td.textContent.length > 50) {
                        td.textContent = td.textContent.substring(0, 50) + '...';
                    }
                    tr.appendChild(td);
                });

                excelPreviewBody.appendChild(tr);
            }

            // 顯示總行數
            excelRowCount.textContent = `共 ${sheetData.length - 1} 行數據`;

            // 更新列選擇下拉框
            updateColumnSelectors(sheetName);
        }

        // 更新列選擇下拉框
        function updateColumnSelectors(sheetName) {
            frontColumnSelect.innerHTML = '';
            backColumnSelect.innerHTML = '';

            const columns = excelSheets[sheetName].columns;

            columns.forEach((column, index) => {
                // 前面列選擇器
                const frontOption = document.createElement('option');
                frontOption.value = index;
                frontOption.textContent = column;
                frontColumnSelect.appendChild(frontOption);

                // 背面列選擇器
                const backOption = document.createElement('option');
                backOption.value = index;
                backOption.textContent = column;
                backColumnSelect.appendChild(backOption);
            });

            // 設置已保存的選擇或默認選擇
            if (sheetOptions[sheetName]) {
                frontColumnSelect.value = sheetOptions[sheetName].frontColumn;
                backColumnSelect.value = sheetOptions[sheetName].backColumn;
            } else if (columns.length >= 2) {
                frontColumnSelect.value = 0;
                backColumnSelect.value = 1;
            }

            // 添加列選擇變更監聽器
            frontColumnSelect.onchange = () => {
                sheetOptions[sheetName].frontColumn = parseInt(frontColumnSelect.value);
            };

            backColumnSelect.onchange = () => {
                sheetOptions[sheetName].backColumn = parseInt(backColumnSelect.value);
            };
        }

        // 更新工作表映射選項
        function updateSheetMappingOptions() {
            sheetMappingContainer.innerHTML = '';

            Object.keys(excelSheets).forEach(sheetName => {
                const mapping = sheetMappings[sheetName];

                const mappingElement = document.createElement('div');
                mappingElement.className = 'border border-gray-300 dark:border-gray-700 rounded-lg p-3 mb-2';

                mappingElement.innerHTML = `
                    <h4 class="font-medium mb-2">工作表「${sheetName}」</h4>
                    <div class="space-y-2">
                        <div>
                            <label class="flex items-center">
                                <input type="radio" name="deckOption-${sheetName}" value="existing"
                                    ${mapping.deckOption === 'existing' ? 'checked' : ''} class="mr-2">
                                <span>添加到現有卡組</span>
                            </label>
                            <div class="existing-deck-selector ml-6 mt-1 ${mapping.deckOption === 'existing' ? '' : 'hidden'}">
                                <select class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800">
                                    ${decksData.map(deck => `<option value="${deck.id}" ${mapping.deckId === deck.id.toString() ? 'selected' : ''}>${deck.name} (${deck.cardIds.length} 張字卡)</option>`).join('')}
                                </select>
                            </div>
                        </div>
                        <div>
                            <label class="flex items-center">
                                <input type="radio" name="deckOption-${sheetName}" value="new"
                                    ${mapping.deckOption === 'new' ? 'checked' : ''} class="mr-2">
                                <span>創建新卡組</span>
                            </label>
                            <div class="new-deck-inputs ml-6 mt-1 ${mapping.deckOption === 'new' ? '' : 'hidden'}">
                                <input type="text" placeholder="卡組名稱" value="${mapping.newDeckName}"
                                    class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800 mb-2">
                                <textarea placeholder="卡組描述（選填）"
                                    class="w-full px-3 py-2 border border-gray-300 dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary dark:bg-gray-800" rows="2">${mapping.newDeckDescription}</textarea>
                            </div>
                        </div>
                    </div>
                `;

                sheetMappingContainer.appendChild(mappingElement);

                // 添加事件監聽器
                const existingRadio = mappingElement.querySelector(`input[name="deckOption-${sheetName}"][value="existing"]`);
                const newRadio = mappingElement.querySelector(`input[name="deckOption-${sheetName}"][value="new"]`);
                const existingSelector = mappingElement.querySelector('.existing-deck-selector');
                const newInputs = mappingElement.querySelector('.new-deck-inputs');
                const deckSelect = mappingElement.querySelector('.existing-deck-selector select');
                const newDeckNameInput = mappingElement.querySelector('.new-deck-inputs input');
                const newDeckDescInput = mappingElement.querySelector('.new-deck-inputs textarea');

                existingRadio.addEventListener('change', function() {
                    if (this.checked) {
                        existingSelector.classList.remove('hidden');
                        newInputs.classList.add('hidden');
                        mapping.deckOption = 'existing';
                        mapping.deckId = deckSelect.value;
                    }
                });

                newRadio.addEventListener('change', function() {
                    if (this.checked) {
                        existingSelector.classList.add('hidden');
                        newInputs.classList.remove('hidden');
                        mapping.deckOption = 'new';
                    }
                });

                deckSelect.addEventListener('change', function() {
                    mapping.deckId = this.value;
                });

                newDeckNameInput.addEventListener('input', function() {
                    mapping.newDeckName = this.value;
                });

                newDeckDescInput.addEventListener('input', function() {
                    mapping.newDeckDescription = this.value;
                });
            });
        }

        // 加載現有的卡組到下拉選單
        function loadExistingDecks() {
            // 首先檢查元素是否存在
            const targetExistingDeck = document.getElementById('targetExistingDeck');

            // 如果元素不存在，直接返回
            if (!targetExistingDeck) {
                console.warn('找不到 targetExistingDeck 元素');
                return;
            }

            targetExistingDeck.innerHTML = '';

            if (decksData.length === 0) {
                // 如果沒有現有卡組，默認選擇"創建新卡組"
                const newRadio = document.querySelector('input[name="deckOption"][value="new"]');
                if (newRadio) {
                    newRadio.checked = true;
                }

                const existingDeckSelector = document.getElementById('existingDeckSelector');
                const newDeckInputs = document.getElementById('newDeckInputs');

                if (existingDeckSelector) existingDeckSelector.classList.add('hidden');
                if (newDeckInputs) newDeckInputs.classList.remove('hidden');

                // 添加一個提示選項
                const noDecksOption = document.createElement('option');
                noDecksOption.value = '';
                noDecksOption.textContent = '沒有現有卡組';
                noDecksOption.disabled = true;
                targetExistingDeck.appendChild(noDecksOption);
            } else {

                // 默認選擇"添加到現有卡組"
                document.querySelector('input[name="deckOption"][value="existing"]').checked = true;
                existingDeckSelector.classList.remove('hidden');
                newDeckInputs.classList.add('hidden');

                // 加載所有卡組
                decksData.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.id;
                    option.textContent = `${deck.name} (${deck.cardIds.length} 張字卡)`;
                    targetExistingDeck.appendChild(option);
                });
            }
        }

        // 下載Excel模板 - 更新為多工作表版本
        function downloadExcelTemplate() {
            // 創建工作簿
            const wb = XLSX.utils.book_new();

            // 創建示例工作表 1 - 英文單字
            const englishData = [
                ['正面內容', '背面內容', '備註(選填)'],
                ['Apple', '蘋果', '水果'],
                ['Book', '書本', '文具'],
                ['Computer', '電腦', '電子產品']
            ];
            const wsEnglish = XLSX.utils.aoa_to_sheet(englishData);
            XLSX.utils.book_append_sheet(wb, wsEnglish, '英文單字');

            // 創建示例工作表 2 - 歷史事件
            const historyData = [
                ['事件', '年代', '重要性'],
                ['中國改革開放', '1978年', '高'],
                ['柏林牆倒塌', '1989年', '高'],
                ['911事件', '2001年', '高']
            ];
            const wsHistory = XLSX.utils.aoa_to_sheet(historyData);
            XLSX.utils.book_append_sheet(wb, wsHistory, '歷史事件');

            // 生成Excel文件並下載
            XLSX.writeFile(wb, '字卡模板_多工作表.xlsx');
        }

        // 修改的importExcelData函數 - 支持多工作表並自動刷新
                function importExcelData() {
                    if (Object.keys(excelSheets).length === 0) {
                        showNotification('沒有可用的工作表數據');
                        return;
                    }

                    const results = [];

                    // 處理每個工作表
                    for (const sheetName of Object.keys(excelSheets)) {
                        const sheetData = excelSheets[sheetName].data;
                        const mapping = sheetMappings[sheetName];
                        const options = sheetOptions[sheetName];

                        if (options.frontColumn === options.backColumn) {
                            results.push({ sheetName, success: false, message: '正面和背面不能選擇相同的欄位' });
                            continue;
                        }

                        let targetDeckId;
                        let targetDeckName;
                        let newDeckCreated = false;

                        try {
                            if (mapping.deckOption === 'existing') {
                                targetDeckId = parseInt(mapping.deckId);
                                const deckIndex = decksData.findIndex(d => d.id === targetDeckId);
                                if (deckIndex === -1) {
                                    results.push({ sheetName, success: false, message: '找不到選擇的卡組' });
                                    continue;
                                }
                                targetDeckName = decksData[deckIndex].name;
                            } else {
                                const deckName = mapping.newDeckName.trim();
                                if (!deckName) {
                                    results.push({ sheetName, success: false, message: '卡組名稱不能為空' });
                                    continue;
                                }
                                const newDeck = {
                                    id: Date.now() + Math.floor(Math.random() * 1000),
                                    name: deckName,
                                    description: mapping.newDeckDescription.trim(),
                                    cardIds: [],
                                    createdAt: Date.now()
                                };
                                decksData.push(newDeck);
                                targetDeckId = newDeck.id;
                                targetDeckName = newDeck.name;
                                newDeckCreated = true;
                            }

                            const targetDeck = decksData.find(d => d.id === targetDeckId);
                            let importedCount = 0;
                            let skippedCount = 0;

                            for (let i = 1; i < sheetData.length; i++) {
                                const row = sheetData[i];
                                if (!row) {
                                    skippedCount++;
                                    continue;
                                }
                                const rawFrontContent = row[options.frontColumn];
                                const rawBackContent = row[options.backColumn];
                                if (!rawFrontContent && !rawBackContent) {
                                    skippedCount++;
                                    continue;
                                }
                                const processedFront = processImportedContent(rawFrontContent);
                                const frontText = processRawTextForCard(processedFront.text);
                                const frontImage = processedFront.image;
                                const processedBack = processImportedContent(rawBackContent);
                                const backText = processRawTextForCard(processedBack.text);
                                const backImage = processedBack.image;
                                const newCardId = Date.now() + i + Math.floor(Math.random() * 10000);
                                const newCard = {
                                    id: newCardId,
                                    frontText: frontText,
                                    frontImage: frontImage,
                                    backText: backText,
                                    backImage: backImage,
                                    nextReview: Date.now(),
                                    repetitions: 0,
                                    easeFactor: 2.0,
                                    interval: 1.0
                                };
                                cardsData.push(newCard);
                                targetDeck.cardIds.push(newCardId);
                                importedCount++;
                            }
                            results.push({ sheetName, success: true, targetDeckName, importedCount, skippedCount, newDeckCreated });
                        } catch (error) {
                            console.error(`工作表 "${sheetName}" 導入出錯:`, error);
                            results.push({ sheetName, success: false, message: '導入數據過程中發生錯誤' });
                        }
                    }

                    // 【關鍵修改】在顯示結果前，先刷新所有UI
                    refreshAllViews();

                    // 顯示導入結果
                    showExcelStep(3);
                    displayMultiSheetImportResults(results);

                    saveDataToLocalStorage();
                }

                                // 顯示多工作表導入結果
                                function displayMultiSheetImportResults(results) {
                                    importResults.innerHTML = '';

                                    let totalSuccess = 0;
                                    let totalFailed = 0;
                                    let totalCards = 0;

                                    // 彙總結果
                                    results.forEach(result => {
                                        if (result.success) {
                                            totalSuccess++;
                                            totalCards += result.importedCount;
                                        } else {
                                            totalFailed++;
                                        }
                                    });

                                    // 添加彙總資訊
                                    const summaryHTML = `
                                        <div class="mb-4 border-b pb-3 border-gray-300 dark:border-gray-700">
                                            <h3 class="font-medium mb-2 ${totalFailed > 0 ? 'text-yellow-600 dark:text-yellow-400' : 'text-green-600 dark:text-green-400'}">
                                                導入完成
                                            </h3>
                                            <p>成功處理 <span class="font-medium">${totalSuccess}</span> 個工作表，
                                               失敗 <span class="font-medium">${totalFailed}</span> 個工作表，
                                               共導入 <span class="font-medium">${totalCards}</span> 張字卡</p>
                                        </div>
                                    `;

                                    importResults.innerHTML = summaryHTML;

                                    // 添加每個工作表的詳細結果
                                    const detailsContainer = document.createElement('div');
                                    detailsContainer.className = "space-y-3";

                                    results.forEach(result => {
                                        const resultElement = document.createElement('div');
                                        resultElement.className = `p-3 rounded ${result.success ? 'bg-green-50 dark:bg-green-900/30' : 'bg-red-50 dark:bg-red-900/30'}`;

                                        if (result.success) {
                                            resultElement.innerHTML = `
                                                <h4 class="font-medium">工作表「${result.sheetName}」- 成功</h4>
                                                <p>導入 <span class="font-medium">${result.importedCount}</span> 張字卡${result.skippedCount > 0 ? `，跳過 ${result.skippedCount} 行數據` : ''}</p>
                                                <p>卡組: <span class="font-medium">${result.targetDeckName}</span> ${result.newDeckCreated ? '(新建)' : '(現有)'}</p>
                                            `;
                                        } else {
                                            resultElement.innerHTML = `
                                                <h4 class="font-medium text-red-600 dark:text-red-400">工作表「${result.sheetName}」- 失敗</h4>
                                                <p>${result.message || '未知錯誤'}</p>
                                            `;
                                        }

                                        detailsContainer.appendChild(resultElement);
                                    });

                                    importResults.appendChild(detailsContainer);

                                    // 添加導覽提示
                                    if (totalSuccess > 0) {
                                        const tipsElement = document.createElement('div');
                                        tipsElement.className = "mt-4 pt-4 border-t border-gray-300 dark:border-gray-700";
                                        tipsElement.innerHTML = `
                                            <p class="text-sm">你現在可以:</p>
                                            <ul class="list-disc pl-5 mt-2 text-sm space-y-1">
                                                <li>在「複習」頁面中選擇卡組進行複習</li>
                                                <li>在「管理卡組」頁面中查看或編輯卡組</li>
                                                <li>在「管理字卡」頁面中查看或編輯導入的字卡</li>
                                            </ul>
                                        `;
                                        importResults.appendChild(tipsElement);
                                    }
                                    // 預先更新複習頁面的卡組列表，確保導入後立即可見
                                    loadDeckList();

                                    // 如果用戶當前在複習頁面，確保視圖已正確更新
                                    if (!reviewSection.classList.contains('hidden')) {
                                        showReviewStage('deckSelection');
                                    }
                                }

                                // Initialize app
                                function initApp() {

                                  // 【關鍵新增】在應用程式初始化時，首先載入本地儲存的數據
                                  loadDataFromLocalStorage();

                                  // 初始化 Google Sheets 導入功能
                                  initGSheetsImport();

                                  // 【新增】由於按鈕位置改變，我們需要重新獲取元素並確保事件已綁定
                                  // 這些按鈕現在在新頁面中，所以我們在 initApp 裡確保它們的功能正常
                                  const newImportExcelBtn = document.getElementById('importExcelBtn');
                                  const newExportExcelBtn = document.getElementById('exportExcelBtn');
                                  const newImportGSheetsBtn = document.getElementById('importGSheetsBtn');
                                  const newExportDataBtn = document.getElementById('exportDataBtn');
                                  const newImportDataInput = document.getElementById('importDataInput');

                                  if(newImportExcelBtn) newImportExcelBtn.addEventListener('click', openExcelImportModal);
                                  if(newExportExcelBtn) newExportExcelBtn.addEventListener('click', openExportExcelModal);
                                  if(newImportGSheetsBtn) newImportGSheetsBtn.addEventListener('click', openGSheetsImportModal);
                                  if(newExportDataBtn) newExportDataBtn.addEventListener('click', openExportModal);
                                  if(newImportDataInput) newImportDataInput.addEventListener('change', handleImportFile);


                                  // 初始化 API 設置
                                  initApiSettings();

                                    // Initialize Quill editors
                                    initQuillEditors();

                                    // Setup image compression
                                    setupImageCompression();

                                    // Setup drag and drop for file upload
                                    setupDragAndDrop();

                                    // Setup storage reminders
                                    setupStorageReminders();

                                    // 初始化Excel導入功能
                                    initExcelImport();

                                    setupNavigationButtons();

                                    // 初始化Excel導出功能
                                    exportExcelBtn.addEventListener('click', openExportExcelModal);

                                    // Show welcome message for first time visitors
                                    if (!window.welcomeShown) {
                                        showWelcomeMessage();
                                        window.welcomeShown = true;
                                    }

                                    // 添加視窗大小變化監聽
                                    window.addEventListener('resize', function() {
                                        // 如果在複習界面，動態調整卡片容器高度
                                        if (!reviewInterface.classList.contains('hidden')) {
                                            const availableHeight = window.innerHeight - 220;
                                            cardContainer.style.height = `${Math.max(300, availableHeight * 0.6)}px`;
                                        }

                                        // 調整Quill編輯器外觀
                                        adjustQuillForDarkMode();
                                    });

                                    // Listen for dark mode changes
                                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', adjustQuillForDarkMode);

                                    // 初始觸發一次resize事件，以便在頁面加載時設置正確尺寸
                                    window.dispatchEvent(new Event('resize'));

                                    // 改為：
                                    setTimeout(() => {
                                        // 使用原始函數而非被包裝的函數
                                        showSection('review');
                                    }, 0);

                                    // 【新增】綁定本地儲存管理按鈕的事件
                                    const forceSaveBtn = document.getElementById('forceSaveBtn');
                                    const clearLocalStorageBtn = document.getElementById('clearLocalStorageBtn');

                                    if (forceSaveBtn) {
                                        forceSaveBtn.addEventListener('click', () => {
                                            saveDataToLocalStorage();
                                            showNotification('已手動儲存所有資料！', 2000);
                                        });
                                    }

                                    if (clearLocalStorageBtn) {
                                        clearLocalStorageBtn.addEventListener('click', clearLocalStorageData);
                                    }
                                }

                                // Initialize app when DOM is ready
                                document.addEventListener('DOMContentLoaded', initApp);

                                // 為建立字卡按鈕添加Command+Enter或Ctrl+Enter快捷鍵
                                function setupCardSubmitShortcut() {
                                    // 添加全局鍵盤事件監聽
                                    document.addEventListener('keydown', function(e) {
                                        // 檢測是否是Command+Enter (Mac) 或 Ctrl+Enter (Windows/Linux)
                                        if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
                                            // 只有當建立字卡頁面可見時才執行
                                            if (!createCardSection.classList.contains('hidden')) {

                                                // 防止可能的默認行為
                                                e.preventDefault();

                                                // 模擬點擊「建立字卡」按鈕
                                                const submitButton = cardForm.querySelector('button[type="submit"]');
                                                if (submitButton) {
                                                    // 添加按鈕點擊效果以提供視覺反饋
                                                    submitButton.classList.add('active');
                                                    setTimeout(() => {
                                                        submitButton.classList.remove('active');
                                                    }, 200);

                                                    // 觸發表單提交
                                                    submitButton.click();
                                                }
                                            }
                                        }
                                    });

                                    // 添加提示樣式
                                    const styleElement = document.createElement('style');
                                    styleElement.textContent = `
                                        button[type="submit"].active {
                                            transform: scale(0.95);
                                            box-shadow: 0 0 0 3px rgba(93, 92, 222, 0.3);
                                        }
                                    `;
                                    document.head.appendChild(styleElement);

                                    // 添加快捷鍵提示到按鈕上
                                    const submitButton = cardForm.querySelector('button[type="submit"]');
                                    if (submitButton) {
                                        // 檢測操作系統以顯示適當的快捷鍵提示
                                        const isMac = /Mac|iPod|iPhone|iPad/.test(navigator.platform);
                                        const shortcutText = isMac ? '⌘+Enter' : 'Ctrl+Enter';

                                        // 創建提示元素
                                        const shortcutTip = document.createElement('span');
                                        shortcutTip.className = 'ml-2 text-xs text-white bg-black bg-opacity-30 px-2 py-1 rounded';
                                        shortcutTip.textContent = shortcutText;

                                        // 添加到按鈕中
                                        submitButton.appendChild(shortcutTip);

                                        // 更新按鈕樣式以容納提示
                                        submitButton.classList.add('flex', 'items-center', 'justify-center');
                                    }
                                }

                                // 確保DOM完全加載後運行
                                if (document.readyState === 'loading') {
                                    document.addEventListener('DOMContentLoaded', setupCardSubmitShortcut);
                                } else {
                                    setupCardSubmitShortcut();
                                }

                                // 檢測瀏覽器環境
                                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                                console.log('檢測到的瀏覽器：', isSafari ? 'Safari' : '其他瀏覽器');

                                // --- START: 新增「關鍵概念一覽表」功能 ---

                                // 1. 獲取新區塊的 DOM 元素
                                const keyConceptsSection = document.getElementById('keyConceptsSection');
                                const keyConceptsBtn = document.getElementById('keyConceptsBtn');

                                // 2. 修改 showSection 函數以處理新頁面
                                // 我們需要找到原始的 showSection 函數並擴充它
                                function setupNewNavigation() {
                                    // 【新增】獲取數據管理頁面的按鈕和區塊
                                    const dataManagementBtn = document.getElementById('dataManagementBtn');
                                    const dataManagementSection = document.getElementById('dataManagementSection');

                                    window.showSection = function(section) {
                                        // 先重置所有按鈕和區塊
                                        reviewBtn.classList.remove('border-primary');
                                        createCardBtn.classList.remove('border-primary');
                                        manageCardBtn.classList.remove('border-primary');
                                        manageDeckBtn.classList.remove('border-primary');
                                        keyConceptsBtn.classList.remove('border-primary');
                                        dataManagementBtn.classList.remove('border-primary'); // 【新增】

                                        reviewBtn.classList.add('border-transparent');
                                        createCardBtn.classList.add('border-transparent');
                                        manageCardBtn.classList.add('border-transparent');
                                        manageDeckBtn.classList.add('border-transparent');
                                        keyConceptsBtn.classList.add('border-transparent');
                                        dataManagementBtn.classList.add('border-transparent'); // 【新增】

                                        reviewSection.classList.add('hidden');
                                        createCardSection.classList.add('hidden');
                                        manageCardSection.classList.add('hidden');
                                        manageDeckSection.classList.add('hidden');
                                        keyConceptsSection.classList.add('hidden');
                                        dataManagementSection.classList.add('hidden'); // 【新增】

                                        // 清除所有計時器
                                        clearAllDrillTimers();

                                        // 根據傳入的 section 顯示對應內容
                                        if (section === 'keyConcepts') {
                                            keyConceptsBtn.classList.remove('border-transparent');
                                            keyConceptsBtn.classList.add('border-primary');
                                            keyConceptsSection.classList.remove('hidden');
                                            loadKeyConceptsView();
                                        } else if (section === 'dataManagement') { // 【新增】
                                            dataManagementBtn.classList.remove('border-transparent');
                                            dataManagementBtn.classList.add('border-primary');
                                            dataManagementSection.classList.remove('hidden');
                                        } else {
                                            // 如果不是新頁面，調用原始的 showSection 邏輯
                                            if (section === 'review') {
                                                reviewBtn.classList.remove('border-transparent');
                                                reviewBtn.classList.add('border-primary');
                                                reviewSection.classList.remove('hidden');
                                                showReviewStage('deckSelection');
                                                loadDeckList();
                                            } else if (section === 'createCard') {
                                                createCardBtn.classList.remove('border-transparent');
                                                createCardBtn.classList.add('border-primary');
                                                createCardSection.classList.remove('hidden');
                                                if (decksData.length === 0) {
                                                    noDeckWarning.classList.remove('hidden');
                                                    deckSelectionForCard.classList.add('hidden');
                                                    cardForm.classList.add('hidden');
                                                    initCreateCardWarningLink();
                                                } else {
                                                    noDeckWarning.classList.add('hidden');
                                                    deckSelectionForCard.classList.remove('hidden');
                                                    cardForm.classList.remove('hidden');
                                                    updateSelectedDecksDisplay();
                                                    initSearchableDeckSelector();
                                                }
                                            } else if (section === 'manageCard') {
                                                manageCardBtn.classList.remove('border-transparent');
                                                manageCardBtn.classList.add('border-primary');
                                                manageCardSection.classList.remove('hidden');
                                                loadDeckFilterOptions();
                                                loadAllCards();
                                                selectedCardIds.clear();
                                                updateBatchDeleteButton();
                                            } else if (section === 'manageDeck') {
                                                manageDeckBtn.classList.remove('border-transparent');
                                                manageDeckBtn.classList.add('border-primary');
                                                manageDeckSection.classList.remove('hidden');
                                                loadAllDecks();
                                                selectedDeckIds2.clear();
                                                updateBatchDeleteDecksButton();
                                            }
                                        }
                                    };

                                    // 為新按鈕添加事件監聽器
                                    keyConceptsBtn.addEventListener('click', () => window.showSection('keyConcepts'));
                                    dataManagementBtn.addEventListener('click', () => window.showSection('dataManagement')); // 【新增】

                                    // 將預設顯示的頁面從 'review' 改為 'keyConcepts'
                                    document.addEventListener('DOMContentLoaded', () => {
                                        setTimeout(() => {
                                            window.showSection('keyConcepts');
                                        }, 10);
                                    });
                                }

                                // 3. 載入「關鍵概念一覽表」視圖的主函數 (已加入切換按鈕邏輯)
                                function loadKeyConceptsView() {
                                    const sheetListContainer = document.getElementById('keyConceptsSheetList');
                                    const contentContainer = document.getElementById('keyConceptsContent');
                                    const controlsContainer = document.getElementById('keyConceptsControlsContainer');
                                    const searchInput = document.getElementById('keyConceptsSearchInput');
                                    const toggleAllBtn = document.getElementById('toggleAllConceptsBtn');

                                    sheetListContainer.innerHTML = '';
                                    contentContainer.innerHTML = ''; // 清除先前內容

                                    // 檢查是否有從 Google Sheets 導入的數據
                                    if (Object.keys(excelSheets).length === 0) {
                                        contentContainer.innerHTML = `
                                            <div class="text-center py-10 bg-gray-50 dark:bg-gray-800 rounded-lg">
                                                <h3 class="text-lg font-medium">無可用數據</h3>
                                                <p class="mt-2 text-gray-600 dark:text-gray-400">請先使用「從 Google Sheets 導入」功能載入您的概念表。</p>
                                                <button id="goToImportBtnFromConcepts" class="mt-4 bg-primary hover:bg-opacity-80 text-white font-semibold py-2 px-4 rounded-lg transition-colors">
                                                    前往導入
                                                </button>
                                            </div>
                                        `;
                                        document.getElementById('goToImportBtnFromConcepts').addEventListener('click', openGSheetsImportModal);
                                        controlsContainer.classList.add('hidden'); // 隱藏控制項
                                        return;
                                    }

                                    // 有數據時，顯示控制項並清空搜尋框
                                    controlsContainer.classList.remove('hidden');
                                    searchInput.value = '';

                                    // 為每個工作表創建按鈕
                                    Object.keys(excelSheets).forEach(sheetName => {
                                        const button = document.createElement('button');
                                        button.textContent = sheetName;
                                        button.dataset.sheetName = sheetName; // 使用 data attribute 存儲名稱
                                        button.className = 'px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-primary/10 transition-colors focus:outline-none focus:ring-2 focus:ring-primary';
                                        button.addEventListener('click', () => {
                                            // 更新按鈕樣式
                                            document.querySelectorAll('#keyConceptsSheetList button').forEach(btn => btn.classList.remove('bg-primary', 'text-white', 'border-primary'));
                                            button.classList.add('bg-primary', 'text-white', 'border-primary');
                                            // 切換工作表時，應用當前的搜尋條件
                                            displaySheetConcepts(sheetName, searchInput.value);
                                        });
                                        sheetListContainer.appendChild(button);
                                    });

                                    // 搜尋欄的事件監聽器
                                    searchInput.addEventListener('input', () => {
                                        const activeSheetBtn = document.querySelector('#keyConceptsSheetList button.bg-primary');
                                        if (activeSheetBtn) {
                                            const activeSheetName = activeSheetBtn.dataset.sheetName;
                                            displaySheetConcepts(activeSheetName, searchInput.value);
                                        }
                                    });

                                    // 【關鍵修改】為「展開/收合全部」按鈕設置事件監聽器 (確保只設置一次)
                                    if (!toggleAllBtn.listenerAttached) {
                                        toggleAllBtn.addEventListener('click', () => {
                                            const currentState = toggleAllBtn.dataset.state || 'closed';
                                            const detailsElements = document.querySelectorAll('#keyConceptsContent details');
                                            const shouldOpen = currentState === 'closed';

                                            detailsElements.forEach(detail => {
                                                detail.open = shouldOpen;
                                            });

                                            // 更新按鈕狀態和文字
                                            if (shouldOpen) {
                                                toggleAllBtn.textContent = '收合全部';
                                                toggleAllBtn.dataset.state = 'open';
                                            } else {
                                                toggleAllBtn.textContent = '展開全部';
                                                toggleAllBtn.dataset.state = 'closed';
                                            }
                                        });
                                        toggleAllBtn.listenerAttached = true; // 標記已設置監聽器
                                    }


                                    // 自動點擊並顯示第一個工作表的內容
                                    if (sheetListContainer.firstChild) {
                                        sheetListContainer.firstChild.click();
                                    }
                                }

                                // 4. 顯示指定工作表的概念列表 (已加入搜尋、空行過濾、重置切換按鈕狀態)
                                function displaySheetConcepts(sheetName, searchText = '') {
                                    const contentContainer = document.getElementById('keyConceptsContent');
                                    contentContainer.innerHTML = ''; // 清空

                                    const sheet = excelSheets[sheetName];
                                    if (!sheet || !sheet.data || sheet.data.length < 2) { // 至少需要標題+1行數據
                                        contentContainer.innerHTML = '<p class="text-gray-500 dark:text-gray-400">此工作表無內容。</p>';
                                        return;
                                    }

                                    let conceptRows = sheet.data.slice(1); // 獲取所有數據行
                                    const lowerSearchText = searchText.trim().toLowerCase();

                                    // 如果有搜尋文字，則過濾數據
                                    if (lowerSearchText) {
                                        conceptRows = conceptRows.filter(row => {
                                            const conceptText = getCellTextContent(row[0]).toLowerCase();
                                            const definitionText = getCellTextContent(row[1]).toLowerCase();
                                            const extraInfoText = row.length > 2 ? getCellTextContent(row[2]).toLowerCase() : '';

                                            return conceptText.includes(lowerSearchText) ||
                                                   definitionText.includes(lowerSearchText) ||
                                                   extraInfoText.includes(lowerSearchText);
                                        });
                                    }

                                    let itemsDisplayed = 0; // 用於計算實際顯示的項目數量

                                    // 遍歷過濾後的結果
                                    conceptRows.forEach(row => {
                                        const concept = row[0]; // 第 1 欄
                                        const definition = row[1]; // 第 2 欄
                                        const extraInfo = row.length > 2 ? row[2] : null; // 第 3 欄 (可選)

                                        // 如果第一欄和第二欄的內容都為空，則跳過此行
                                        if (!getCellTextContent(concept).trim() && !getCellTextContent(definition).trim()) {
                                            return; // continue a forEach loop
                                        }

                                        itemsDisplayed++; // 實際要顯示的項目加一

                                        const detailsEl = document.createElement('details');
                                        detailsEl.className = 'bg-white dark:bg-gray-800 p-4 rounded-lg shadow-sm group';

                                        const summaryEl = document.createElement('summary');
                                        summaryEl.className = 'font-medium text-lg list-none cursor-pointer flex justify-between items-center';

                                        const conceptHTML = processCellContent(concept);

                                        summaryEl.innerHTML = `
                                            <span>${conceptHTML || '<span class="italic text-gray-500">無標題</span>'}</span>
                                            <svg class="w-5 h-5 transition-transform duration-300 group-open:rotate-180 text-gray-500" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                              <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                                            </svg>
                                        `;

                                        const answerDiv = document.createElement('div');
                                        answerDiv.className = 'mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-gray-700 dark:text-gray-300 space-y-2';

                                        let answerHTML = '';
                                        if (definition) {
                                            answerHTML += `<div>${processCellContent(definition)}</div>`;
                                        }
                                        if (extraInfo) {
                                            answerHTML += `<div class="mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded text-sm">${processCellContent(extraInfo)}</div>`;
                                        }

                                        // 如果第二欄和第三欄都為空，也給一個提示
                                        if (!definition && !extraInfo) {
                                             answerHTML = '<p class="text-gray-500 italic">無詳細內容。</p>';
                                        }

                                        answerDiv.innerHTML = answerHTML;

                                        detailsEl.appendChild(summaryEl);
                                        detailsEl.appendChild(answerDiv);
                                        contentContainer.appendChild(detailsEl);
                                    });

                                    // 【關鍵修改】重置「展開/收合全部」按鈕的狀態
                                    const toggleBtn = document.getElementById('toggleAllConceptsBtn');
                                    if (toggleBtn) {
                                        toggleBtn.textContent = '展開全部';
                                        toggleBtn.dataset.state = 'closed';
                                    }

                                    // 如果遍歷完所有行後，沒有任何項目被顯示
                                    if (itemsDisplayed === 0) {
                                        if (searchText) {
                                            contentContainer.innerHTML = `<p class="text-center text-gray-500 dark:text-gray-400 py-4">在此工作表中找不到符合「${searchText}」的內容。</p>`;
                                        } else {
                                            contentContainer.innerHTML = '<p class="text-center text-gray-500 dark:text-gray-400 py-4">此工作表無有效內容可顯示。</p>';
                                        }
                                        toggleBtn.style.display = 'none'; // 如果沒有內容，隱藏切換按鈕
                                    } else {
                                        toggleBtn.style.display = ''; // 有內容則顯示按鈕
                                    }
                                }

                                // 5. 新增輔助函數來處理單元格內容 (可能為字串或帶格式的物件)
                                function processCellContent(cell) {
                                    if (!cell) return '';
                                    // 如果是從 Google Sheets API 來的帶格式物件
                                    if (typeof cell === 'object' && cell.delta) {
                                        return convertDeltaToHTML(cell.delta);
                                    }
                                    // 如果是普通字串 (例如從 CSV 導入)
                                    // 將換行符 \n 轉換為 <br>
                                    return cell.toString().replace(/\n/g, '<br>');
                                }

                                // 6. 新增輔助函數以獲取單元格的純文本內容，用於搜尋
                                function getCellTextContent(cell) {
                                    if (!cell) return '';
                                    // 如果是帶格式的物件
                                    if (typeof cell === 'object' && cell.delta) {
                                        // 使用一個臨時的Quill實例來提取純文本
                                        const tempEditor = document.createElement('div');
                                        const tempQuill = new Quill(tempEditor);
                                        tempQuill.setContents(cell.delta);
                                        return tempQuill.getText();
                                    }
                                    // 如果是普通字串
                                    return cell.toString();
                                }


                                // 7. 在應用初始化時，設置新的導覽邏輯
                                // 將這個調用放在現有的 DOMContentLoaded 事件監聽器中
                                document.addEventListener('DOMContentLoaded', () => {
                                    // 替換現有的導航邏輯
                                    setupNewNavigation();
                                });

                                // --- END: 新增「關鍵概念一覽表」功能 ---

                                // 【新增】將數據保存到瀏覽器的 localStorage
                                function saveDataToLocalStorage() {
                                    try {
                                        const now = new Date();
                                        // 將 cardsData 和 decksData 陣列轉換為 JSON 字串並儲存
                                        localStorage.setItem('flashcard_cardsData', JSON.stringify(cardsData));
                                        localStorage.setItem('flashcard_decksData', JSON.stringify(decksData));
                                        // 【已移除】不再儲存 "關鍵概念一覽表" 的數據，以避免超出儲存配額
                                        // localStorage.setItem('flashcard_excelSheets', JSON.stringify(excelSheets));

                                        // 記錄儲存時間
                                        localStorage.setItem('flashcard_lastSaved', now.toISOString());

                                        console.log("數據已成功保存到 localStorage。");
                                        updateLastSavedTimestamp(now); // 更新頁面上的時間顯示
                                    } catch (e) {
                                        console.error("保存數據到 localStorage 失敗:", e);
                                        // 如果儲存失敗（例如空間已滿），可以提示使用者
                                        showNotification("錯誤：無法自動保存您的數據！請嘗試手動匯出。", 5000);
                                    }
                                }

                                // 【新增】更新頁面上顯示的最後儲存時間
                                function updateLastSavedTimestamp(date) {
                                    const timestampEl = document.getElementById('lastSavedTimestamp');
                                    if (timestampEl) {
                                        if (date) {
                                            const dateObj = (typeof date === 'string') ? new Date(date) : date;
                                            timestampEl.textContent = `最後儲存時間：${dateObj.toLocaleString()}`;
                                        } else {
                                            timestampEl.textContent = '最後儲存時間：尚未儲存';
                                        }
                                    }
                                }

                                // 【新增】清除本地儲存的所有數據
                                function clearLocalStorageData() {
                                    customConfirm(
                                        '您確定要清除儲存在這個瀏覽器上的所有字卡和卡組嗎？這個操作無法復原，除非您有另外匯出備份檔案。',
                                        '確認清除所有本地存檔',
                                        (confirmed) => {
                                            if (confirmed) {
                                                // 清除相關的 localStorage 項目
                                                localStorage.removeItem('flashcard_cardsData');
                                                localStorage.removeItem('flashcard_decksData');
                                                localStorage.removeItem('flashcard_lastSaved');
                                                // 【已移除】不再需要清除 excelSheets 的存檔，因為我們已不儲存它
                                                localStorage.removeItem('flashcard_firstVisit'); // 也清除訪問記錄，以便下次顯示歡迎訊息

                                                // 清空記憶體中的數據
                                                cardsData = [];
                                                decksData = [];
                                                excelSheets = {}; // 清除匯入的Sheet數據

                                                // 顯示成功訊息並重新載入頁面，回到初始狀態
                                                showNotification('已清除所有本地存檔。頁面即將重新整理。', 3000);
                                                setTimeout(() => {
                                                    window.location.reload();
                                                }, 3000);
                                            }
                                        }
                                    );
                                }

                                // 【新增】從瀏覽器的 localStorage 載入數據
                                function loadDataFromLocalStorage() {
                                    try {
                                        const savedCards = localStorage.getItem('flashcard_cardsData');
                                        const savedDecks = localStorage.getItem('flashcard_decksData');
                                        const lastSaved = localStorage.getItem('flashcard_lastSaved');
                                        // 【已移除】不再讀取 "關鍵概念一覽表" 的數據
                                        // const savedExcelSheets = localStorage.getItem('flashcard_excelSheets');

                                        if (savedCards) {
                                            cardsData = JSON.parse(savedCards);
                                            console.log(`從 localStorage 載入了 ${cardsData.length} 張字卡。`);
                                        }

                                        if (savedDecks) {
                                            decksData = JSON.parse(savedDecks);
                                            console.log(`從 localStorage 載入了 ${decksData.length} 個卡組。`);
                                        }

                                        // 【已移除】excelSheets 在每次啟動時都會是空的，需要重新匯入
                                        excelSheets = {};


                                        // 載入後更新時間戳顯示
                                        if(lastSaved) {
                                            updateLastSavedTimestamp(lastSaved);
                                        }

                                    } catch (e) {
                                        console.error("從 localStorage 讀取數據失敗:", e);
                                        // 如果解析失敗，重置為空，防止程式崩潰
                                        cardsData = [];
                                        decksData = [];
                                        excelSheets = {}; // 確保在出錯時也清空
                                        showNotification("錯誤：讀取本地存檔失敗，將以空白狀態啟動。", 5000);
                                    }
                                }

                                // 【新增】將數據保存到瀏覽器的 localStorage
                                function saveDataToLocalStorage() {
                                    try {
                                        const now = new Date();
                                        // 將 cardsData 和 decksData 陣列轉換為 JSON 字串並儲存
                                        localStorage.setItem('flashcard_cardsData', JSON.stringify(cardsData));
                                        localStorage.setItem('flashcard_decksData', JSON.stringify(decksData));
                                        // 【新增】儲存 "關鍵概念一覽表" 的數據來源
                                        localStorage.setItem('flashcard_excelSheets', JSON.stringify(excelSheets));

                                        // 記錄儲存時間
                                        localStorage.setItem('flashcard_lastSaved', now.toISOString());

                                        console.log("數據已成功保存到 localStorage。");
                                        updateLastSavedTimestamp(now); // 更新頁面上的時間顯示
                                    } catch (e) {
                                        console.error("保存數據到 localStorage 失敗:", e);
                                        // 如果儲存失敗（例如空間已滿），可以提示使用者
                                        showNotification("錯誤：無法自動保存您的數據！請嘗試手動匯出。", 5000);
                                    }
                                }

                            </script>
                        </body>
                        </html>
